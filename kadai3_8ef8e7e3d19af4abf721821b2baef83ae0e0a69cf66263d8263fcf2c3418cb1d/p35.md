---
layout: page
title: 3-5. メモ化　【15点，プログラムの提出に加え，レポートが必要】
---

再帰呼び出しで$c_{m,n}$を求める過程で，一度求めた$c_{i,j}$の値をメモリに保存しておき，再び必要になった時は再帰呼び出しを行わず，以前求めて保存してあった$c_{i,j}$の値を再利用し，処理を効率化することを**メモ化（memoization）**と呼ぶ．問題3-2で作ったプログラムにメモ化を導入し，メモ化により再帰関数の呼び出し回数が削減されることを確認したい．問題3-2のプログラムを，以下の仕様を満たすプログラムに改変し，メモ化を導入した再帰関数で編集距離を求めるとともに，メモ化の有り・無しのそれぞれの場合において再帰関数の呼び出し回数を計測せよ．

+ 文字列$X$と$Y$は標準入力から与えられ，空白文字（スペースや改行）で区切られる．文字数は100未満であると仮定してよい．
+ 文字列$X$と$Y$のペアはストリームの終端（EOF）に達するまで，複数与えられる．
+ 問題3-2で実装した再帰関数の実装をベースに，メモ化を導入せよ．
+ メモ化の有り・無しのそれぞれの場合において再帰関数を呼び出した回数を計測する．したがって，問題3-2の実装（メモ化無しの再帰関数）も残しておき，再帰関数が呼び出された回数を計測する処理を加えることになる．
+ 再帰関数を呼び出した回数を求めるためにグローバル変数を使ってもよい．
+ 文字列$X$と$Y$のペア毎に，**メモ化を行った再帰関数で求めた$c_{m,n}$の値**を標準出力に書き出せ．さらに，$m$の値，$n$の値，$m \times n$の値，メモ化無しの再帰関数の呼び出し回数，メモ化有りの再帰関数の呼び出し回数をカンマ区切りで標準エラー出力に書き出せ．

さらに，`/opt/local/enshu/data-2019/strings.txt`を標準入力にリダイレクトしてこのプログラムを動かし，$m \times n$と再帰呼び出し回数の関係を，メモ化の有無を区別してグラフにプロットせよ．その際，メモ化の有無での振る舞いの違いが分かるようにプロットせよ．また，メモ化の有無によって呼び出し回数がどのようになるか考察すること．なお，グラフの作成にはgnuplotを使うとよい．

参考: `/opt/local/enshu/data-2019/strings.txt`を標準入力にリダイレクトし，標準エラー出力だけをカレントディレクトリの`calls.txt`というファイルに保存する方法

```
(./a.out < /opt/local/enshu/data-2019/strings.txt > /dev/null) >& calls.txt
```

注意: 再帰関数の呼び出し方法は実装によって異なるため，投稿システムでは正しいかどうか検証しない．このため，再帰関数の呼び出し回数の妥当性を面接で確認することとする．

## 実行例

```
# eat ate
> 2
>> 3,3,9,94,28
# see seen
> 1
>> 3,4,12,193,37
# joti jobutu
> 3
>> 4,6,24,1933,73
```

`#`は標準入力，`>`は標準出力，`>>`は標準エラー出力を表す．

### 参考文献

+ [課題解説資料](./2019_kadai3_intro-Windows-190610.pdf)
