---
layout: page
title: 3-6. ナンプレ解探索
---

---
## 問題
---

ナンバープレイスの問題を与えると，自動で答えを出力するプログラムを作成せよ．

ナンバープレイスとは，9x9の81マスの盤面に対して，1から9までの数字を埋める問題である．
ただし，以下の条件を満たす必要がある．
- 行または列に対して，2つ以上同じ数字があってはいけない
- 3x3の部分的なマスに対しても同じ値が二つ以上出現してはいけない


---
### 仕様
---
+ 課題3-0に記載の課題全体の仕様
  + ただし，この問題の入力は整数なので，入力・出力に関する仕様は無効とする．
  + また，課題3-0に提示してある関数は使用しないでも良い．
  + この問題でも整数型の2次元配列を扱うので，`#include "ppa_extra_h/p3_header.h"`という宣言をし，整数型の2次元配列の確保と開放に`func_mallocation_2d_`関数と`func_free_2d_`関数をそれぞれ用いよ．．


- ナンバープレイスの問題を解くために，必ず再帰関数`rec`を使ってプログラムを構築すること．
  - 関数`rec`の引数は行列の大きさ`N`と二次元配列`data`の二つとする．
  - 関数`rec`の戻り値は条件を満たした解の個数とする．
    ```
    int rec(int N, int** data);
    ```

- 盤面の表示には，`print_matrix_`を使う．
  + 関数`print_matrix_`の引数は行列の大きさ`N`と二次元配列`data`の二つである．
    ```
    void print_matrix_(int N, int** matrix);
    ```
    + 出力形式は，下記の通りとする．
    - 1行目：
    ```
    ⊔⊔⊔#1⊔#2⊔#3⊔#4⊔#5⊔#6⊔#7⊔#8⊔#9↩︎    
    ```    
    - 2行目以降：
    ```
    #1⊔⊔1⊔⊔4⊔⊔5⊔⊔3⊔⊔2⊔⊔7⊔⊔6⊔⊔9⊔⊔8↩
    ```    

- 入力は空白または改行文字で区切られた合計81の0-9の値である．
  - 値は必ず0から9の値であることを仮定して良い．
  - 1-9の値は，事前に決められた値とする．
  - 0は値が決まっていないことを表す．
  - 入力データは，便宜上左上を開始として，行優先で9個の数字で一行を表すとする．
  - 以下の読み込み例に従ってデータを読み込む
    ```
    for (int i = 0; i < N; i++) {    // ???
      for (int j = 0; j < N; j++) {  // ???
        scanf("%d", &(data[i][j]));  // ???
      }
    }
    ```

- 入力データを読み込んだ直後に値を表示する．
  - 9x9の形に整形すること，値が埋まっていない場所は0を表示する．
  - 盤面を表示する前に以下の表示をする．
    ```
    ###⊔INIT↩︎
    ````
+ 入力データがそもそもナンバープレイスの条件を満たしていない場合がある．
  - 入力データが条件を満たしているかチェックし，そもそも条件を満たしていない場合は以下の表示をしてプログラムを終了する．
  ```
  ###⊔INVALID⊔INPUT↩︎
  ```
  + 入力データの条件チェックをする関数`check_invalid`内でチェックすること
    +  関数`check_invalid`の引数は行列の大きさ`N`と二次元配列`data`の二つとする．
    +  関数`check_invalid`の戻り値は，条件を満たしていない場合は1，条件を満たしている場合を0とする．
      ```
      int check_invalid(int N, int** matrix);
      ```


- 答えが見つかったらそれを表示する．
  - 答えが複数ある場合もある．その場合は複数の答えを列挙する．
  - 盤面を表示する前に以下の表示をする．複数答えがある場合は盤面を表示する前に毎回表示する．
    ```
    ###⊔FOUND↩︎
    ````
  - もし答えが見つからなかったら以下の表示をして終了する．
    ```
    ###⊔NOT⊔FOUND↩︎
    ````


- 以下のプログラムを必ず用いてプログラムを完成せること．
  + `???` の部分は適宜補完すること

```
#include <stdio.h>
#include <stdlib.h>

#include "ppa_extra_h/p3_header.h"

  ... 関数前方宣言 ...
void print_matrix_(int N, int** matrix);
int rec(int N, int** data);
int check_invalid(int N, int** matrix);

int main() {
  int N=9;        // ???
  int** data = func_mallocation_2d_(N, N); // ???
  for (int i = 0; i < N; i++) {    // ???
    for (int j = 0; j < N; j++) {  // ???
      scanf("%d", &(data[i][j]));  // ???
    }
  }

  ...(省略)...

  fun_free_2d_(data, N);
  return 0;               //
}


void print_matrix_(int N, int** matrix){
  ...(省略)...

}

int rec(int N, int** data){
  ...(省略)...

}

int check_invalid(int N, int** matrix){
  ...(省略)...

}

```



---
## 実行例
---

---
### 実行例(1)
---


- 入力：
```
0 0 5 3 0 0 0 0 0 8 0 0 0 0 0 0 2 0 0 7 0 0 1 0 5 0 0 4 0 0 0 0 5 3 0 0 0 1 0 0 7 0 0 0 6 0 0 3 2 0 0 0 8 0 0 6 0 5 0 0 0 0 9 0 0 4 0 0 0 0 3 0 0 0 0 0 0 9 7 0 0
```

- 出力：
```
## INIT
     #1 #2 #3 #4 #5 #6 #7 #8 #9
#1  0  0  5  3  0  0  0  0  0
#2  8  0  0  0  0  0  0  2  0
#3  0  7  0  0  1  0  5  0  0
#4  4  0  0  0  0  5  3  0  0
#5  0  1  0  0  7  0  0  0  6
#6  0  0  3  2  0  0  0  8  0
#7  0  6  0  5  0  0  0  0  9
#8  0  0  4  0  0  0  0  3  0
#9  0  0  0  0  0  9  7  0  0
### FOUND
     #1 #2 #3 #4 #5 #6 #7 #8 #9
#1  1  4  5  3  2  7  6  9  8
#2  8  3  9  6  5  4  1  2  7
#3  6  7  2  9  1  8  5  4  3
#4  4  9  6  1  8  5  3  7  2
#5  2  1  8  4  7  3  9  5  6
#6  7  5  3  2  9  6  4  8  1
#7  3  6  7  5  4  2  8  1  9
#8  9  8  4  7  6  1  2  3  5
#9  5  2  1  8  3  9  7  6  4
```

---
### 実行例(2)
---

- 入力：
```
0 0 5 3 0 0 0 0 0 8 0 0 0 0 0 0 2 0 0 7 0 0 1 0 5 0 0 4 0 0 0 0 5 3 0 0 0 1 0 0 7 0 0 0 6 0 0 3 2 0 0 0 8 0 0 6 0 5 0 0 0 0 9 0 0 4 0 0 0 0 3 0 0 0 0 0 0 9 7 0 1
```

- 出力：
```
### INIT
     #1 #2 #3 #4 #5 #6 #7 #8 #9
#1  0  0  5  3  0  0  0  0  0
#2  8  0  0  0  0  0  0  2  0
#3  0  7  0  0  1  0  5  0  0
#4  4  0  0  0  0  5  3  0  0
#5  0  1  0  0  7  0  0  0  6
#6  0  0  3  2  0  0  0  8  0
#7  0  6  0  5  0  0  0  0  9
#8  0  0  4  0  0  0  0  3  0
#9  0  0  0  0  0  9  7  0  1
### NOT FOUND
```

---
### 実行例(3)
---

- 入力：
```
7 0 5 3 0 0 0 0 0 8 0 0 0 0 0 0 2 0 0 7 0 0 1 0 5 0 0 4 0 0 0 0 5 3 0 0 0 1 0 0 7 0 0 0 6 0 0 3 2 0 0 0 8 0 0 6 0 5 0 0 0 0 9 0 0 4 0 0 0 0 3 0 0 0 0 0 0 9 7 0 0
```

- 出力：
```
### INIT
     #1 #2 #3 #4 #5 #6 #7 #8 #9
#1  7  0  5  3  0  0  0  0  0
#2  8  0  0  0  0  0  0  2  0
#3  0  7  0  0  1  0  5  0  0
#4  4  0  0  0  0  5  3  0  0
#5  0  1  0  0  7  0  0  0  6
#6  0  0  3  2  0  0  0  8  0
#7  0  6  0  5  0  0  0  0  9
#8  0  0  4  0  0  0  0  3  0
#9  0  0  0  0  0  9  7  0  0
### INVALID INPUT
```

---
## ヒント
---

ナンバープレイスでは，ランダムに数字を入れていって，条件を満たしているかを判定し，条件が満たされていれば，完成していることがわかる．

しかし，何も工夫しなければ，$9^{81}$通りの盤面が存在するが，実際にはそれほど多くの盤面を調べる必要はない．
- 最初からいくつかの数は提示されている．
- 数字を一つずつ入れていき，上記条件を満たさない場合はそれ以上評価する必要がない．

これらの性質をうまく利用して，効率的なナンプレの自動解法のプログラムを考える．
基本的には，これまで学んできた再帰関数を使うと効率的なプログラムがかける．