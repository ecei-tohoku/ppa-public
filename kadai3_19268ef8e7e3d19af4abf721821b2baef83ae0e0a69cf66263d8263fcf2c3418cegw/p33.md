---
layout: page
title: 3-3. 編集過程の表示
---


ここまでで編集距離そのものは計算できたが，具体的に二つの文字列のどことどこをみて編集したかという情報はわからない．
そこで，どのような編集処理をしたのかを表示するプログラムをつくってみよう．

素朴には,動的計画法の計算過程でコストが最小になるような編集操作を記録しながら計算を進めれば良いと考えられるが,残念ながら動的計画法の計算途中ではどの操作が最終的にコストが小さいか知ることはできない.そこで,動的計画法によって編集距離の操作が終わった後に，最もコストが小さくなる操作を逆順に辿っていくことを考える.
これを一般にバックトレースと呼ぶ．

再び、問題 3-1 の表を参考に考えよう。

| $i \setminus j$ | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | $x_i$ |
|:---------------:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-----:|
|      **0**      | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |       |
|      **1**      | 1 | 1 | 2 | 2 | 3 | 4 | 5 | 6 |   Q   |
|      **2**      | 2 | 2 | 2 | 3 | 2 | 3 | 4 | 5 |   U   |
|      **3**      | 3 | 3 | 3 | 3 | 3 | 3 | 4 | 5 |   E   |
|      **4**      | 4 | 4 | 4 | 4 | 4 | 4 | 3 | 4 |   R   |
|      **5**      | 5 | 5 | 5 | 5 | 5 | 5 | 4 | 4 |   Y   |
|      $y_j$      |   | I | N | Q | U | I | R | E |       |
{: .table .table-striped}

バックトレースの出発点は表の右下、$i=5, j=7, c_{5,7}=4$である。


---
## 問題
---
与えられた文字列$X$を$Y$に変換する編集距離を動的計画法により求めるプログラムに対して，動的計画法のテーブル，および，編集操作を提示するプログラムを実装せよ．

---
### 仕様
---
+ 課題3-0に記載の課題全体の仕様

+ 編集距離を求める関数`get_dp_table_`を用いて編集距離および動的計画法のテーブルを取得すること．
  + 関数`get_dp_table_`は，文字列$X$，文字列$X$の文字列$X$の長さ$m$，文字列$Y$，文字列$Y$の長さ$n$，動的計画法用の二次元配列テーブル`dpt`の5つを引数にとる．
  + 例：
    ```
    void get_dp_table_(char *X, int m, char *Y, int n, 
                       int dpt[m＋1]][n+1]);
    ```


+ 動的計画法用の二次元配列テーブル`dpt`を表示すること．
  + 関数`show_matrix`を用いること．
    + 引数は，文字列$X$，文字列$X$の長さ$m$，文字列$Y$，文字列$Y$の長さ$n$，動的計画法用の二次元配列テーブル`dpt`の5つを引数にとる．
    + `get_dp_table_`の実行後に表示すること．
  + 実行例や以下の例を参考にし，文字列$X$を左端（縦）に，文字列$Y$を先頭（横）に出力し，$c_{i,j} (i \in \{0, 1, ..., m\}, j \in \{0, 1, ..., n\})$のすべての値をスペース区切りの行列形式で出力せよ．行末に余分なスペースを出力しないように注意せよ．
    + 出力先は標準出力とする．
    + 1行目は文字列$Y$の文字をスペース区切りで出力せよ．行頭に4文字分のスペースを挿入せよ．
    + 2行目は$c_{0,j}$の値をスペース区切りで出力せよ．行頭に2文字分のスペースを挿入せよ．
    + 3行目以降は，行頭に$x_i$の文字，続けて$c_{i,j}$の値をスペース区切りで出力せよ．
    + 出力例：    eat ate
      ```
          a t e
        0 1 2 3
      e 1 1 2 2
      a 2 1 2 3
      t 3 2 1 2
      ```

+ 編集操作を表示すること
  + 関数`show_matrix`の後に実行すること．
  + 実行例を参考にし，`show_matrix`表示後の一行目に文字列$X$，2行目に文字列$Y$，3行目に編集操作列を出力せよ．
    + 出力先は標準出力とする．
    + 編集操作は`=` (copy)，`I` (insert), `D` (delete), `R` (replace) とする．
    + 3行目の編集操作列に対応するように，1行目と2行目に出力される文字の位置を調整せよ．
    + **行末に余分なスペースを出力しないように注意すること．**
      + 例えば，下記の `eat ate` に対する出力例において，`eat` の後ろに余分なスペースを出力してはならない．
        ```
        eat 
         ate
        D==I
        ```
  + `get_dp_table_`により得られた動的計画法用の二次元配列テーブルから算出すること．
  + 編集操作を求めるときは，コピー／置換を優先する．


+ 題3-0に提示してある関数を`ppa_extra_h/p3_header.h`というファイルにおいてある．`#include "ppa_extra_h/p3_header.h"`という宣言を通して含め、以下の関数を必要に応じて用いること．
  + `vmax_`
  + `vmax3_`
  + `vmin_`
  + `vmin3_`
  + `zeros_`
  + `read_string_`
  + `count_len_`


+ 以下のプログラムを必ず用いてプログラムを完成せること．
  + `???` の部分は適宜補完すること

```
#include <stdio.h>
#include <stdlib.h>

#include "ppa_extra_h/p3_header.h"

void show_matrix(char *X, int m, char *Y, int n, int dpt[m + 1][n + 1]);
int get_ops(char *X, int m, char *Y, int n, int dpt[m + 1][n + 1],
            char *seq_x, char *seq_y, char *ops);


int main() {
  int N = 21;                      // ???
  char *data_x = read_string_(N);  // ???
  char *data_y = read_string_(N);  // ???
  int len_x = count_len_(data_x);  // ???
  int len_y = count_len_(data_y);  // ???
  int dpt[len_x + 1][len_y + 1];   // ???
  get_dp_table_(data_x, len_x, data_y, len_y, dpt);  // ???

  ...(省略)...

  free(data_x);  // ???
  free(data_y);  // ???
  return 0;      // ???
}


void show_matrix(char *X, int m, char *Y, int n, int dpt[m + 1][n + 1]){

  ...(省略)...

}
int get_ops(char *X, int m, char *Y, int n, int dpt[m + 1][n + 1],
            char *seq_x, char *seq_y, char *ops){

  ...(省略)...

}
```


---
## 実行例
---
---
### 例(1)
---

+ 入力
```
eat ate
```

+ 出力
```
    a t e
  0 1 2 3
e 1 1 2 2
a 2 1 2 3
t 3 2 1 2
eat 
 ate
D==I
```

---
### 例(2)
---

+ 入力
```
abababab abababc
```

+ 出力
```
   a b a b a b c
  0 1 2 3 4 5 6 7
a 1 0 1 2 3 4 5 6
b 2 1 0 1 2 3 4 5
a 3 2 1 0 1 2 3 4
b 4 3 2 1 0 1 2 3
a 5 4 3 2 1 0 1 2
b 6 5 4 3 2 1 0 1
a 7 6 5 4 3 2 1 1
b 8 7 6 5 4 3 2 2
abababab
ababab c
======DR
```


