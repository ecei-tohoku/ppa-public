---
layout: page
title: 3-3. 編集距離(動的計画法版)
---

---
### 動的計画法
---

問題 3-1,3-2 のプログラムでは，文字列 $X$ と $Y$ の編集距離 $c_{m,n}$ を，与えられた文字列長から順に遡って（$c_{m, n}, c_{m-1, n-1}, c_{m, n-1}, ..., c_{0,0}$）再帰的に計算した.

本問題では，編集距離を効率的に計算する別の方法として，**動的計画法 (Dynamic Programming)** に基づく編集距離の計算を考える．(動的計画法という言葉を最初に使い始めたのは最適制御理論の研究において顕著な活躍をした Richard Belleman である.**次元の呪い**という表現を最初に用いたのも彼のようである.)

動的計画法はアルゴリズムの分類の一つであり,簡単に言えば,「部分問題の最適解を得ることを繰り返すことにより全体の問題の最適解を求める手法」である．以下では，編集距離を例にして動的計画法の考え方を説明する.


編集距離の漸化式より，$c_{i,j}$ を求めるためには，$c_{i-1,j-1}, c_{i-1,j}, c_{i,j-1}$ の3つの値が必要である．これを視覚的に理解するために， $X=QUERY, Y=INQUIRE$の場合を考えよう.:

| $i \setminus j$ | 0 |   1   |   2   |   3   | 4 | 5 | 6 | 7 | $x_i$ |
|:---------------:|:-:|:-----:|:-----:|:-----:|:-:|:-:|:-:|:-:|:-----:|
|      **0**      | 0 |   1   |   2   |   3   | 4 | 5 | 6 | 7 |       |
|      **1**      | 1 | ``1`` | ``2`` | ``2`` | 3 | 4 | 5 | 6 |   Q   |
|      **2**      | 2 | ``2`` | ``A`` | ``B`` | 2 | 3 | 4 | 5 |   U   |
|      **3**      | 3 |   3   |   3   |   3   | 3 | 3 | 4 | 4 |   E   |
|      **4**      | 4 |   4   |   4   |   4   | 4 | 4 | 3 | 4 |   R   |
|      **5**      | 5 |   5   |   5   |   5   | 5 | 5 | 4 | 4 |   Y   |
|      $y_j$      |   |   I   |   N   |   Q   | U | I | R | E |       |
{: .table .table-striped}

表の上では，とある編集距離 ($c_{i,j}$) を計算するためには，(1) その**左上** ($c_{i-1,j-1}$)，(2) その**左隣** ($c_{i,j-1}$)，(3) その**真上** ($c_{i-1,j}$) の値が必要である．裏を返せば，これらの3つの値が計算済みであれば，それらに囲まれるマスの値を計算できるということである．例えば，$c_{2,2}$ (``A``) は，その左上，左隣，真上である $c_{1,1},c_{1,2},c_{2,1}$ の値を利用して，$min(c_{1,1}+1,c_{1,2}+1,c_{2,1}+1)=min($``1``$+1,$``2``$+1,$``2``$+1)=2$ と求まる．

この位置関係に着目すると，表の一行目は，左から右へ値を五月雨式に埋めることができる．さらに，一行目の値が決まれば，二行目も左から右へ値を埋めていくことができる．例えば，$c_{2,3}$ (``B``) は，左隣の $c_{2,2}$ (``A``) の計算結果を利用し，$min(c_{1,2}+1,c_{2,2}+1,c_{1,3}+1)=min($``2``$+1,$``A``$=$``2``$+1,$``2``$+1)=3$ と求まる．同様に $c_{2,4},c_{2,5},...,c_{3,1},c_{3,2},...,c_{5,7}$ と計算をしていけば全ての値が埋まり，最終的に文字列 $X$ と $Y$ の編集距離 $c_{m,n}$ を求めることができる．

以上のように，再帰計算の深いところから順に値を求めていく（**ボトムアップ (bottom up) に求める**ともいう.）方法は，計算回数を $X$ と $Y$ の文字列長の積 $mn$ に抑えることができ，重複して部分的な編集距離を計算することはないため，単純な再帰計算を用いるプログラムよりも多くの場面で効率的である．


---
## 問題
---
与えられた文字列$X$を$Y$に変換する編集距離を動的計画法により求めるプログラムを実装せよ．

---
### 仕様
---
+ 課題3-0に記載の課題全体の仕様

+ 動的計画用の二次元配列テーブル`dpt`は課題3-2と同じく,`func_mallocation_2d_`を用いてメモリを確保せよ.
  + `dpt`の大きさは文字列の長さに合わせて必要十分な大きさとすること．
  + `main`関数の最後ではメモリの開放を課題3-2と同じく,`func_free_2d_`を用いて行うこと.
  
  

+ 文字列$X$，文字列$X$の長さ$m$，文字列$Y$，文字列$Y$の長さ$n$，動的計画法用の二次元配列テーブル`dpt`の5つを引数にとり，編集距離を返す関数`ld_dp`を作成すること
  + 例：
  ```
  int ld_dp(char *X, int m, char *Y, int n, int **dpt);
  ```

+ 文字列$X$の位置$a$の文字と文字列$Y$の位置$b$の文字が等しい場合に0，違う場合に1を返す関数`delta`を作成し，それを関数`ld_dp`の中で用いること
  + 例：
  ```
  int delta(char *X, int a, char *Y, int b);
  ```

+ 標準出力に以下の出力をする．
  + 1行目に入力文字列$X$とその長さを表示する．
  + 2行目に入力文字列$Y$とその長さを表示する．
  + 3行目に編集距離を表示する．
    + 余計な空白などは入れないこと．
  + 実行例(1)の場合
    ```
    eat⊔3↩︎
    ate⊔3↩︎
    2↩︎
    ```
   

+ 問題3-0に提示してある関数を`ppa_extra_h/p3_header.h`というファイルにおいてある．`#include "ppa_extra_h/p3_header.h"`という宣言を通して含め、以下の関数を必要に応じて用いること．
  + `vmax_`
  + `vmax3_`
  + `vmin_`
  + `vmin3_`
  + `zeros_`
  + `read_string_`
  + `count_len_`

＋ 以下のプログラムを必ず用いてプログラムを完成せること．
  + `???` の部分は適宜補完すること

```
#include <stdio.h>
#include <stdlib.h>

#include "ppa_extra_h/p3_header.h"

int delta(char *X, int a, char *Y, int b);                 // ???
int ld_dp(char *X, int m, char *Y, int n, int **dpt);      // ???

/////////////////////////////////////////
int main() {
  int N = 21;                             // ???
  char *data_x = read_string_(N);         // ???
  char *data_y = read_string_(N);         // ???
  int len_x = count_len_(data_x);         // ???
  int len_y = count_len_(data_y);         // ???
  int **dpt = func_mallocation_2d_(??, ??); // ???

  ...(省略)...

  func_free_2d_(dpt, ???);
  free(data_x);  // ???
  free(data_y);  // ???
  return 0;      // ???
}

/////////////////////////////////////////

int delta(char *X, int a, char *Y, int b) {

  ...(省略)...

}

/////////////////////////////////////////

int ld_dp(char *X, int m, char *Y, int n, int **dpt) {

  ...(省略)...

}
```




---
## 実行例
---

---
## 例(1)
---

+ 入力
```
eat ate
```

+ 出力
```
eat 3
ate 3
2
```

---
## 例(2)
---

+ 入力
```
see seen
```

+ 出力
```
see 3
seen 4
1
```





---
## 参考資料
---

- [秋葉 拓哉, プログラミングコンテストでの動的計画法](http://www.slideshare.net/iwiwi/ss-3578511)


