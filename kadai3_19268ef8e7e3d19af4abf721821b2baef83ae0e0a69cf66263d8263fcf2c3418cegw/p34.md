---
layout: page
title: 3-4. 編集距離(再帰+メモ化)
---


---
## メモ化
---
問題 3-1 のプログラムでは，文字列 $X$ と $Y$ の編集距離 $c_{m,n}$ を，与えられた文字列長から順に遡って再帰的に計算した．しかし，この方法では，同じ値を複数回計算してしまう可能性があるため，効率面で問題がある．
本問題では，再帰処理を効率的に行う手法として**メモ化(memoization)**について学ぶ。

メモ化の考えは非常に単純であり,

  + $c_{m,n}$ を求める過程で,一度計算した $c_{i,j}$の値をメモリに保存する.
  + 再び必要になった時は再帰呼び出しを行わず,以前求めて保存してあった $c_{i,j}$ の値を再利用する.
  
このような処理をメモ化と呼ぶ.
これにより,一度計算したものを再び計算する必要がないため,計算量は指数関数的に改善される.



---
## 問題
---


問題3-1で実装したプログラムにメモ化を導入し,メモ化ありの場合とメモ化なしの場合の再帰関数の呼び出し回数を比較せよ.



---
### 仕様
---
+ 課題3-1に記載の仕様．ただし，「以下のプログラムを必ず用いてプログラムを完成せること」の部分は除く．

+ 問題3-1で実装した再帰関数をベースに,メモ化を導入せよ. 関数名は'ldmemo'とする．文字列$X$，文字列$X$の先頭から$m$文字目の場所を表すインデックス$m$，文字列$Y$，文字列$Y$の先頭から$n$文字目の場所を表すインデックス$n$，メモを記憶する2次元配列memo[M][N]の5つを引数にとること
  + 例：
  ```
  int ldmemo(char *X, int m, char *Y, int n, int memo[M][N]);int ld(char *X, int m, char *Y, int n);
  ```

+ aaa

　+ 例：
　```
　aaa
　```


+ <font color="red">この問題に限り、再帰関数を呼び出した回数を求めるために,グローバル変数を用いてもよい.</font>

+ 表示
  + 一行目に文字列$X$ とその長さ $n$ を、二行目に文字列 $Y$ とその長さ $n$ を表示すること.
  + 三行目にメモ化なしの再帰関数で求めた $c_{m,n}$ の値とメモ化なしの再帰関数の呼び出し回数を表示すること.
  + 四行目にメモ化ありの再帰関数で求めた $c_{m,n}$ の値とメモ化ありの再帰関数の呼び出し回数を表示すること.
  
  
  メモ化を行った再帰関数で求めた $c_{m,n}$ の値,$m$の値,$n$の値,$m\times n$の値,メモ化なしの再帰関数の呼び出し回数,メモ化ありの再帰関数の呼び出し回数を標準出力に書き出せ.

+ メモ化の有り・無しのそれぞれの場合において再帰関数を呼び出した回数を計測する.したがって，問3-1の実装(メモ化無しの再帰関数)も残しておき，再帰関数が呼び出された回数を計測する処理を加えことになる.


---
## 実行例
---
