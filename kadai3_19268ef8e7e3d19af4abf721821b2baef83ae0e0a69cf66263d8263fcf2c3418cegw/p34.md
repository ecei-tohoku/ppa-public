---
layout: page
title: 3-4. 編集距離(再帰+メモ化)
---


---
## メモ化
---
問題 3-1 のプログラムでは，文字列 $X$ と $Y$ の編集距離 $c_{m,n}$ を，与えられた文字列長から順に遡って再帰的に計算した．しかし，この方法では，同じ値を複数回計算してしまう可能性があるため，効率面で問題がある．
本問題では，再帰処理を効率的に行う手法として**メモ化(memoization)**について学ぶ。

メモ化の考えは非常に単純であり,

  + $c_{m,n}$ を求める過程で,一度計算した $c_{i,j}$の値をメモリに保存する.
  + 再び必要になった時は再帰呼び出しを行わず,以前求めて保存してあった $c_{i,j}$ の値を再利用する.
  
このような処理をメモ化と呼ぶ.
これにより,一度計算したものを再び計算する必要がないため,計算量は指数関数的に改善される.



---
## 問題
---


問題3-1で実装したプログラムにメモ化を導入し,メモ化ありの場合とメモ化なしの場合の再帰関数の呼び出し回数を比較せよ.

なお，メモ化ありの呼び出し回数は，その最小値を求めよ．


---
### 仕様
---
+ 課題3-1に記載の課題全体の仕様．ただし，「以下のプログラムを必ず用いてプログラムを完成させること」の部分は除く．

+ 問題3-1で実装した再帰関数をベースに,メモ化を導入せよ.関数名は"ldmemo"とする．この関数は，文字列$X$，文字列$X$の先頭から$m$文字目の場所を表すインデックス$m$，文字列$Y$，文字列$Y$の先頭から$n$文字目の場所を表すインデックス$n$，メモを格納する2次元配列memo[M][N]の5つを引数にとり，編集距離を返す．
  + 例：
  ```	
  int ldmemo(char *X, int m, char *Y, int n, int memo[M][N]);
  ```


+ <font color="red">この問題に限り、再帰関数を呼び出した回数を求めるために,グローバル変数を用いてもよい.</font>

+ 表示
  + 一行目に文字列$X$ とその長さ $n$ を、二行目に文字列 $Y$ とその長さ $n$ を表示すること.
  + 三行目にメモ化なしの再帰関数で求めた $c_{m,n}$ の値とメモ化なしの再帰関数の呼び出し回数を表示すること.
  + 四行目にメモ化ありの再帰関数で求めた $c_{m,n}$ の値とメモ化ありの再帰関数の呼び出し回数を表示すること.
  
  
  メモ化を行った再帰関数で求めた $c_{m,n}$ の値,$m$の値,$n$の値,$m\times n$の値,メモ化なしの再帰関数の呼び出し回数,メモ化ありの再帰関数の呼び出し回数を標準出力に書き出せ.


+ 以下のプログラムを必ず用いてプログラムを完成させること．
  + `???` の部分は適宜補完すること
  
```
#include <stdio.h>
#include <stdlib.h>

#include "ppa_extra_h/p3_header.h"

int delta(char *X, int a, char *Y, int b);  // ???
int ld(char *X, int m, char *Y, int n);     // ???
int ldmemo(char *X, int m, char *Y, int n, int memo[M][N]);     // ???

int main() {
  int N = 21;                      // ???
  char *data_x = read_string_(N);  // ???
  char *data_y = read_string_(N);  // ???
  int len_x = count_len_(data_x);  // ???
  int len_y = count_len_(data_y);  // ???
  int memo[len_x+1][len_y+1];

  ...(省略)...

  free(data_x);  // ???
  free(data_y);  // ???
  return 0;      // ???
}


int delta_( ??? ) {

  ...(省略)...

};


int ld( ??? ) {

  ...(省略)...

}


int ld( ??? ) {

  ...(省略)...

}
```


---
## 実行例
---
