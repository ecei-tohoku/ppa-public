---
layout: page
title: 3-5. 共通部分文字列のマッチング数
---

長さ $n$ の文字列 $X=(x_1 x_2 x_3 \dots x_n)$ が与えられたときに,

+ $X$を構成する文字を0文字以上取り除く
+ 残った文字を元の順番で並べる

ことによって得られる文字列を $X$ の部分文字列と呼ぶ.
例として, $X=edcba$ を考えると,二文字目と五文字目を取り除いた $ecb$ は部分文字列であるが,それを並び替えた $ebc$ や $bce$ は部分文字列ではない.


二つの文字列 $X=(x_1,x_2,\cdots,x_m)$ と $Y=(y_1, y_2,\cdots, y_n)$ が与えられたときに, $X$ と $Y$ の共通部分文字列のマッチング数 $N_{\rm match}$ を求める問題を考えよう.<font color="red">ただし, $X$ や $Y$ から取り除いてできる部分文字列が同じものだとしても,取り除き方の異なる操作によって生じる部分文字列は,異なる部分文字列として見なすことにする.</font>

例として, $X=aab$, $Y=ba$ の場合を考えると, $X$ から二文字目と三文字目を取り除いてできる $a$ と, $X$ から一文字目と三文字目を取り除いてできる $a$ を区別するということを意味する.したがって、共通部分文字列のマッチング数 $N_{\rm match}$ は, $(a,a,b)$ の3通りである<font color="red">(空文字は含めない)</font>.

次に,一般的な場合を考えよう.編集距離を求めた時と同じように,マッチング数を求めるために,再帰的な関係を定義したい.
素朴には, $X$ と $Y$ の接頭辞をそれぞれ $X_{i}, Y_{j}$として, $X_{i-1}$ と $Y_{j-1}$のマッチング数, $X_{i-1}$ と $Y_{j}$のマッチング数, $X_{i-1}$ と $Y_{j-1}$のマッチング数の三つを用いて, $X_i$ と $Y_j$ のマッチング数を表せば良いと考えられるが,重複が生じてしまい計算が非常に複雑になる.

そこで、漸化式に現れる量の定義を工夫しよう. ${\rm dp}[i][j]$を次のように定義する. 

${\rm dp}[i][j]$:= ($X$ の最初 $i$ 文字と, $Y$ の最初 $j$ 文字からできる共通部分列のうち,最後の文字が等しく($x_i=y_j$),かつこれを含んでいる部分文字列の個数)

(ここでは, $i=1,2,\cdots m$, $j=1,2,\cdots, n$としてカウントしていることに注意せよ.0からのカウントではない.)
さらに, $x_i \neq y_j$ の場合は,${\rm dp}[i][j]=0$ と定義する.
このように定義すれば, ${\rm dp}[i][j]$ には重複が存在せず,　$N_{\rm match}$ と ${\rm dp}[i][j]$ の間には次の関係が成立する.

$$
N_{\rm match} = \sum_{i=1}^m \sum_{j=1}^n {\rm dp}[i][j].
$$

定義より, $x_i=y_j$ のとき, ${\rm dp}[i][j]$ には次のような再帰関係が成立する.

$$
{\rm dp}[i][j] = \sum_{k=1}^{i-1} \sum_{l=1}^{j-1}{\rm dp}[k][l]+1.
$$

この関係式を用いれば, 原理的にはマッチング数を求めることができるが,計算量が大きくなってしまう.
そこで,さらに新しい変数

$${\rm sumdp}[i][j]=\sum_{k=1}^{i} \sum_{l=1}^{j}{\rm dp}[k][l],
$$

を導入すると, 単純な計算により,次のような関係が成立することが分かる.

$$
{\rm sumdp}[i][j]={\rm sumdp}[i-1][j] + {\rm sumdp}[i][j-1] -{\rm sumdp}[i-1][j-1] + {\rm dp}[i][j].
$$

以上をまとめると,マッチング数 $N={\rm sumdp}[m][n]$ を求めるためには,次の漸化式を解けば良い.

$$
{\rm dp}[i][j] = \begin{cases}
{\rm sumdp}[i-1][j-1] +1. & (x_i = y_j) \\
0 & (x_i \neq y_j)
\end{cases},
$$

$$
{\rm sumdp}[i][j]={\rm sumdp}[i-1][j] + {\rm sumdp}[i][j-1] -{\rm sumdp}[i-1][j-1] + {\rm dp}[i][j],
$$

ただし,$i=0$ または $j=0$ のとき,

$$
{\rm sumdp}[i][j]={\rm dp}[i][j]=0,
$$

である.

---
## 問題
---
二つの文字列 $X$ と $Y$ が与えられる．
この $X$ と $Y$ の共通部分文字列のマッチング数 $N_{\rm match}$ を動的計画法を用いて求めよ．


---
### 仕様
---
+ 課題3-0に記載の課題全体の仕様

+ 共通部分列のマッチング数を求めるために，動的計画法用の二次元配列テーブル`dp`, `sumdp`の二種類を,課題3-2と同じく,`func_mallocation_2d_`を用いて用意すること．
  + `dp`, `sumdp`の大きさは文字列の長さに合わせて必要十分な大きさとすること．
  + `main`関数の最後ではメモリの開放を課題3-2と同じく,`func_free_2d_`を用いて行うこと.

+ 共通部分列のマッチング数を求める関数`ssk`を作成すること．
  + 関数`ssk`は，文字列 $X$ ，文字列 $X$ の長さ $m$ ，文字列 $Y$ ，文字列 $Y$ の長さ $n$ ，動的計画法用の二次元配列テーブル`dp`, `sumdp`の6つを引数にとる．
    ```
    int ssk(char* X, int m, char* Y, int n, int **dp, int **sumdp) ;
    ```
  + 関数`ssk`の戻り値は文字列 $X$ と文字列 $Y$ のマッチング数とする．

+ 表示

  + 一行目に文字列 $X$ とその長さ $m$ を、二行目に文字列 $Y$ とその長さ $n$ を表示すること.  
  + 三行目から,動的計画法用の二次元配列テーブル`dp`, `sumdp`の計算結果を実行例に従って表示すること．
    + 関数`show_table`を用いること．
      + 引数は，表示する動的計画法用の二次元配列テーブル`K`，大きさ`M`および`N`の3種
      ```
      void show_table(int M, int N, int **K);
      ```
    + 全ての整数は三桁分の表示スペースを確保する．つまり，表示対象が二桁の場合は三桁目に空白を,表示対象が一桁の場合は二桁目と三桁目に空白を入れること．

  + 最後の行に共通部分文字列のマッチング数を出力すること．
  + 実行例(1)の場合
    ```
    eat⊔3↩︎
    ate⊔3↩︎
    ###⊔dp↩︎
    #⊔⊔⊔0⊔⊔⊔0⊔⊔⊔0⊔⊔⊔0↩︎
    #⊔⊔⊔0⊔⊔⊔0⊔⊔⊔0⊔⊔⊔1↩︎
    #⊔⊔⊔0⊔⊔⊔1⊔⊔⊔0⊔⊔⊔0↩︎
    #⊔⊔⊔0⊔⊔⊔0⊔⊔⊔2⊔⊔⊔0↩︎
    ###⊔sumdp↩︎
    #⊔⊔⊔0⊔⊔⊔0⊔⊔⊔0⊔⊔⊔0↩︎
    #⊔⊔⊔0⊔⊔⊔0⊔⊔⊔0⊔⊔⊔1↩︎
    #⊔⊔⊔0⊔⊔⊔1⊔⊔⊔1⊔⊔⊔2↩︎
    #⊔⊔⊔0⊔⊔⊔1⊔⊔⊔3⊔⊔⊔4↩︎
    4↩︎
    ```

+ 問題3-0に提示してある関数を`ppa_extra_h/p3_header.h`というファイルにおいてある．`#include "ppa_extra_h/p3_header.h"`という宣言を通して含め、以下の関数を必要に応じて用いること．
  + `vmax_`
  + `vmax3_`
  + `vmin_`
  + `vmin3_`
  + `zeros_`
  + `read_string_`
  + `count_len_`


+ 以下のプログラムを必ず用いてプログラムを完成せること．
  + `???` の部分は適宜補完すること

```
#include <stdio.h>
#include <stdlib.h>

#include "ppa_extra_h/p3_header.h"

void show_table(int M, int N, int **K);
int ssk(char* X, int m, char* Y, int n, 
        int **dp, int **sumdp) ;

int main() {
  int N = 21;                      
  char* data_x = read_string_(N);  
  char* data_y = read_string_(N);  
  int len_x = count_len_(data_x);  
  int len_y = count_len_(data_y);  
  int **dp = func_mallocation_2d_(??, ??);
  int **sumdp = func_mallocation_2d_(??, ??);

  ...(省略)...

  func_free_2d_(dp, ??);
  func_free_2d_(sumdp, ??);
  free(data_x);
  free(data_y);
  return 0;
}

void show_table( ??? ){

  ...(省略)...

}


int ssk( ??? ) {

  ...(省略)...

}
```


---
## 実行例
---
---
### 例(1)
---

+ 入力データ
```
eat ate
```

+ 出力例
```
eat 3
ate 3
### dp
#   0   0   0   0
#   0   0   0   1
#   0   1   0   0
#   0   0   2   0
### sumdp
#   0   0   0   0
#   0   0   0   1
#   0   1   1   2
#   0   1   3   4
4
```

---
### 例2
---

+ 入力データ
```
abababab abcabcabc
```

+ 出力例
```
abababab 8
abcabcabc 9
### dp
#   0   0   0   0   0   0   0   0   0   0
#   0   1   0   0   1   0   0   1   0   0
#   0   0   2   0   0   3   0   0   4   0
#   0   1   0   0   4   0   0   8   0   0
#   0   0   3   0   0  10   0   0  22   0
#   0   1   0   0   8   0   0  26   0   0
#   0   0   4   0   0  22   0   0  70   0
#   0   1   0   0  13   0   0  61   0   0
#   0   0   5   0   0  40   0   0 171   0
### sumdp
#   0   0   0   0   0   0   0   0   0   0
#   0   1   1   1   2   2   2   3   3   3
#   0   1   3   3   4   7   7   8  12  12
#   0   2   4   4   9  12  12  21  25  25
#   0   2   7   7  12  25  25  34  60  60
#   0   3   8   8  21  34  34  69  95  95
#   0   3  12  12  25  60  60  95 191 191
#   0   4  13  13  39  74  74 170 266 266
#   0   4  18  18  44 119 119 215 482 482
482
```

