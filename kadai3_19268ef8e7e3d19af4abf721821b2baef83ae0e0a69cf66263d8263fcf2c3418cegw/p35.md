---
layout: page
title: 3-5. 共通部分文字列のマッチング数
---

二つの文字列 $X=(x_1,x_2,\cdots,x_m)$ と $Y=(y_1, y_2,\cdots, y_n)$ が与えられたときに, $X$ と $Y$ の共通部分文字列のマッチング数 $N$ を求める問題を考えよう.
ただし, $X$ や $Y$ から取り除いてできる部分文字列が同じものだとしても,取り除き方の異なる操作によって生じる部分文字列は,異なる部分文字列として見なすことにする.

例として, $X=aab$, $Y=ba$ の場合を考えると,Xから二文字目と三文字目を取り除いてできる $a$ と, $X$ から一文字目と三文字目を取り除いてできる $a$ を区別するということを意味する.したがって、共通部分文字列のマッチング数 $N$ は, $(a,a,b)$ の3通りである.

次に,一般的な場合を考えよう.編集距離を求めた時と同じように,マッチング数を求めるために,再帰的な関係を定義したい.
素朴には, $X$ と $Y$ の接頭辞をそれぞれ $X_{i}, Y{j}$として, $X_{i-1}$ と $Y{j-1}$のマッチング数, $X_{i-1}$ と $Y{j}$のマッチング数, $X_{i-1}$ と $Y_{j-1}$のマッチング数の三つを用いて, $X$の接頭辞$X_i$と$Y$の接頭辞$Y_j$のマッチング数を表せば良いと考えられるが,重複が生じてしまい計算が非常に複雑になる.

そこで、漸化式を定義する際の定義を工夫しよう. $dp[i][j]$を次のように定義する. 

$dp[i][j]$: $X$ の 最初 $i$ 文字と, $Y$ の最初 $j$　文字からできる共通部分列のうち,最後の文字が等しく($x_i=y_j$),かつこれを含んでいる部分列の個数

ここでは, $i=1,2,\cdots m$, $j=1,2,\cdots, n$としてカウントしていることに注意せよ.0からのカウントではない.
さらに,$x_i \neq y_j$ の場合は,$dp[i][j]=0$ と定義する.
このように定義すれば, $dp[i][j]$ には重複が存在せず,　$N$ と$dp[i][j]$の間には次の関係が成立する.

$$
N = \sum_{i=1}^m \sum_{j=1}^n dp[i][j].
$$

さらに,定義より,$x_i=y_j$のとき, $dp[i][j]$ には次のような再帰関係が成立する.

$$
dp[i][j] = \sum_{k=1}^{i-1} \sum_{l=1}^{j-1}dp[k][l]+1.
$$

この関係式を用いれば, 原理的にはマッチング数を求めることができるが,計算量が大きくなってしまう.
そこで,新しい変数$sdp[i][j]=\sum_{k=1}^{i} \sum_{l=1}^{j}dp[k][l]$を導入すると, 単純な計算により,次のような関係が成立することが分かる.

$$
sdp[i][j]=sdp[i-1][j] + sdp[i][j-1] -sdp[i-][j-1] + dp[i][j].
$$

以上をまとめると,マッチング数 $N$ を求めるためには,次の再帰式を解けば良い.

$$
dp[i][j]=sdp[i-1][j-1] +1.
$$

$$
sdp[i][j]=sdp[i-1][j] + sdp[i][j-1] -sdp[i-][j-1] + dp[i][j].
$$

---
## 問題
---
二つの文字列$X$と$Y$が与えられる．
この$X$と$Y$の共通部分文字列のマッチング数$N$を動的計画法を用いて求めよ．


---
### 仕様
---
+ 課題3-0に記載の課題全体の仕様

+ 共通部分文字列のマッチング数を求めるために，動的計画法用の二次元配列テーブル`K0`, `K1`, `K2`の三種類を用意すること．
  + `K0`, `K1`, `K2`の大きさは文字列の長さに合わせて必要十分な大きさとすること．

+ 共通部分文字列のマッチング数を求める関数`ssk`を作成すること．
  + 関数`ssk`は，文字列`X`，文字列`X`の長さ`M`，文字列`Y`，文字列`Y`の長さ`N`，動的計画法用の二次元配列テーブル`K0`, `K1`, `K2`の7つを引数にとる．
    ```
    int ssk(char* X, int M, char* Y, int N, 
            int K0[M][N], int K1[M][N], int K2[M][N]) ;
    ```
  + 関数`ssk`の戻り値は文字列`X`と文字列`Y`のマッチング数とする．



+ 動的計画法用の二次元配列テーブル`K0`, `K1`, `K2`の計算結果を実行例に従って表示すること．
  + 関数`show_table`を用いること．
    + 引数は，表示する動的計画法用の二次元配列テーブル`K`，大きさ`M`および`N`の3種
    ```
    void show_table(int M, int N, int K[M][N]);
    ```

+ 共通部分文字列のマッチング数を最後の行に出力すること．

+ 題3-0に提示してある関数を`ppa_extra_h/p3_header.h`というファイルにおいてある．`#include "ppa_extra_h/p3_header.h"`という宣言を通して含め、以下の関数を必要に応じて用いること．
  + `vmax_`
  + `vmax3_`
  + `vmin_`
  + `vmin3_`
  + `zeros_`
  + `read_string_`
  + `count_len_`


+ 以下のプログラムを必ず用いてプログラムを完成せること．
  + `???` の部分は適宜補完すること

```
#include <stdio.h>
#include <stdlib.h>

#include "ppa_extra_h/p3_header.h"

void show_table(int M, int N, int K[M][N]);
int ssk(char* X, int M, char* Y, int N, 
        int K0[M][N], int K1[M][N], int K2[M][N]) ;

int main() {
  int N = 21;                      // ???
  char* data_x = read_string_(N);  // ???
  char* data_y = read_string_(N);  // ???
  int len_x = count_len_(data_x);  // ???
  int len_y = count_len_(data_y);  // ???
  int k0[len_x][len_y];
  int k1[len_x][len_y];
  int k2[len_x][len_y];

  ...(省略)...

  free(data_x);
  free(data_y);
  return 0;
}

void show_table( ??? ){

  ...(省略)...

}


int ssk( ??? ) {

  ...(省略)...

}
```


---
## 実行例
---
---
### 例(1)
---

+ 入力データ
```
eat ate
```

+ 出力例
```
eat 3
ate 3
### k0
#   0   0   1
#   1   0   0
#   0   2   0
### k1
#   0   0   0
#   0   0   1
#   1   0   1
### k2
#   0   0   0
#   0   0   0
#   0   1   1
4
```

---
### 例2
---

+ 入力データ
```
abababab abcabcabc
```

+ 出力例
```
abababab 8
abababc 7
### k0
#   1   0   1   0   1   0   0
#   0   2   0   3   0   4   0
#   1   0   4   0   8   0   0
#   0   3   0  10   0  22   0
#   1   0   8   0  26   0   0
#   0   4   0  22   0  70   0
#   1   0  13   0  61   0   0
#   0   5   0  40   0 171   0
### k1
#   0   0   0   0   0   0   0
#   1   0   1   0   1   0   0
#   1   2   1   3   1   4   0
#   2   2   5   3   9   4   0
#   2   5   5  13   9  26   0
#   3   5  13  13  35  26   0
#   3   9  13  35  35  96   0
#   4   9  26  35  96  96   0
### k2
#   0   0   0   0   0   0   0
#   0   1   1   2   2   3   3
#   0   1   3   4   7   8  12
#   0   2   4   9  12  21  25
#   0   2   7  12  25  34  60
#   0   3   8  21  34  69  95
#   0   3  12  25  60  95 191
#   0   4  13  39  74 170 266
482
```

---
## ヒント
---
