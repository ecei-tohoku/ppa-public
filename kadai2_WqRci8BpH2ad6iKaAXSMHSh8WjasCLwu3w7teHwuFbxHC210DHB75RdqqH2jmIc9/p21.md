---
layout: page
title: 2-1. 配列の逆順置換【初歩】
---

与えられたデータを一定の大小関係に基づいて並べ替えることを**ソート**と呼ぶ．
「並べ替える」というと単純そうだが，ソートの手順（**アルゴリズム**）には様々なバリエーションが存在し，またこれらを学ぶ中で**計算量**（complexity）や**再帰**（recursion）といった重要な概念に触れることができるため，ソートは計算機科学のカリキュラムに必ず登場する基本的なトピックとなっている．

課題2では，様々なソートアルゴリズムを実装することを通して，それぞれのソートアルゴリズムがどのように値を並び替えているかを学ぶ．

- 課題2-2: 選択に基づくソート (選択ソート)
- 課題2-3: 交換に基づくソート (バブルソート)
- 課題2-4: 挿入に基づくソート (挿入ソート)
- 課題2-5: 分解/結合に基づくソート (マージソート)
- 課題2-6: 比較に基づかないソート (基数ソート)
- 課題2-7: 選択に基づくソート 改良版 (ヒープソート)

本課題では，ソートアルゴリズムそのものを学ぶことだけではなく，ソートアルゴリズムを作成することを通して，<font color="red">関数</font>，<font color="red">動的メモリ確保</font>，<font color="red">再帰処理</font>，<font color="red">ポインタ</font>に関する知識も合わせて学ぶ．
例えば，できるだけ利用するメモリを少なくすることを念頭に動的メモリ確保を用いてプログラムを作成する．
また，ソート処理を関数に分けて書くことで，処理の再利用性を高める練習をする．

さらに、本課題の質問は、整数の配列内のデータを中心に展開される. 課題2は動的メモリ割り当てを使用するのに、概念は、`int array [N]`（`N`は配列の長さ）の形式で課題1で使用された配列に似ている。 質問ごとに、初期入力には配列の初期内容が含まれる. さらに、実装されたアルゴリズム中に、配列を並べ替えるために、配列の内容が交換される. 本課題、配列の内容は配列データと呼ばれる.

---
## <font color="red">！！重要！！　課題全体を通しての仕様</font>
---

課題を通しての仕様を説明する (各設問で追加の仕様や注意書きがある場合はそちらを優先する)．

- グローバル変数や静的変数を使用してはいけない．
- `include`するファイルは`<stdio.h>`および`<stdlib.h>`のみとする．
- プログラム全体の構成を以下に従うようにする．
  - `main`関数の正常終了時の戻り値0にする．
  - 関数の前方宣言を用い，関数本体は`main`関数の下に記述する．
    ```
      #include <stdio.h>
      #include <stdlib.h>

        ... 事前に与えられる関数の定義 ...

      //////

        ... 課題ごとの関数前方宣言 ...

      int main()
      {

        ...（main関数本体）...

        return 0;
      }

        ... 課題ごとの関数本体 ...
      ```
  - ただし，課題ごとに与えられるコードを記載する場所は，それぞれの指示に従う．

- ~~変数の宣言は関数の先頭でおこなうこと (途中の宣言は不可とする)~~ C99 より前（ANSI C まで）のかなり古いC言語では、変数の宣言はブロック（ `{}` ）の先頭であることを求められていましたが、現行の C ではこれは不要です.

- 入力データの読み込み/配列の動的確保
  - 入力データは正の整数のみと仮定して良い．正の整数が空白または改行区切りで並んでいると仮定する．
  - 入力データを読み込む際には，事前に定義された`func_mallocation_`関数を用いて，データの格納に必要なメモリ領域を動的に確保すること．
  - 動的に確保したメモリ領域は処理が完了した後に解放すること（関数`free`などを使うこと)
  - 入力データの読み込は`main` 関数内で行うこと．

- 配列の要素へのアクセス
  - 入力データを読み込んだ配列の要素へのアクセスは，事前に用意された専用の関数を用いること．それ以外の方法でアクセスすることを禁止する．以下例を挙げる．
    - 要素間の入れ替え：`func_swap_`関数
    - 要素のコピー：`func_copy_val_`関数
    - 要素感の比較：`comp_`関数
    - 要素の表示：`print_array_`関数
  - それぞれの課題で利用可能な関数を確認すること．

- 事前に定義されている関数(基本的に関数名の最後に`_`がついているもの)の中身を書き換えてはいけない．これらの関数は例えば，`printf`や`scanf`と同様に中身を書き換えられない関数として扱うこと．

- 表示例の`⊔` は半角スペース，`↩︎`は改行を表す．
- 表示(出力)
  - 全ての表示は標準出力にすること．ただし，標準エラー出力への表示が必要な場合は各課題の仕様に記載する．
  - 全ての出力には改行文字 `\n` を付けること．特に最後の行の改行の有無に注意すること．
  - 各要素の間には空白文字を一つ入れる．
  - 改行前の空白文字などの表示されない文字を出力しないこと．

  - 入力データを動的に確保した配列内に読み込んだ直後に配列を表示すること．
    - 必ず`main`関数内で呼び出すこと．
    - 書式は各課題の指示に合わせること．
    - 例： 配列データ 10 2 8 4 11 9 12 5 3 13 1 7 6 場合
      ```
      INIT:::::::⊔10⊔⊔2⊔⊔8⊔⊔4⊔11⊔⊔9⊔12⊔⊔5⊔⊔3⊔13⊔⊔1⊔⊔7⊔⊔6↩︎
      ```
    - 全ての整数は二桁分の表示スペースを確保する．つまり，表示対象が一桁の場合は，空白を一つ二桁目に入れること．
  - 課題の処理が完了し`main`関数を終了する前に，最終状態の配列データを表示すること．
    - 合わせて比較回数の表示を求めらた場合はその指示に従うこと．
      - 比較回数はその課題で最も少なくなるようにすること．
    - 必ず`main`関数内で呼び出すこと．
    - 書式は各課題の指示に合わせること．
    - 例： 配列データ 1 2 3 4 5 6 7 8 9 10 11 12 13, 比較回数 15 の場合
  	  ```
      DONE:::::::⊔⊔1⊔⊔2⊔⊔3⊔⊔4⊔⊔5⊔⊔6⊔⊔7⊔⊔8⊔⊔9⊔10⊔11⊔12⊔13↩︎
      15↩︎
	    ```
    - 全ての整数は二桁分の表示スペースを確保する．つまり，表示対象が一桁の場合は，空白を一つ二桁目に入れること．




---
## 問題
---

以下のプログラムは与えられた配列データを読み込み，逆順にして出力する．このプログラムにコメントを追加せよ．

---
## 仕様
---

- 上記記載の仕様を満たすこと．

- "// ???"となっている箇所にコメントを追加すること．コメントは，プログラムの要約や意図を記述していること．

- 配列操作関数
  - `func_swap_`: 配列内の二つの要素を入れ替える．
  - `comp_`: 配列内の二つの要素を比較する．
  - `print_array_`: 配列内の要素を表示する．

- `reverse_array` 関数は配列を逆順に並び替える．以下の仕様を満す．
  - 配列の要素を逆順に並び替える操作は全てこの関数内で行う．
  - 入力データ用に動的に確保した配列と入力データの個数の二つを引数とすること．
    ```
    int reverse_array(int *array, int N) ...
    ```
  - 要素間の比較`comp_`の呼び出し回数を`reverse_array` 関数の戻り値とする．
  - 要素の値が同じ場合など，入れ替える必要がない場合は入れ替えない．

- 表示
  - 入力データを動的に確保した配列内に読み込んだ直後に配列を表示する．
    - 書式は，上記の全体の仕様に記載の書式とする．
  - 逆順にする処理が終わった後の配列データ，および，比較回数表示する．
    - 書式は，上記の全体の仕様に記載の書式とする．
	- `func_swap_`により値を入れ替えるたびに，入れ替えた要素の場所と配列全体の要素を以下の書式で表示する
    - 交換した2つの要素番号$i,j(i<j)$を用いて SWAP$(i,j)$ と表示し，空白後に交換後の配列の全要素を表示する．ただし，交換が実行されなかった場合は何も表示してはいけない．
  	- 例：要素番号0,12の要素を交換した場合
	  	```
      SWAP(⊔0,12)⊔⊔6⊔⊔2⊔⊔8⊔⊔4⊔11⊔⊔9⊔12⊔⊔5⊔⊔3⊔13⊔⊔1⊔⊔7⊔10↩︎
      ```

- 以下のプログラムを必ず用いてプログラムを完成せること．
  - コメントがない関数にコメントを入れること．
  - すでに書かれているコメントは，書き写す必要はない．

```
#include <stdio.h>
#include <stdlib.h>

void func_swap_(  // 配列内の2つの要素を交換し、操作をSTDOUTに出力
    int* const array,  // 要素が交換される配列
    const int pos_a,   // 1番目の交換対象の要素番号
    const int pos_b    // 2番目の交換対象の要素番号
) {
  int tmp = array[pos_a];       // array[pos_a]の値をtmpに退避
  array[pos_a] = array[pos_b];  // array[pos_a]にarray[pos_b]を代入
  array[pos_b] = tmp;           // 退避したarray[pos_a]の値をarray[pos_b]に代入
  printf("SWAP(%2d,%2d)", pos_a, pos_b);
}

int comp_(             // 配列内の2つの要素を比較する関数
    int* const array,  // 要素の比較を行う配列
    const int pos_a,   // 1つ目の比較対象の要素番号
    const int pos_b    // 2つ目の比較対象の要素番号
) {
  if (array[pos_a] < array[pos_b]) return 1;  // ???
  return 0;                                   // ???
}

void print_array_(           // 配列をSTDOUTに表示する関数
    const int* const array,  // 表示する配列
    const int N              // 配列の要素数
) {
  for (int i = 0; i < N; ++i) {
    printf(" %2d", array[i]);
  }
  printf("\n");
}

int* func_mallocation_(  // 配列の動的メモリ確保をおこなう関数
    const int N          // 配列の要素数
) {
  int* data = (int*)malloc(N * sizeof(int));  // ???
  if (data == NULL) { // メモリ確保に失敗した際のエラー処理
    printf("Can not allocate memory. 'data' is NULL.\n");
    exit(EXIT_FAILURE);
  }
  return data;  // 確保した配列のポインタを戻り値として返す
}


int reverse_array(int*, int);

int main() {
  int N;       // 入力配列の要素数
  scanf("%d", &N);               // STDINから要素数を受け取る
  int* array = func_mallocation_(N);  // 配列に動的メモリを割り当てる
  for (int i = 0; i < N; i++)
    scanf("%d", &(array[i]));  // STDINから配列要素を受け取る
  printf("INIT:::::::");
  print_array_(array, N);             // 配列の初期状態をSTDOUTに出力
  int cnt = reverse_array(array, N);  // 入力配列を逆順
  printf("DONE:::::::");
  print_array_(array, N);  // 配列の最終状態をSTDOUTに出力
  printf("%d\n", cnt);     // comp_が呼んだ合計回数を出力

  free(array);  // 配列に割り当てられた動的メモリを解放
  return 0;     // ???
}

int reverse_array(  // ???
    int* array,     // ???
    int N           // ???
) {
  int pos_a = 0;       // ???
  int pos_b = N - 1;   // ???
  int comp_count = 0;  // ???

  while (pos_a < pos_b) {  // ???
    comp_count += 2;       // ???

    if ((comp_(array, pos_a, pos_b) +   // ???
        comp_(array, pos_b, pos_a))	// ???
	== 1) {   			// ???
      func_swap_(array, pos_a, pos_b);  // ???
      print_array_(array, N);           // ???
    }
    pos_a++;  // ???
    pos_b--;  // ???
  }
  return comp_count;  // ???
}
```

---
## 手順
---
- まず，上記プログラムを書きうつす．
- 追加する必要があるコメントは`???`に置き換えられた．
- `???`の代わりに`main`と`func_swap_`にある例に従ってコメントを追加せよ．

---
## 実行例
---
---
### 実行例(1)
---
- 入力データ
```
5 1 1 1 1 1
```
- 出力例
```
INIT:::::::  1  1  1  1  1
DONE:::::::  1  1  1  1  1
4
```

---
### 実行例(2)
---
- 入力データ
```
13 10 2 8 4 11 9 12 5 3 13 1 7 6
```
- 出力例
```
INIT::::::: 10  2  8  4 11  9 12  5  3 13  1  7  6
SWAP( 0,12)  6  2  8  4 11  9 12  5  3 13  1  7 10
SWAP( 1,11)  6  7  8  4 11  9 12  5  3 13  1  2 10
SWAP( 2,10)  6  7  1  4 11  9 12  5  3 13  8  2 10
SWAP( 3, 9)  6  7  1 13 11  9 12  5  3  4  8  2 10
SWAP( 4, 8)  6  7  1 13  3  9 12  5 11  4  8  2 10
SWAP( 5, 7)  6  7  1 13  3  5 12  9 11  4  8  2 10
DONE:::::::  6  7  1 13  3  5 12  9 11  4  8  2 10
12
```

---
### 実行例(3)
---
- 入力データ
```
10 1 2 1 1 2 1 1 2 2 1
```
- 出力例
```
INIT:::::::  1  2  1  1  2  1  1  2  2  1
SWAP( 2, 7)  1  2  2  1  2  1  1  1  2  1
SWAP( 4, 5)  1  2  2  1  1  2  1  1  2  1
DONE:::::::  1  2  2  1  1  2  1  1  2  1
10
```




---
## 参考情報
---
---
### 関数
---

C 言語のプログラムは，`main` 関数内に動作させたい内容を記述すればよいが，プログラムの規模が大きくなるにつれて，`main` 関数の内容が膨大になってしまう．このような場合，適当な大きさの関数に分割してプログラムを書くことが多い．たとえば，繰り返し計算する部分を関数として実装することで，別の箇所から何回も呼び出すことができる．ここでは，関数を使ったプログラムを作成しよう．

---
### メモリ領域の動的確保
---

C言語では, int a[5]; のように, 配列を宣言して使用するためには具体的に要素数を指定する必要があります．
しかしこの仕組みは，今回の課題のように，配列の要素数が入力等から得られるまで不定の場合には不都合が生じてしまいます．
例えば，int a[5]; として用意した配列に10個の配列要素を読み込ませることはできませんし，
かといってあらかじめ int a[500]; のように多めに配列を用意していても，実際に入力される要素数が10や20だった場合は貴重なメモリ容量の無駄遣いになってしまいます．

C言語ではこのようにプログラムを実行するまで配列の要素数が決まらない場合に
必要に応じて必要なだけ配列要素を確保する `malloc`(えむあろっく，まろっく)と言う関数が用意されています．
今回の課題のように標準入力から配列の要素数が 10 と入力された場合は 
```
int *x;
x = ( int * ) malloc ( 10 * sizeof ( int ) );
```
のように `malloc` 関数を使用します．
`malloc` 関数は確保した領域の先頭ポインタを返すため、[] 演算子を用いることで
x[0],x[1],x[5] 等のようにポインタ x をあたかも配列 int x[10]; と宣言した場合のように扱うことができます．
(`malloc`関数を用いる場合は必ず確保に失敗した場合のエラー処理と `free` による解放処理を行ってください．)

- 高橋：10.4 文字列の操作
- 林：17.3 メモリ管理
