---
layout: page
title: 2-4. 挿入ソート
---


ここでは，<font color="red">挿入に基づくソート</font>である<font color="red">挿入ソート (insersion sort)</font>を実装してみよう．

挿入ソートの基本操作は，<font color="red">すでにソート済みの配列に対して，一つ要素を新たに（ソートされた状態を保持しつつ）追加/挿入</font>することである．

- 今，配列の先頭から$i-1$番目の要素までは昇順にソートされていると仮定する．
- この時，$i$番目の要素と先頭から$i-1$番目までの要素を合わせて$i$個の値をソートすることを考える．
- この場合，すでに$i-1$番目まではソートされているのだから，$i$番目の要素が$i-1$番目までのソート済みの要素のどこに入るかわかれば，そこに値を入れるだけで$i$個の要素はソートされる．
- ただし，$k$番目に$i$番目の要素の値を入れるためには，$k$番目から$i-1$番目までの現在の要素を一つずつ後ろにずらして入れ直す必要がある．
- そこで，$i-1$番目から逆順に$i$番目の要素と値を比較していき，（現在$k$番目の要素と$i$番目の要素を比較する場合）
  - $i$番目の要素が小さければ，$k$番目の要素を$k+1$にコピーして，$k=k-1$する．
  - もし，$i$番目の要素が小さくなければ，$i$番目の要素の値を$k+1$番目にコピーする．

![Insert Sort](https://i.imgur.com/NECQzAd.png)

---
## 問題
---
与えられた配列データを<font color="red">挿入ソート</font>により<font color="red">昇順</font>に並べ替えるプログラムを作成せよ．

---
### 仕様
---

- 課題2-1に記載の仕様全て

- 挿入ソートを実行するためには，挿入対象の値を一度別の場所に退避する必要がでてくる．
  - データを読み込む配列を動的確保する際に，一つ余計に確保する．つまりデータの要素数が$N$なら$N+1$個のメモリを確保すること．
  - 余計に確保したメモリを挿入対象の値を一時退避する場所として利用すること．

- 配列操作に利用可能な関数
  - 配列内の要素を配列内の別の場所にコピーする手続きとして`func_copy_val_`関数を用いること．これは，挿入対象の値を退避したり挿入する場合も含まれる．
  - 課題2-4では`func_swap_`は用いない
  - 配列内の二つの要素を比較する手続きとして`comp_`関数を用いること．
  - 配列内の要素を表示する手続きとして`print_array_`関数を用いること．
 
- 配列を選択ソートによって並び替える `ins_sort` 関数を作成すること．また，以下の仕様を満すこと．
  - 配列の要素を並び替える操作は全てこの関数内で行うこと．
    - ただし，この関数内で呼ばれる別の関数を作成してもよい．その際は必ず前方宣言すること．
  - 入力データ用に動的に確保した配列と入力データの個数の二つを引数とすること．
    - 例：
    ```
    int ins_sort(int *array, int N) ...
    ```
  - 要素間の比較`comp_`の呼び出し回数を`ins_sort` 関数の戻り値とすること．
  - 要素の値が同じ場合など，入れ替える必要がない場合は入れ替えてはいけない．

- 表示
  ```
  int* func_copy_val_(
      int* const array,
      const int pos_a,
      const int pos_b
  ) {
    array[pos_b] = array[pos_a];
    return array;
  }
  ```
  - 上にある`func_copy_val_`により退避した値を配列に挿入する際に，入れ替えた要素の場所(退避する前の要素番号と挿入した要素番号)と配列全体の要素を以下の書式で表示すること．
    - 交換した2つの要素番号$k,i(k<i)$を用いて INST$(i,k)$ と表示し，空白後に交換後の配列の全要素を表示する．ただし，交換が実行されなかった場合は何も表示してはいけない．
  	- 例：要素番号0,12の要素を交換した場合
    ```
    INST(⊔0,12)⊔⊔6⊔⊔2⊔⊔8⊔⊔4⊔11⊔⊔9⊔12⊔⊔5⊔⊔3⊔13⊔⊔1⊔⊔7⊔10↩︎
    ```
    
    - 全体的な出力例は実行例を参照のこと．
  - `func_copy_val_`により配列ないの値を後ろにずらす際には表示はしないこと．

- 題2-1に提示してある関数と`func_copy_val_`を`ppa_extra_h/p2_header.h`というファイルにおいてある．`#include "ppa_extra_h/p2_header.h"`という宣言を通して含めたら、こちらの関数を書かなくても呼べる：`func_swap_`、`comp_`、`print_array_`、`func_mallocation_`、`func_copy_val_`

- 以下のプログラムを必ず用いてプログラムを完成せること．

```
#include <stdio.h>
#include <stdlib.h>
#include “ppa_extra_h/p2_header.h”

int ins_sort(int *, int);

int main() {

  ...(省略)...

  return 0;               //
}

int ins_sort(int *array, int N) {

  ...(省略)...

}
```



---
## 実行例
---
---
### 実行例(1)
---
- 入力データ
```
7 2 1 3 7 4 6 5
```
- 出力例
```
INIT:::::::  2  1  3  7  4  6  5
INST( 1, 0)  1  2  3  7  4  6  5
INST( 4, 3)  1  2  3  4  7  6  5
INST( 5, 4)  1  2  3  4  6  7  5
INST( 6, 4)  1  2  3  4  5  6  7
DONE:::::::  1  2  3  4  5  6  7
10
```


---
### 実行例(2)
---
- 入力データ
```
13 10 2 8 4 11 9 11 5 3 13 1 2 6
```
- 出力例
```
INIT::::::: 10  2  8  4 11  9 11  5  3 13  1  2  6
INST( 1, 0)  2 10  8  4 11  9 11  5  3 13  1  2  6
INST( 2, 1)  2  8 10  4 11  9 11  5  3 13  1  2  6
INST( 3, 1)  2  4  8 10 11  9 11  5  3 13  1  2  6
INST( 5, 3)  2  4  8  9 10 11 11  5  3 13  1  2  6
INST( 7, 2)  2  4  5  8  9 10 11 11  3 13  1  2  6
INST( 8, 1)  2  3  4  5  8  9 10 11 11 13  1  2  6
INST(10, 0)  1  2  3  4  5  8  9 10 11 11 13  2  6
INST(11, 2)  1  2  2  3  4  5  8  9 10 11 11 13  6
INST(12, 6)  1  2  2  3  4  5  6  8  9 10 11 11 13
DONE:::::::  1  2  2  3  4  5  6  8  9 10 11 11 13
53
```


---
### 実行例(3)
---
- 入力データ
```
7 2 1 1 2 3 1 2
```
- 出力例
```
INIT:::::::  2  1  1  2  3  1  2
INST( 1, 0)  1  2  1  2  3  1  2
INST( 2, 1)  1  1  2  2  3  1  2
INST( 5, 2)  1  1  1  2  2  3  2
INST( 6, 5)  1  1  1  2  2  2  3
DONE:::::::  1  1  1  2  2  2  3
11
```
