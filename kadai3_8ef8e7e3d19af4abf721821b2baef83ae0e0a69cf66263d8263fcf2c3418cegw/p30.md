---
layout: page
title: 3-0. 文字列操作
---

---
## 問題
---
与えられた文字列$X$と$Y$に共通して出現する文字を辞書順に列挙せよ

---
### 課題を全体通した仕様
---
+ 値の大小関係を取得
  + 2または3つの整数の最大，最小値を取得したい場合に以下の関数を用いること．
  + 以下の関数が不要な場合は使わなくても良い．ただし同様の関数を再定義することは不可とする．
  + 2つの値のうち小さい方の値を取得する場合
    + `vmin_`を使う
    ```
    int vmin_(int a, int b);
    ```
    + 例；`vmin_(1 ,3 )` なら戻り値は`1`
  + 2つの値のうち大きい方の値を取得する場合
    + `vmax_`を使う
    ```
    int vmax_(int a, int b);
    ```
    + 例：`vmax_(2 ,3 )` なら戻り値は`3`
  + 3つの値のうち最も小さい値を取得する場合
    + `vmin3_`を使う
    ```
    int vmin3_(int a, int b，int c);
    ```
    + 例：`vmin3_(2, 1, 3)` なら戻り値は`1`
  + 3つの値のうち最も大きい値を取得する場合
    + `vmax3_`を使う
    ```
    int vmax3_(int a, int b，int c);
    ```
    + 例：`vmax3_(3, 2 ,1)` なら戻り値は`3`

+ 文字列用のメモリ確保と標準入力からの文字列読み込み
  + 関数 `read_string_`を用いること

+ 文字列の長さの取得
  + 関数 `count_len_`を用いること

+ 文字列用の配列を`\0`で初期化
  + 関数 `zoros_`を用いること


---
### 仕様
---
+ 文字列$X$や$Y$は標準入力から与えられる
  + 空白文字（スペースや改行）で区切られる．
  + 文字数は20以下であると仮定してよい．

+ 文字列$X$，文字列$X$の先頭から$M$文字目の場所を表すインデックス$M$，文字列$Y$，文字列$Y$の先頭から$N$文字目の場所を表すインデックス$N$, マッチした文字を保存する配列`buf`の5つを引数にとり，マッチした数を返す関数`find_matching`を作成すること
  + 例：
  ```
  int find_matching(char *X, int M, char *Y, int N);
  ```

+ マッチした文字をソートする関数`sort_buf`を用いること．
  + 引数に，文字の配列`buf`と個数`n`をとること．
  + 例：
  ```
  int sort_buf(char *buf, int N);
  ```

+ 標準出力に以下の週力をする．
  + 1行目に入力文字列$X$とその長さを表示する．
  + 2行目に入力文字列$Y$とその長さを表示する．
  + 3行目以降にマッチした文字を辞書順に1行1文字で表示する．
    + 余計な空白などは入れないこと．


＋ 以下のプログラムを必ず用いてプログラムを完成せること．
  + `???` の部分は適宜補完すること

```
int vmax_(int x, int y) { return x > y ? x : y; };                 // ???
int vmax3_(int a, int b, int c) { return vmax_(a, vmax_(b, c)); }  // ???
int vmin_(int x, int y) { return x < y ? x : y; };                 // ???
int vmin3_(int a, int b, int c) { return vmin_(a, vmin_(b, c)); }  // ???

void zeros_(     // ???
    char* data,  // ???
    int N        // ???
) {
  for (int i = 0; i < N; ++i) {
    data[i] = '\0';  // ???
  }
}

char* read_string_(  // ???
    const int N      // ???
) {
  char* data = (char*)malloc(N * sizeof(char));  // ???
  if (data == NULL) {                            // ???
    printf("Can not allocate memory. 'data' is NULL.\n");
    exit(1);  // ???
  }
  zeros_(data, N);            // ???
  scanf("%s", data);          // ???
  if (data[N - 1] != '\0') {  // ???
    printf("Reading invalid string\n");
    exit(1);  // ???
  }
  return data;  // ???
}

int count_len_(        // ???
    const char* array  // ???
) {
  int ri = 0;
  while (array[ri] != '\0') {  // ???
    ri++;
  }
  return ri;  // ???
}


int find_matching(char* X, int M, char* Y, int N, char* buf);
void sort_buf(char* buf, int N);


int main() {
  int N = 21;                      // ???
  char* data_x = read_string_(N);  // ???
  char* data_y = read_string_(N);  // ???
  int len_x = count_len_(data_x);  // ???
  int len_y = count_len_(data_y);  // ???
  char buf[vmin_(len_x, len_y)];   // ???

  int cnt = find_matching(data_x, len_x, data_y, len_y, buf);  // ???
  sort_buf(buf, cnt);                                          // ???

  printf("%s %d\n", data_x, len_x);  // ???
  printf("%s %d\n", data_y, len_y);  // ???

  char prev = '\0';                // ???
  for (int i = 0; i < cnt; ++i) {  // ???
    if (prev == buf[i]) continue;  // ???
    printf("%c\n", buf[i]);        // ???
    prev = buf[i];                 // ???
  }
  free(data_x);  // ???
  free(data_y);  // ???
  return 0;      // ???
}


int find_matching(  // ???
    char* X,        // ???
    int M,          // ???
    char* Y,        // ???
    int N,          // ???
    char* buf       // ???
) {
  int cnt = 0;  // ???
  for (int i = 0; i < M; ++i) {
    for (int j = i; j < N; ++j) {
      // ???
      if (X[i] == Y[j]) {  // ???
        buf[cnt] = X[i];   // ???
        cnt++;             // ???
      }
    }
  }
  return cnt;  // ???
}


void sort_buf(  // ???
    char* buf,  // ???
    int N       // ???
) {
  // ???
  for (int i = 0; i < N; ++i) {
    for (int j = 1; j < N - i; ++j) {
      // ???
      if (buf[j] < buf[j - 1]) {
        char tmp = buf[j];    // ???
        buf[j] = buf[j - 1];  // ???
        buf[j - 1] = tmp;     // ???
      }
    }
  }
}
```


---
## 実行例
---

---
### 例（1）
---

+ 入力
```
eat ate
```

+ 出力
```
eat 3
ate 3
e
```

---
### 例（2）
---

+ 入力
```
abababab abababc
```

+ 出力
```
abababab 8
abababc 7
a
b
```





### 参考文献

