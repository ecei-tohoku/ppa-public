---
layout: page
title: 3-1. 再帰手続きによる編集距離
---

2つの文字列の類似性が測定できると役に立つ場合がある．
例えば，`GATCGGCAT`と`CAATGTGAATC`の2つの塩基配列に対して，次のような対応付けを行うことで，これらの塩基配列の類似度合いを調べることができる．

```
G ATCG GCAT
CAAT GTGAATC
RI==D=I=R==I
```

なお，`=`は文字が一致している箇所，`R`は文字が異なっている場所，`D`は上側に文字を挿入した箇所，`I`は下側に文字を挿入した箇所である．
また，修正前と修正後のソースコードの類似部分を見つけることで，ソースコードに加えられた変更点（diff）を調べることができる（以下の例では`=`を`==`に修正）．

```
before: if (flag = 1) { printf("found\n"); }
after:  if (flag == 1) { printf("found\n"); }
```

本課題では，2つの文字列$X = \langle x_1, x_2, ..., x_m \rangle$と$Y = \langle y_1, y_2, ..., y_n \rangle$の類似性を測定する方法として，**編集距離（edit distance）**に取り組む．


---
### 編集距離の定義
---

編集距離について理解するため，文字列$X$の先頭から任意回の**編集操作**を逐次適用していき，文字列$Y$に等しい文字列$Z = \langle z_1, z_2, ..., z_n \rangle$を得る手続きを考える．**編集操作**とは，「$X$ の 2 文字目を $Z$ の 3 番目の変数にコピーする」などの「$X$ の $i$ 番目の文字 $x_i$ の情報を使って，$Z$ の $j$ 番目の変数 $z_j$ を変更する操作」をいう．

以上を形式的に表現してみよう．まず，$Z$の初期状態を空文字列とする（$j = 1, 2, ..., n$ に対して $z_j = \phi$）．$X,Z$ の編集操作の対象となる添字を変数 $i,j$ で表現し，初期状態を $i=j=1$ とする．すると，前述の手続きは，「$Y$ と等しい $Z$ を得るまで (1) 編集操作の適用，(2) 操作対象の添字 $i,j$ の更新，を繰り返す」という手続きで表現できる．ここで，可能な編集操作は，次のものとする．

+ **copy**: $X$の1文字を$Z$にコピーする．つまり，代入$z_j \gets x_i$を行い，$i$と$j$にそれぞれ$1$を加える．
+ **replace**: $X$の1文字を別の文字$\alpha$に置換する．つまり，代入$z_j \gets \alpha$を行い，$i$と$j$にそれぞれ$1$を加える．
+ **delete**: $X$の1文字を消去する．つまり，$j$を変更せずに$i$に$1$を加える．
+ **insert**: 文字$\alpha$を$Z$に挿入する．つまり，代入$z_j \gets \alpha$を行ったうえで，$j$だけに$1$を加える．

例えば，$X = \langle a,l,g,o,r,i,t,h,m \rangle$に編集操作を適用し，$Z=\langle  a,l,t,r,u,i,s,t,i,c \rangle$を得る過程の例を示す．
ここで，$X$の太字と$Z$のアスタリスク（*）は，操作対象の添字 $i,j$ を表す．$Z$ の アンダーバー (_) は，空文字を表す．

| 現在の $X$            | 適用する操作     | 操作適用後の $Z$      | 操作適用後の $i$ | 操作適用後の $j$ |
|:----------------------|:-----------------|:----------------------|:-----------------|:-----------------|
| **a** l g o r i t h m | 初期化           | * _ _ _ _ _ _ _ _ _   | 1                | 1                |
| **a** l g o r i t h m | copy             | a * _ _ _ _ _ _ _ _   | 2                | 2                |
| a **l** g o r i t h m | copy             | a l * _ _ _ _ _ _ _   | 3                | 3                |
| a l **g** o r i t h m | replace with 't' | a l t * _ _ _ _ _ _   | 4                | 4                |
| a l g **o** r i t h m | delete           | a l t * _ _ _ _ _ _   | 5                | 4                |
| a l g o **r** i t h m | copy             | a l t r * _ _ _ _ _   | 6                | 5                |
| a l g o r **i** t h m | insert 'u'       | a l t r u * _ _ _ _   | 6                | 6                |
| a l g o r **i** t h m | insert 'i'       | a l t r u i * _ _ _   | 6                | 7                |
| a l g o r **i** t h m | insert 's'       | a l t r u i s * _ _   | 6                | 8                |
| a l g o r **i** t h m | insert 't'       | a l t r u i s t * _   | 6                | 9                |
| a l g o r **i** t h m | copy             | a l t r u i s t i *   | 7                | 10               |
| a l g o r i **t** h m | replace with 'c' | a l t r u i s t i c * | 8                | 11               |
| a l g o r i t **h** m | delete           | a l t r u i s t i c * | 9                | 11               |
| a l g o r i t h **m** | delete           | a l t r u i s t i c * | 10               | 11               |
{: .table .table-striped}

一般的に，ある文字列を別の文字列に変換する編集過程は複数存在することに注意せよ．

さて，各編集操作$a$にコスト${\rm cost}(a)$が定義されているとすれば，上記の編集過程で要するコストは，次のように計算できる．

$$
4 \times {\rm cost}(\mbox{copy}) + 1 \times {\rm cost}(\mbox{replace}) + 3 \times {\rm cost}(\mbox{delete}) + 5 \times {\rm cost}(\mbox{insert})
$$

本課題では，${\rm cost}(\mbox{copy}) = 0$，${\rm cost}(\mbox{replace}) = {\rm cost}(\mbox{delete}) = {\rm cost}(\mbox{insert}) = 1$とする．したがって，編集過程のコストの総和は$9$である．

一般的に，2つの文字列$X = \langle x_1, x_2, ..., x_m \rangle$と$Y = \langle y_1, y_2, ..., y_n \rangle$，および編集操作コストが与えられたとき，**$X$から$Y$への編集距離とは，$X$を$Y$に変換する編集操作列のコストの最小値である．**

---
### 編集距離の求め方
---

編集距離を効率良く求める問題を考える．まず，**接頭辞 (prefix)** という概念を導入する．

+ ある文字列$X = \langle x_1, x_2, ..., x_m \rangle$の長さ$p \in \{0, 1, ..., m\}$の**接頭辞**を$X_p = \langle x_1, x_2, ..., x_p \rangle$と定義する．例えば，$X = \langle A, T, C, G \rangle$に対し，$X_2 = \langle A, T \rangle$である．$X_0$は空文字列である．

$X$の接頭辞$X_i$（$i \in \{0, 1, ..., m\}$），$Y$の接頭辞$Y_j$（$j \in \{0, 1, ..., n\}$）の編集距離を$c_{i,j}$と書くと，以下の再帰的な式が成り立つ．

$$
c_{i,j} = \begin{cases}
\max (i, j) & i = 0 \mbox{ または } j = 0 \mbox{ のとき} \\
\min \begin{cases}
c_{i-1, j-1} + d_{x_i \neq y_j},\\
c_{i-1, j} + 1,\\
c_{i, j-1} + 1,\\
\end{cases} & それ以外
\end{cases}
$$

ただし，$d_{x_i \neq y_j}$は，$x_i = y_j$ならば$0$，$x_i \neq y_j$ならば$1$である（注意: クロネッカーのデルタとは異なる）．
$c_{i,j}$の再帰式のうち，最小値を求める部分は次の編集操作に対応する．

+ （$x_i = y_j$の場合のみ）$c_{i-1,j-1}$: $Y_{j-1}$に$x_i$を追加（copy）する
+ （$x_i \neq y_j$の場合のみ）$c_{i-1,j-1} + 1$: $x_i$を$\alpha$に置換（replace）して，$Y_{j-1}$に追加する
+ $c_{i-1,j} + 1$: $x_i$を削除（delete）し，$Y_j$を得る
+ $c_{i,j-1} + 1$: 新しい文字$\alpha$を追加（insert）し，$Y_j$を得る

以上のことから，**編集距離$d_{m,n}$を求める問題は，部分問題，すなわち編集距離$d_{m-1,n-1}$, $d_{m-1,n}$, $d_{m,n-1}$を求める問題に分解できる．**

例えば，$X = \langle Q, U, E, R, Y \rangle$と$Y = \langle I, N, Q, U, I, R, E\rangle$に対して，$c_{i,j}$は次のように求まる．したがって，$X$と$Y$の編集距離は$4$である．

| $i \setminus j$ | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | $x_i$ |
|:---------------:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-----:|
|      **0**      | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |       |
|      **1**      | 1 | 1 | 2 | 2 | 3 | 4 | 5 | 6 |   Q   |
|      **2**      | 2 | 2 | 2 | 3 | 2 | 3 | 4 | 5 |   U   |
|      **3**      | 3 | 3 | 3 | 3 | 3 | 3 | 4 | 5 |   E   |
|      **4**      | 4 | 4 | 4 | 4 | 4 | 4 | 3 | 4 |   R   |
|      **5**      | 5 | 5 | 5 | 5 | 5 | 5 | 4 | 4 |   Y   |
|      $y_j$      |   | I | N | Q | U | I | R | E |       |
{: .table .table-striped}

以上のアルゴリズムを再帰および動的計画法で実装する．
文字列$X = \langle A, T, C, G \rangle$を，C言語では文字列として表現する．

```
char *x = "ATCG";
```

これは，文字の配列として文字列を表現することとほぼ等価である．

```
char x[] = {'A', 'T', 'C', 'G', '\0'};
```

なお，文字列$X$の要素$x_i$は，C言語では`x[i-1]`として表現されることに注意せよ（配列のインデックスが$0$から始まるため）．



$X = \mbox{"on"}$，$Y = \mbox{"so"}$に対して，$c_{i,j}$の漸化式を$c_{2,2}$を出発点として，手作業で再帰的に適用することにより$c_{2,2}$の値を求めよ．このとき，$c_{2,2}$を求める途中経過を省略することなく，すべてレポートに記すこと（課題説明スライドと同様な木構造を使って記すこと）．

+ $c_{i,j}$の値を求めるのに使った接頭辞の編集距離の値と，その添字を明示せよ．
+ 編集操作が分かるように明示せよ．
+ 編集距離を与える編集過程をすべて示せ．

さらに，この手順の問題点を面接で説明せよ．

---
## 問題
---

上記手順を実行するプログラムを再帰関数を用いて実装せよ．
ただし，以下の仕様を満たすようにせよ．

---
### 仕様
---

+ 与えられた文字列$X$と$Y$に対して$c_{m,n}$（編集距離）を計算し，標準出力に書き出す．
+ 文字列$X$と$Y$は標準入力から与えられ，空白文字（スペースや改行）で区切られる．文字数は100未満であると仮定してよい．
+ 文字列$X$，$m$の値（$|X|$），文字列$Y$，$n$の値（$|Y|$）を引数にとり，$c_{m,n}$の値を返す再帰関数を実装せよ．再帰関数のプロトタイプは次のようになるはずである（関数名や引数の順序は任意であるが，4つの引き数を受け取り，1つの値を返す関数として実装せよ）．
```
int ld(char *x, int m, char *y, int n);
```

なお，3つの引き数を受け取って最も小さい値を返す関数`min3`を実装し，再帰関数の中から呼び出すこと．


```
int min3(int a, int b, int c);
```

---
## 実行例
---

```
# eat ate
> 2
```

`#`は標準入力，`>`は標準出力を表す．


---
## 参考文献
---

+ T. コルメン, R. リベスト, C. シュタイン, C. ライザーソン．アルゴリズムイントロダクション 第3版 総合版．近代科学社，2013年．
