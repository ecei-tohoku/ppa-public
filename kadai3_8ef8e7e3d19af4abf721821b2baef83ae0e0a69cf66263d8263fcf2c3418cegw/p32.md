---
layout: page
title: 3-2. 動的計画法による編集距離
---

---
### 動的計画法
---

3-1 のプログラムでは，文字列 $X$ と $Y$ の編集距離 $c_{m,n}$ を，与えられた文字列長から順に遡って（$c_{m, n}, c_{m-1, n-1}, c_{m, n-1}, ..., c_{0,0}$）再帰的に計算した．しかし，この方法では，同じ値を複数回計算してしまう可能性があるため，効率面で問題がある．本問題では，編集距離をより効率的に計算する方法の一つとして，**動的計画法 (Dynamic Programming)** に基づく編集距離の計算を考える．

編集距離の漸化式より，$c_{i,j}$ を求めるためには，$c_{i-1,j-1}, c_{i-1,j}, c_{i,j-1}$ の3つの値が必要である．これを視覚的に理解するために，問題 3-0 の表を思い出して欲しい（一部変更済み）:

| $i \setminus j$ | 0 |   1   |   2   |   3   | 4 | 5 | 6 | 7 | $x_i$ |
|:---------------:|:-:|:-----:|:-----:|:-----:|:-:|:-:|:-:|:-:|:-----:|
|      **0**      | 0 |   1   |   2   |   3   | 4 | 5 | 6 | 7 |       |
|      **1**      | 1 | ``1`` | ``2`` | ``2`` | 3 | 4 | 5 | 6 |   Q   |
|      **2**      | 2 | ``2`` | ``A`` | ``B`` | 2 | 3 | 4 | 5 |   U   |
|      **3**      | 3 |   3   |   3   |   3   | 3 | 3 | 4 | 4 |   E   |
|      **4**      | 4 |   4   |   4   |   4   | 4 | 4 | 3 | 4 |   R   |
|      **5**      | 5 |   5   |   5   |   5   | 5 | 5 | 4 | 4 |   Y   |
|      $y_j$      |   |   I   |   N   |   Q   | U | I | R | E |       |
{: .table .table-striped}

表の上では，とある編集距離 ($c_{i,j}$) を計算するためには，(1) その**左上** ($c_{i-1,j-1}$)，(2) その**左隣** ($c_{i,j-1}$)，(3) その**真上** ($c_{i-1,j}$) の値が必要である．裏を返せば，これらの3つの値が計算済みであれば，それらに囲まれるマスの値を計算できるということである．例えば，$c_{2,2}$ (``A``) は，その左上，左隣，真上である $c_{1,1},c_{1,2},c_{2,1}$ の値を利用して，$min(c_{1,1}+1,c_{1,2}+1,c_{2,1}+1)=min($``1``$+1,$``2``$+1,$``2``$+1)=2$ と求まる．

この位置関係に着目すると，表の一行目は，左から右へ値を五月雨式に埋めることができる．さらに，一行目の値が決まれば，二行目も左から右へ値を埋めていくことができる．例えば，$c_{2,3}$ (``B``) は，左隣の $c_{2,2}$ (``A``) の計算結果を利用し，$min(c_{1,2}+1,c_{2,2}+1,c_{1,3}+1)=min($``2``$+1,$``A``$=$``2``$+1,$``2``$+1)=3$ と求まる．同様に $c_{2,4},c_{2,5},...,c_{3,1},c_{3,2},...,c_{5,7}$ と計算をしていけば全ての値が埋まり，最終的に文字列 $X$ と $Y$ の編集距離 $c_{m,n}$ を求めることができる．

以上のように，再帰計算の深いところから順に値を求めていく（**ボトムアップ (bottom up) に求める**，ともいう）方法は，**動的計画法** として知られている．動的計画法を用いることで，計算回数を $X$ と $Y$ の文字列長の積 $mn$ に抑えることができ，重複して部分的な編集距離を計算することはないため，単純な再帰計算を用いるプログラムよりも多くの場面で効率的である．


再帰呼び出しで$c_{m,n}$を求める過程で，一度求めた$c_{i,j}$の値をメモリに保存しておき，再び必要になった時は再帰呼び出しを行わず，以前求めて保存してあった$c_{i,j}$の値を再利用し，処理を効率化することを**メモ化（memoization）**と呼ぶ．
プログラムにメモ化を導入し，メモ化により再帰関数の呼び出し回数が削減されることを確認したい．


---
## 問題
---

上記手順を実行するプログラムを実装せよ．
ただし，以下の仕様を満たすようにせよ．

---
### 仕様
---

+ 文字列$X$と$Y$は標準入力から与えられ，空白文字（スペースや改行）で区切られる．文字数は100未満であると仮定してよい．
+ 文字列$X$と$Y$のペアはストリームの終端（EOF）に達するまで，複数与えられる．

+ 与えられた文字列$X$と$Y$に対して$c_{m,n}$（編集距離）を計算する

+ 出力例を参考にし，文字列$X$を左端（縦）に，文字列$Y$を先頭（横）に出力し，$c_{i,j} (i \in \{0, 1, ..., m\}, j \in \{0, 1, ..., n\})$のすべての値をスペース区切りの行列形式で出力せよ．行末に余分なスペースを出力しないように注意せよ．
    + 1行目は文字列$Y$の文字をスペース区切りで出力せよ．行頭に4文字分のスペースを挿入せよ．
    + 2行目は$c_{0,j}$の値をスペース区切りで出力せよ．行頭に2文字分のスペースを挿入せよ．
    + 3行目以降は，行頭に$x_i$の文字，続けて$c_{i,j}$の値をスペース区切りで出力せよ．

```
# eat ate
>     a t e
>   0 1 2 3
> e 1 1 2 2
> a 2 1 2 3
> t 3 2 1 2
```

`#`は標準入力，`>`は標準出力を表す．

+ メモ化の有り・無しのそれぞれの場合において再帰関数を呼び出した回数を計測する．
+ 再帰関数を呼び出した回数を求めるためにグローバル変数を使ってもよい．
+ 文字列$X$と$Y$のペア毎に，**メモ化を行った再帰関数で求めた$c_{m,n}$の値**を標準出力に書き出せ．
+ さらに，$m$の値，$n$の値，$m \times n$の値，メモ化無しの再帰関数の呼び出し回数，メモ化有りの再帰関数の呼び出し回数をカンマ区切りで標準エラー出力に書き出せ．
+ メモ化を導入した再帰関数で編集距離を求めるとともに，メモ化の有り・無しのそれぞれの場合において再帰関数の呼び出し回数を計測せよ．
  + 注意: 再帰関数の呼び出し方法は実装によって異なるため，投稿システムでは正しいかどうか検証しない．このため，再帰関数の呼び出し回数の妥当性を面接で確認することとする．


---
## 実行例
---

```
# eat ate
```
# eat ate
>     a t e
>   0 1 2 3
> e 1 1 2 2
> a 2 1 2 3
> t 3 2 1 2
> 2
>> 3,3,9,94,28
```



```
# see seen
> 1
>> 3,4,12,193,37
# joti jobutu
> 3
>> 4,6,24,1933,73
```

`#`は標準入力，`>`は標準出力，`>>`は標準エラー出力を表す．




---
## 参考資料
---

- [秋葉 拓哉, プログラミングコンテストでの動的計画法](http://www.slideshare.net/iwiwi/ss-3578511)


