---
layout: page
title: 4-3. 編集距離(動的計画法版)【基本】
---

---
### 動的計画法
---

問題 4-1,4-2 のプログラムでは，文字列 $X=\langle x_1, x_2, ..., x_m\rangle$ と $Y=\langle y_1, y_2, ..., y_n\rangle$ の編集距離 $c_{m,n}$ を，与えられた文字列長から順に遡って（$c_{m, n}, c_{m-1, n-1}, c_{m, n-1}, ..., c_{0,0}$）再帰的に計算した.

本問題では，編集距離を効率的に計算する別の方法として，**動的計画法 (Dynamic Programming)** に基づく編集距離の計算を考える．(動的計画法という言葉を最初に使い始めたのは最適制御理論の研究において顕著な活躍をした Richard Belleman である.**次元の呪い**という表現を最初に用いたのも彼のようである.)

動的計画法はアルゴリズムの分類の一つであり,簡単に言えば,「部分問題の最適解を得ることを繰り返すことにより全体の問題の最適解を求める手法」である．以下では，編集距離を例にして動的計画法の考え方を説明する.


問題4-1に示した編集距離の漸化式より，$c_{i,j}$ を求めるためには，$c_{i-1,j-1}, c_{i-1,j}, c_{i,j-1}$ の3つの値が必要である．これを視覚的に理解するために， $X=QUERY, Y=INQUIRE$の場合を考えよう.:

| $i \setminus j$ | 0 |   1   |   2   |   3   | 4 | 5 | 6 | 7 | $x_i$ |
|:---------------:|:-:|:-----:|:-----:|:-----:|:-:|:-:|:-:|:-:|:-----:|
|      **0**      | 0 |   1   |   2   |   3   | 4 | 5 | 6 | 7 |       |
|      **1**      | 1 | ``1`` | ``2`` | ``2`` | 3 | 4 | 5 | 6 |   Q   |
|      **2**      | 2 | ``2`` | ``A`` | ``B`` | 2 | 3 | 4 | 5 |   U   |
|      **3**      | 3 |   3   |   3   |   3   | 3 | 3 | 4 | 4 |   E   |
|      **4**      | 4 |   4   |   4   |   4   | 4 | 4 | 3 | 4 |   R   |
|      **5**      | 5 |   5   |   5   |   5   | 5 | 5 | 4 | 4 |   Y   |
|      $y_j$      |   |   I   |   N   |   Q   | U | I | R | E |       |
{: .table .table-striped}

表の上では，とある編集距離 ($c_{i,j}$) を計算するためには，(1) その**左上** ($c_{i-1,j-1}$)，(2) その**左隣** ($c_{i,j-1}$)，(3) その**真上** ($c_{i-1,j}$) の値が必要である．裏を返せば，これらの3つの値が計算済みであれば，それらに囲まれるマスの値を計算できるということである．例えば，$c_{2,2}$ (表の``A``) は，その左上，左隣，真上である $c_{1,1},c_{1,2},c_{2,1}$ の値を利用して，$min(c_{1,1}+1,c_{1,2}+1,c_{2,1}+1)=min($``1``$+1,$``2``$+1,$``2``$+1)=2$ と求まる．

この位置関係に着目すると，表の一行目は，左から右へ値を五月雨式に埋めることができる．さらに，一行目の値が決まれば，二行目も左から右へ値を埋めていくことができる．例えば，$c_{2,3}$ (表の``B``) は，左隣の $c_{2,2}$ (表の``A``) の計算結果を利用し，$min(c_{1,2}+1,c_{2,2}+1,c_{1,3}+1)=min($``2``$+1,$``A``$=$``2``$+1,$``2``$+1)=3$ と求まる．同様に $c_{2,4},c_{2,5},...,c_{3,1},c_{3,2},...,c_{5,7}$ と計算をしていけば全ての値が埋まり，最終的に文字列 $X$ と $Y$ の編集距離 $c_{m,n}$ を求めることができる．

以上のように，再帰計算の深いところから順に値を求めていく（**ボトムアップ (bottom up) に求める**ともいう.）方法は，計算回数を $X$ と $Y$ の文字列長の積 $mn$ に抑えることができ，重複して部分的な編集距離を計算することはないため，単純な再帰計算を用いるプログラムよりも多くの場面で効率的である．


---
## 問題
---
与えられた文字列$X$を$Y$に変換する編集距離を動的計画法により求めるプログラムを実装せよ．

---
### 仕様
---
+ 課題4-1に記載の課題全体の仕様

+ コメントがプログラムの要約や意図を記述して、インデント・行間を適切に入れていること．

+ 入力文字列を読み，動的に確保したメモリ領域に格納するために`read_string_`関数が使用されていること．
  + 確保したメモリ領域を処理完了後に解放していること．


+ 再帰ではなく、動的計画法を用いて編集距離を求めること.

+ 動的計画用の二次元配列テーブル`dpt`は，課題4-2と同じく`malloc_2d_`関数を用いてメモリを確保せよ.
  + `dpt`の大きさは文字列の長さに合わせて必要十分な大きさとすること．


+ `main`関数の最後では，課題4-2と同じく`free_2d_`関数を用いてメモリの開放を行うこと.
  
+ 問題4-1と問題4-2に提示してある関数を`ppa_extra_h/p3_header.h`というファイルにおいてある．`#include "ppa_extra_h/p3_header.h"`という宣言を通して含め、以下の関数を必要に応じて用いること．
  + `vmax_`
  + `vmax3_`
  + `vmin_`
  + `vmin3_`
  + `zeros_`
  + `malloc_string_`
  + `read_string_`
  + `malloc_2d_`
  + `free_2d_`  
   
---
## ステップ 1
---

+ 文字列$X$の位置$a$の文字と文字列$Y$の位置$b$の文字が等しい場合に0，違う場合に1を返す関数`delta`を作成し，それを関数`dpt_delta`の中で用いること
  + 例：
  ```
  int delta(char *X, int a, char *Y, int b);
  ```
  
+ 文字列$X$，文字列$X$の長さ$m$，文字列$Y$，文字列$Y$の長さ$n$，二次元配列テーブル`dpt`の5つを引数にとる`dpt_delta`を作成すること
  + `dpt_delta`は以下のように`dpt`に値を保存する
    + 最初の行と最初の列に-1を保存する（つまり、インデックスの1つが0の場合）
    + $X$の$i$番目の文字と$Y$の$j$番目の文字が等しい場合は$dpt[i][j]$に0を保存し、そうでない場合は1を保存する
      + ヒント：　$X$の$i$番目の文字は、配列$X$のインデックス$i$を持つ要素ではないので、気をつけてください
    + `delta`を使うこと
  + 例：
  ```
  void dpt_delta(char *X, int m, char *Y, int n, int **dpt);
  ```

+ 標準出力に以下の出力をする．
  + 1行目に文字列 $X$ とその長さ $m$ を、2行目に文字列 $Y$ とその長さ $n$ を表示すること.
  + 3行目に`dpt`の１行目, 4行目に`dpt`の2行目等々, `dpt`の最終行目まで．
  + 下の実行例(1)の場合
    ```
    eat⊔3↩︎
    ate⊔3↩︎
    -1⊔-1⊔-1⊔-1↩︎
    -1⊔⊔1⊔⊔1⊔⊔0↩︎
    -1⊔⊔0⊔⊔1⊔⊔1↩︎
    -1⊔⊔1⊔⊔0⊔⊔1↩︎
    ```
  + 全ての整数は2桁分の表示スペースを確保する．つまり，表示対象が2桁の場合はそのまま,表示対象が1桁の場合は2桁目（十の位）に空白を入れること．
  + 行の最後の要素を除いて，各要素の後に1つの空白文字を出力すること．
   
---
## ステップ 2
---

+ 文字列$X$，文字列$X$の長さ$m$，文字列$Y$，文字列$Y$の長さ$n$，二次元配列テーブル`dpt`の5つを引数にとり，編集距離を返す関数`ld_dp`を作成すること
  + `delta`を使うこと
  + ステップ１で実装した`dpt_delta`を参考に、`ld_dp`を実装すること
  + 例：
  ```
  int ld_dp(char *X, int m, char *Y, int n, int **dpt);
  ```

+ 標準出力に以下の出力をする．
  + 1行目に文字列 $X$ とその長さ $m$ を、2行目に文字列 $Y$ とその長さ $n$ を表示すること.
  + 3行目に編集距離を表示する．
    + 余計な空白などは入れないこと．
  + 下の実行例(1)の場合
    ```
    eat⊔3↩︎
    ate⊔3↩︎
    2↩︎
    ```

---
## 実行例
---

---
## 例(1)
---

+ 入力
```
3 3 eat ate
```

+ 出力 (STEP 1)
```
eat 3︎
ate 3
-1 -1 -1 -1︎
-1  1  1  0
-1  0  1  1
-1  1  0  1
```

+ 出力 (STEP 2)
```
eat 3
ate 3
2
```

---
## 例(2)
---

+ 入力
```
3 4 see seen
```

+ 出力 (STEP 1)
```
see 3
seen 4
-1 -1 -1 -1︎ -1
-1  0  1  1  1
-1  1  0  0  1
-1  1  0  0  1
```

+ 出力 (STEP 2)
```
see 3
seen 4
1
```
