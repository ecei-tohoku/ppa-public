# 30: 編集距離　【レポート提出不要】【プログラム提出不要】

2つの文字列の類似性が測定できると役に立つ場合がある．
例えば，`GATCGGCAT`と`CAATGTGAATC`の2つのアミノ酸配列に対して，次のような対応付けを行うことで，これらのアミノ酸配列の類似度合いを調べることができる．

```
G ATCG GCAT
CAAT GTGAATC
RI==D=I=R==I
```

なお，`=`は文字が一致している箇所，`R`は文字が異なっている場所，`D`は上側に文字を挿入した箇所，`I`は下側に文字を挿入した箇所である．
また，修正前と修正後のソースコードの類似部分を見つけることで，ソースコードに加えられた変更点（diff）を調べることができる（以下の例では`=`を`==`に修正）．

```
before: if (flag = 1) { printf("found\n"); }
after:  if (flag == 1) { printf("found\n"); }
```

本課題では，2つの文字列$X = \langle x_1, x_2, ..., x_m \rangle$と$Y = \langle y_1, y_2, ..., y_n \rangle$の類似性を測定する方法として，**編集距離（edit distance）**に取り組む．

編集距離について理解するため，文字列$X$に編集操作を適用し，文字列$Y$に等しい文字列$Z$を得ることを考える．
$Z$の初期状態は空文字列であり，終了時点では$j = 1, 2, ..., n$に対して$z_j = y_j$でなければならない．
編集過程において，$X$の添字$i$と$Z$の添字$j$を管理しており，編集操作は$Z$とこれらの添字の値を変更できる．初期状態は$i = j = 1$で，可能な編集操作は以下の通りである．

+ **copy**: 代入$z_j \gets x_i$を行い，$i$と$j$にそれぞれ$1$を加えることで，$X$の1文字を$Z$にコピーする．
+ **replace**: 代入$z_j \gets \alpha$を行い，$i$と$j$にそれぞれ$1$を加えることで，$X$の1文字を別の文字$\alpha$に置換する．
+ **delete**: $j$を変更せずに$i$に$1$を加えることで，$X$の1文字を消去する．
+ **insert**: 代入$z_j \gets \alpha$を行ったうえで，$j$だけに$1$を加えることで，文字$\alpha$を$Z$に挿入する．

例えば，$X = \mbox{algorithm}$に編集操作を適用し，$Z=\mbox{altruistic}$を得る過程の例を示す．
ここで，$X$の太字と$Z$のアンダーライン（_）は，添字の位置を表す．

|操作| $X$ | $Z$ |
|:--|:--|:--|
| 初期文字列 | **a**lgorithm | _ |
| copy | a**l**gorithm | a_ |
| copy | al**g**orithm | al_ |
| replace by 't' | alg**o**rithm | alt_ |
| delete | algo**r**ithm | alt_ |
| copy | algor**i**thm | altr_ |
| insert 'u'| algor**i**thm | altru_ |
| insert 'i'| algor**i**thm | altrui_ |
| insert 's'| algor**i**thm | altruis_ |
| insert 't'| algor**i**thm | altruist_ |
| copy | algori**t**hm | altruisti_ |
| insert 'c' | algori**t**hm | altruistic_ |

一般的に，ある文字列を別の文字列に変換する編集過程は複数存在することに注意せよ．

さて，各編集操作$a$にコスト${\rm cost}(a)$が定義されているとすれば，上記の編集過程で要するコストは，次のように計算できる．

$$
4 \times {\rm cost}(\mbox{copy}) + 1 \times {\rm cost}(\mbox{replace}) + 1 \times {\rm cost}(\mbox{delete}) + 5 \times {\rm cost}(\mbox{insert})
$$

本課題では，${\rm cost}(\mbox{copy}) = 0$，${\rm cost}(\mbox{replace}) = {\rm cost}(\mbox{delete}) = {\rm cost}(\mbox{insert}) = 1$とする．したがって，編集過程のコストの総和は$7$である．

2つの文字列$X = \langle x_1, x_2, ..., x_m \rangle$と$Y = \langle y_1, y_2, ..., y_n \rangle$，および編集操作コストが与えられたとき，$X$から$Y$への編集距離とは，$X$を$Y$に変換する編集操作列のコストの最小値である．
編集距離を効率よく求める方法を考えるために，接頭辞という概念を導入する．

+ ある文字列$X = \langle x_1, x_2, ..., x_m \rangle$の長さ$p \in \{0, 1, ..., m\}$の**接頭辞（prefix）**を$X_p = \langle x_1, x_2, ..., x_p \rangle$と定義する．例えば，$X = \langle A, T, C, G \rangle$に対し，$X_2 = \langle A, T \rangle$である．$X_0$は空文字列である．

$X$の接頭辞$X_i$（$i \in \{0, 1, ..., m\}$），$Y$の接頭辞$Y_j$（$j \in \{0, 1, ..., n\}$）の編集距離を$c_{i,j}$と書くと，以下の再帰的な式が成り立つ．

$$
c_{i,j} = \begin{cases}
\max (i, j) & i = 0 \mbox{ または } j = 0 \mbox{ のとき} \\
\min \begin{cases}
c_{i-1, j-1} + \delta_{x_i \neq y_j},\\
c_{i-1, j} + 1,\\
c_{i, j-1} + 1,\\
\end{cases} & それ以外
\end{cases}
$$

ただし，$\delta_{x_i \neq y_j}$は，$x_i = y_j$ならば$0$，$x_i \neq y_j$ならば$1$である．
$c_{i,j}$の再帰式のうち，最小値を求める部分は次の編集操作に対応する．

+ （$x_i = y_j$の場合のみ）$c_{i-1,j-1}$: $Y_{j-1}$に$x_i$を追加（copy）する
+ （$x_i \neq y_j$の場合のみ）$c_{i-1,j-1} + 1$: $x_i$を$\alpha$に置換（replace）して，$Y_{j-1}$に追加する
+ $c_{i-1,j} + 1$: $x_i$を削除（delete）し，$Y_j$を得る
+ $c_{i,j-1} + 1$: 新しい文字$\alpha$を追加（insert）し，$Y_j$を得る

以上のことから，編集距離$d_{m,n}$を求める問題は，部分問題，すなわち編集距離$d_{m-1,n-1}$, $d_{m-1,n}$, $d_{m,n-1}$を求める問題に分解できる．
例えば，$X = \langle Q, U, E, R, Y \rangle$と$Y = \langle I, N, Q, U, I, R, E\rangle$に対して，$c_{i,j}$は次のように求まる．したがって，$X$と$Y$の編集距離は$4$である．

| $i \setminus j$ | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | $x_i$ |
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
| **0** | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |   |
| **1** | 1 | 1 | 2 | 2 | 3 | 4 | 5 | 6 | Q |
| **2** | 2 | 2 | 2 | 3 | 2 | 3 | 4 | 5 | U |
| **3** | 3 | 3 | 3 | 3 | 3 | 3 | 4 | 5 | E |
| **4** | 4 | 4 | 4 | 4 | 4 | 4 | 3 | 4 | R |
| **5** | 5 | 5 | 5 | 5 | 5 | 5 | 4 | 4 | Y |
| $y_j$ |   | I | N | Q | U | I | R | E |   |

以上のアルゴリズムを再帰および動的計画法で実装する．
文字列$X = \langle A, T, C, G \rangle$を，C言語では文字列として表現する．
```
char *x = "ATCG";
```
これは，文字の配列として文字列を表現することとほぼ等価である．
```
char x[] = {'A', 'T', 'C', 'G', '\0'};
```
なお，文字列$X$の要素$x_i$は，C言語では`x[i-1]`として表現されることに注意せよ（配列のインデックスが$0$から始まるため）．

参考文献

+ T. コルメン, R. リベスト, C. シュタイン, C. ライザーソン．アルゴリズムイントロダクション 第3版 総合版．近代科学社，2013年．
