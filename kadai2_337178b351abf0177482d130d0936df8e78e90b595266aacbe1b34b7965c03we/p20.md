---
layout: page
title: 2-0. 配列の逆順置換（課題説明用）
---

与えられたデータを一定の大小関係に基づいて並べ替えることを**ソート**と呼ぶ．
「並べ替える」というと単純そうだが，ソートの手順（**アルゴリズム**）には様々なバリエーションが存在し，またこれらを学ぶ中で**計算量**（complexity）や**再帰**（recursion）といった重要な概念に触れることができるため，ソートは計算機科学のカリキュラムに必ず登場する基本的なトピックとなっている．

課題2では，様々なソートアルゴリズムを実装することを通して，それぞれのソートアルゴリズムがどのように値を並び替えているかを学ぶ．

- 課題2-1: 選択に基づくソート (選択ソート)
- 課題2-2: 交換に基づくソート (バブルソート)
- 課題2-3: 挿入に基づくソート (挿入ソート)
- 課題2-4: 分解/結合に基づくソート (マージソート)
- 課題2-5: 選択に基づくソート 改良版 (ヒープソート)

本課題では，ソートアルゴリズムそのものを学ぶことだけではなく，ソートアルゴリズムを作成することを通して，<font color="red">関数</font>，<font color="red">動的メモリ確保</font>，<font color="red">再帰処理</font>，<font color="red">ポインタ</font>に関する知識も合わせて学ぶ．
例えば，できるだけ利用するメモリを少なくすることを念頭に動的メモリ確保を用いてプログラムを作成する．
また，ソート処理を関数に分けて書くことで，処理の再利用性を高める練習をする．

---

## <font color="red">！！重要！！　課題全体を通しての仕様</font>
---

課題を通しての仕様を説明する (各設問で追加の仕様や注意書きがある場合はそちらを優先する)．

- グローバル変数や静的変数を使用してはいけない．
- `include`するファイルは`<stdio.h>`および`<stdlib.h>`のみとする．
- プログラム全体の構成を以下に従うようにする．
  - `main`関数の正常終了時の戻り値0にする．
  - 関数の前方宣言を用い，関数本体は`main`関数の下に記述する．
    ```
      #include <stdio.h>
      #include <stdlib.h>

        ... 事前に与えられる関数の定義 ...

      //////

        ... 課題ごとの関数前方宣言 ...

      int main()
      {

        ...（main関数本体）...

        return 0;
      }

        ... 課題ごとの関数本体 ...
      ```
  - ただし，課題ごとに与えられるコードを記載する場所は，それぞれの指示に従う．
- 変数の宣言は関数の先頭でおこなうこと (途中の宣言は不可とする)

- 入力データの読み込み/配列の動的確保
  - 入力データは正の整数のみと仮定して良い．正の整数が空白または改行区切りで並んでいると仮定する．
  - 入力データを読み込む際には，事前に定義された`func_mallocation_`関数を用いて，データの格納に必要なメモリ領域を動的に確保すること．
  - 動的に確保したメモリ領域は処理が完了した後に解放すること（関数`free`などを使うこと)
  - 入力データの読み込は`main` 関数内で行うこと．

- 配列の要素へのアクセス
  - 入力データを読み込んだ配列の要素へのアクセスは，事前に用意された専用の関数を用いること．それ以外の方法でアクセスすることを禁止する．以下例を挙げる．
    - 要素間の入れ替え：`func_swap_`関数
    - 要素のコピー：`func_copy_val_`関数
    - 要素感の比較：`comp_`関数
    - 要素の表示：`print_array_`関数
  - それぞれの課題で利用可能な関数を確認すること．

- 事前に定義されている関数(基本的に関数名の最後に`_`がついているもの)の中身を書き換えてはいけない．これらの関数は例えば，`printf`や`scanf`と同様に中身を書き換えられない関数として扱うこと．

- 表示例の`⊔` は半角スペース，`↩︎`は改行を表す．
- 表示(出力)
  - 全ての表示は標準出力にすること．ただし，標準エラー出力への表示が必要な場合は各課題の仕様に記載する．
  - 全ての出力には改行文字 `\n` を付けること．特に最後の行の改行の有無に注意すること．
  - 各要素の間には空白文字を一つ入れる．
  - 改行前の空白文字などの表示されない文字を出力しないこと．

  - 入力データを動的に確保した配列内に読み込んだ直後に配列を表示すること．
    - 必ず`main`関数内で呼び出すこと．
    - 書式は各課題の指示に合わせること．
    - 例： 配列データ 10 2 8 4 11 9 12 5 3 13 1 7 6 場合
      ```
      INIT:::::::⊔10⊔⊔2⊔⊔8⊔⊔4⊔11⊔⊔9⊔12⊔⊔5⊔⊔3⊔13⊔⊔1⊔⊔7⊔⊔6↩︎
      ```
    - 全ての整数は二桁分の表示スペースを確保する．つまり，表示対象が一桁の場合は，空白を一つ二桁目に入れること．
  - 課題の処理が完了し`main`関数を終了する前に，最終状態の配列データを表示すること．
    - 合わせて比較回数の表示を求めらた場合はその指示に従うこと．
    - 必ず`main`関数内で呼び出すこと．
    - 書式は各課題の指示に合わせること．
    - 例： 配列データ 1 2 3 4 5 6 7 8 9 10 11 12 13, 比較回数 15 の場合
  	  ```
      DONE:::::::⊔⊔1⊔⊔2⊔⊔3⊔⊔4⊔⊔5⊔⊔6⊔⊔7⊔⊔8⊔⊔9⊔10⊔11⊔12⊔13↩︎
      15↩︎
	    ```
    - 全ての整数は二桁分の表示スペースを確保する．つまり，表示対象が一桁の場合は，空白を一つ二桁目に入れること．



---
## 問題
---

与えられた配列データを読み込み，逆順にして出力するプログラムを作成せよ．

---
## 仕様
---

- 上記記載の仕様を満たすこと．

- 配列操作に利用可能な関数
  - 配列内の二つの要素を入れ替える手続きとして`func_swap_`関数を用いること．
  - 配列内の二つの要素を比較する手続きとして`comp_`関数を用いること．
  - 配列内の要素を表示する手続きとして`print_array_`関数を用いること．

- 配列を逆順に並び替える `reverse_array` 関数を作成すること．また，以下の仕様を満すこと．
  - 配列の要素を逆順に並び替える操作は全てこの関数内で行うこと．
    - ただし，この関数内で呼ばれる別の関数を作成してもよい．その際は必ず前方宣言すること．
  - 入力データ用に動的に確保した配列と入力データの個数の二つを引数とすること．
    - 例：
    ```
    int reverse_array(int *array, int N) ...
    ```
  - 要素間の比較`comp_`の呼び出し回数を`reverse_array` 関数の戻り値とすること．
  - 要素の値が同じ場合など，入れ替える必要がない場合は入れ替えてはいけない．

- 表示
  - 入力データを動的に確保した配列内に読み込んだ直後に配列を表示すること．
    - 書式は，上記の全体の仕様に記載の書式とする．
  - 逆順にする処理が終わった後の配列データ，および，比較回数表示すること．
    - 書式は，上記の全体の仕様に記載の書式とする．
	- `func_swap_`により値を入れ替えるたびに，入れ替えた要素の場所と配列全体の要素を以下の書式で表示すること
    - 交換した2つの要素番号$i,j(i<j)$を用いて SWAP$(i,j)$ と表示し，空白後に交換後の配列の全要素を表示する．ただし，交換が実行されなかった場合は何も表示してはいけない．
  	- 例：要素番号0,12の要素を交換した場合
	  	```
      SWAP(⊔0,12)⊔⊔6⊔⊔2⊔⊔8⊔⊔4⊔11⊔⊔9⊔12⊔⊔5⊔⊔3⊔13⊔⊔1⊔⊔7⊔10↩︎
      ```

- 以下のプログラムを必ず用いてプログラムを完成せること．
  - 事前に定義された関数にコメントを入れること．課題2-0でコメントが入れてあれば，以降の課題で同じ関数に関するコメントは不要．

```
#include <stdio.h>
#include <stdlib.h>

int* func_swap_(       // ???
    int* const array,  // ???
    const int pos_a,   // ???
    const int pos_b    // ???
) {
  int tmp = array[pos_a];                 // ???
  array[pos_a] = array[pos_b];            // ???
  array[pos_b] = tmp;                     // ???
  printf("SWAP(%2d,%2d)", pos_a, pos_b);  // ???
  return array;                           // ???
}

int comp_(             // ???
    int* const array,  // ???
    const int pos_a,   // ???
    const int pos_b    // ???
) {
  if (array[pos_a] < array[pos_b]) return 1;  //
  return 0;
}

void print_array_(           // ???
    const int* const array,  // ???
    const int N              // ???
) {
  int ri = 0;
  for (; ri < N; ++ri) {        // ???
    printf(" %2d", array[ri]);  // ???
  }
  printf("\n");  // ???
}

int* func_mallocation_(  // ???
    const int N          // ???
) {
  int* data = (int*)malloc(N * sizeof(int));  // ???
  if (data == NULL) {                         // ???
    printf("Can not allocate memory. 'data' is NULL.\n");
    exit(EXIT_FAILURE);  // ???
  }
  return data;  // ???
}

///////

int reverse_array(int *, int);

int main() {

  ...(省略)...

  return 0;               //
}

int reverse_array(int *array, int N) {

  ...(省略)...

}
```

---
## 手順
---
- まず，上記プログラムを書きうつす．
- 足りない部分は，基本的に，`main`関数と`reverse_array`関数の中身なのでそれらを追記する．
- `main`関数に必要な処理例：
  1. まず先頭の整数を読み込む．
  1. 読み込んだ整数に合わせて配列を動的確保する．この時に仕様の指示の通り`func_mallocation_`を用いる
  1. 残りのデータ部分を読み込む．読み込む際は単純に`for`文を最初に読み込んだ数だけ回して，それぞれの要素に読み込めば良い．
  1. 仕様の指示にしたがって，配列に読み込んだ要素を表示する．(`INIT:::::::`の行の出力)
  1. 次に，逆順にする関数`reverse_array`を呼ぶ
  1. 戻り値として比較回数の合計を受け取る．
  1. 逆順になった配列を表示する．(`DONE:::::::`の行の出力)
  1. 比較回数を表示する．（表示の最後の行の出力)
  1. 動的確保したメモリを開放する．
  1. `return 0`して`main`関数は終了

- `reverse_array`関数に必要な処理例：
  1. 仕様にしたがって，変数の宣言をする．
  1. 仕様にしたがって，変数の宣言をする．
  1. 配列を先頭から順番に処理する．
     1. `comp_`を使って要素を比較する．この際に<font color="red">「要素が等しい」をどうやって`comp_`で表現するか</font>を考える． 
     1. `comp_`を呼んだ回数をカウントする．
     1. 要素が等しくない場合は，`func_swap_`を用いて要素を入れ替える．また，その際に配列全体を`print_array_`を用いて表示する．
  1. `comp_`を呼んだ回数を`retunr`で返す．

---
## 実行例
---
---
### 実行例(1)
---
- 入力データ
```
5 1 1 1 1 1
```
- 出力例
```
INIT:::::::  1  1  1  1  1
DONE:::::::  1  1  1  1  1
4
```

---
### 実行例(2)
---
- 入力データ
```
13 10 2 8 4 11 9 12 5 3 13 1 7 6
```
- 出力例
```
INIT::::::: 10  2  8  4 11  9 12  5  3 13  1  7  6
SWAP( 0,12)  6  2  8  4 11  9 12  5  3 13  1  7 10
SWAP( 1,11)  6  7  8  4 11  9 12  5  3 13  1  2 10
SWAP( 2,10)  6  7  1  4 11  9 12  5  3 13  8  2 10
SWAP( 3, 9)  6  7  1 13 11  9 12  5  3  4  8  2 10
SWAP( 4, 8)  6  7  1 13  3  9 12  5 11  4  8  2 10
SWAP( 5, 7)  6  7  1 13  3  5 12  9 11  4  8  2 10
DONE:::::::  6  7  1 13  3  5 12  9 11  4  8  2 10
12
```

---
### 実行例(3)
---
- 入力データ
```
10 1 2 1 1 2 1 1 2 2 1
```
- 出力例
```
INIT:::::::  1  2  1  1  2  1  1  2  2  1
SWAP( 2, 7)  1  2  2  1  2  1  1  1  2  1
SWAP( 4, 5)  1  2  2  1  1  2  1  1  2  1
DONE:::::::  1  2  2  1  1  2  1  1  2  1
10
```




---
## 参考情報
---
---
### 関数
---

C 言語のプログラムは，`main` 関数内に動作させたい内容を記述すればよいが，プログラムの規模が大きくなるにつれて，`main` 関数の内容が膨大になってしまう．このような場合，適当な大きさの関数に分割してプログラムを書くことが多い．たとえば，繰り返し計算する部分を関数として実装することで，別の箇所から何回も呼び出すことができる．ここでは，関数を使ったプログラムを作成しよう．

---
### メモリ領域の動的確保
---

C言語では, int a[5]; のように, 配列を宣言して使用するためには具体的に要素数を指定する必要があります．
しかしこの仕組みは，今回の課題のように，配列の要素数が入力等から得られるまで不定の場合には不都合が生じてしまいます．
例えば，int a[5]; として用意した配列に10個の配列要素を読み込ませることはできませんし，
かといってあらかじめ int a[500]; のように多めに配列を用意していても，実際に入力される要素数が10や20だった場合は貴重なメモリ容量の無駄遣いになってしまいます．

C言語ではこのようにプログラムを実行するまで配列の要素数が決まらない場合に
必要に応じて必要なだけ配列要素を確保する `malloc`(えむあろっく，まろっく)と言う関数が用意されています．
今回の課題のように標準入力から配列の要素数が 10 と入力された場合は 
```
int *x;
x = ( int * ) malloc ( 10 * sizeof ( int ) );
```
のように `malloc` 関数を使用します．
`malloc` 関数は確保した領域の先頭ポインタを返すため、[] 演算子を用いることで
x[0],x[1],x[5] 等のようにポインタ x をあたかも配列 int x[10]; と宣言した場合のように扱うことができます．
(`malloc`関数を用いる場合は必ず確保に失敗した場合のエラー処理と `free` による解放処理を行ってください．)

- 高橋：10.4 文字列の操作
- 林：17.3 メモリ管理

---
### 配列を引数にとる関数
---
C言語では以下のように記述することで配列を引数とする関数を作ることができます．

- 記述例(1): int func ( int *array ){ ・・・ };

例えば配列要素の総和を計算するプログラムは

```
#include <stdio.h>
#include <stdlib.h>

int func ( int *a, int n )

int main ()
{
	int sum, N=5;
	int *data;

  data = ( int * ) malloc ( N * sizeof ( int ) );
  if (data==NULL) {
    printf("Can not allocate memory. 'data' is NULL.\n");
    return 1;
  }

	sum = func ( data, N );
	printf ( "%d\n", sum );

  free(data);
	return 0;
}

int func ( int *a, int n )
{
	int i, ans = 0;
	for ( i=0; i < n; i++ )
	{
		ans += a[i];
	}
	return ans;
}
```

のように記述できます．

参考として配列を引数にとる場合は

- 記述例(2): int func ( int array[] ){ ・・・ };

のように通常の配列とポインタ型を区別するために，`int a[5];` のように宣言した配列を引数とする場合にはこのように書くことが推奨されます．

本課題では，`int *a = (int*)malloc(SIZE);` のように動的に確保した配列を使用するので前記(1)の記述法を用いることが推奨されます．
