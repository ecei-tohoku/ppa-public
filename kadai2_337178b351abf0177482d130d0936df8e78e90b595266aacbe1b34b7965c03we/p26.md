---
layout: page
title: 2-6. ヒープソート
---


ここでは，<font color="red">選択に基づくソート</font>の一種である<font color="red">ヒープソート (heap sort)</font>を実装してみよう．

ヒープソートとは，二分ヒープ木を活用してソートをおこなうアルゴリズムである．
ヒープソートが選択に基づくソートの一種と呼ばれるのは，選択ソートと同様に，ソートされていない要素から，一つ最大値（あるいは最小値）を取得して，それを順番に並べる処理を基本操作とするためである．
ただし，ヒープソートでは，二分ヒープ木と呼ばれる特別な構造をソートされていない範囲で実現することで，最大値（あるいは最小値）の取得を容易にする工夫がなされている．
要素数が少ない場合は単純な選択ソートでよいが，要素数が大きくなった場合に，ヒープを作成しておく分だけ効率的になる．

---
## 問題
---
与えられた配列データを<font color="red">ヒープソート</font>により<font color="red">昇順</font>に並べ替えるプログラムを作成せよ．



---
### 仕様
---
- 課題2-0に記載されている仕様を全て満たすこと．

<br>

- 配列操作に利用可能な関数
  - 配列内の二つの要素を入れ替える手続きとして`func_swap_`関数を用いること．
  - 配列内の二つの要素を比較する手続きとして`comp_`関数を用いること．
  - 配列内の要素を表示する手続きとして`print_array_`関数を用いること．

<br>

- 配列をヒープソートによって並び替える `hp_sort` 関数を作成すること．また，以下の仕様を満すこと．
  - この関数内で呼ばれる別の関数を作成してもよい．その際は必ず前方宣言すること．
  - `hp_sort`の引数は，入力データ用に動的に確保した配列と入力データの個数の二つを引数とすること．
    ```
    void hp_sort(int *array, int N) ...
    ```
  - 要素の値が同じ場合など，入れ替える必要がない場合は入れ替えてはいけない．

<br>

- 配列を先頭を根とする<font color="red">降順の</font>二分ヒープ木に並び替えること．
  - このために，配列が既に二分ヒープ木として構築されている際に，配列のある要素が書き換わったと仮定し，その要素（節点）から葉に向かって二分ヒープ木を再構築する `downheap` 関数を作成すること．ただし，`downheap` 関数は以下の仕様を満すこと．
    - `downheap`の引数は，(1)動的に確保したデータ配列のポインタ，(2)配列データの個数 $N$，(3)ヒープ木再構築する節点の位置$i$，(4)二分ヒープ木の大きさ$M$の
       4種とする．
      ```
      void downheap(int* array, int N, int i, const int M) ...
      ```
    - 子の値が等しい場合は，配列のインデックスが小さい方と入れ替えること．
    - 要素の値が同じ場合は入れ替えてはいけない．

<br>

- `hp_sort`関数で最初に配列を二分ヒープ木に並び替える際に以下の仕様を満たすこと．
  - `downheap`を配列に対して逆順に適用することで二分ヒープ木に並べ替えること．
    - この時の二分ヒープ木の大きさ$M$は便宜的に配列の大きさ$N$とする．

<br>

- 表示
  - 仕様の指示にしたがって，配列に読み込んだ要素を表示する．(`INIT:::::::`の行の出力)
  - `func_swap_`により値を入れ替えるたびに，入れ替えた要素の場所と配列全体の要素を以下の書式で表示すること
    - 交換した2つの要素番号$i,j(i < j)$を用いて SWAP$(i, j)$ と表示し，空白後に交換後の配列の全要素を表示する．ただし，交換が実行されなかった場合は何も表示してはいけない．
    - 例：要素番号 0,12の要素を交換した場合
    ```
    SWAP(⊔0,12)⊔⊔6⊔⊔2⊔⊔8⊔⊔4⊔11⊔⊔9⊔12⊔⊔5⊔⊔3⊔13⊔⊔1⊔⊔7⊔10↩︎
    ```
    - また，`downheap`関数内で要素を入れ替えた場合は，その`downheap`関数を呼び出した際の引数(先頭の節点$k$と二分ヒープ木の大きさ$M$)の情報を，DH$(k,M)$と先頭に表示する．
      - 例：`downheap`の引数が$k=1,M=6$，および，要素番号 $0,12$の要素を交換した場合
　　　　　```
	DH(⊔1,⊔6)⊔SWAP(⊔0,12)⊔⊔6⊔⊔2⊔⊔8⊔⊔4⊔11⊔⊔9⊔12⊔⊔5⊔⊔3⊔13⊔⊔1⊔⊔7⊔10↩︎
	```
  - ソート済の配列を表示する．(`DONE:::::::`の行の出力)
  - 全体的な出力例は実行例を参照のこと．

<br>

- 題2-0に提示してある関数と題2-1に提示してある`func_copy_val_`と`print_array_range_`を`ppa_extra_h/p2_header.h`というファイルにおいてある．`#include "ppa_extra_h/p2_header.h"`という宣言を通して含めたら，こちらの関数を書かなくても呼べる：`func_swap_`，`comp_`，`print_array_`，`func_mallocation_`，`func_copy_val_`，`print_array_range_`

<br>

- 入力として与えられる配列の値は全て異なる．

<br>

- 以下のプログラムを必ず用いてプログラムを完成せること．

```
#include <stdio.h>
#include <stdlib.h>
#include “ppa_extra_h/p2_header.h”

void downheap(int *, int , int , int ) ;
void hp_sort(int *, int ) ;

int main() {

  ...(省略)...

  return 0;               //
}

void downheap(int *array, int N, int i, int M) {

  ...(省略)...

}

void hp_sort(int *array, int N) {

  ...(省略)...

}
```


---
## 実行例
---
---
### 実行例(1)
---
- 入力データ
```
7 2 1 3 7 4 6 5
```
- 出力例
```
INIT:::::::  2  1  3  7  4  6  5
DH( 2, 7) SWAP( 2, 5)  2  1  6  7  4  3  5
DH( 1, 7) SWAP( 1, 3)  2  7  6  1  4  3  5
DH( 0, 7) SWAP( 0, 1)  7  2  6  1  4  3  5
DH( 0, 7) SWAP( 1, 4)  7  4  6  1  2  3  5
SWAP( 0, 6)  5  4  6  1  2  3  7
DH( 0, 6) SWAP( 0, 2)  6  4  5  1  2  3  7
SWAP( 0, 5)  3  4  5  1  2  6  7
DH( 0, 5) SWAP( 0, 2)  5  4  3  1  2  6  7
SWAP( 0, 4)  2  4  3  1  5  6  7
DH( 0, 4) SWAP( 0, 1)  4  2  3  1  5  6  7
SWAP( 0, 3)  1  2  3  4  5  6  7
DH( 0, 3) SWAP( 0, 2)  3  2  1  4  5  6  7
SWAP( 0, 2)  1  2  3  4  5  6  7
DH( 0, 2) SWAP( 0, 1)  2  1  3  4  5  6  7
SWAP( 0, 1)  1  2  3  4  5  6  7
DONE:::::::  1  2  3  4  5  6  7
```


---
### 実行例(2)
---
- 入力データ
```
13 10 15 8 4 12 9 11 5 3 13 1 2 6
```
- 出力例
```
INIT::::::: 10 15  8  4 12  9 11  5  3 13  1  2  6
DH( 4,13) SWAP( 4, 9) 10 15  8  4 13  9 11  5  3 12  1  2  6
DH( 3,13) SWAP( 3, 7) 10 15  8  5 13  9 11  4  3 12  1  2  6
DH( 2,13) SWAP( 2, 6) 10 15 11  5 13  9  8  4  3 12  1  2  6
DH( 0,13) SWAP( 0, 1) 15 10 11  5 13  9  8  4  3 12  1  2  6
DH( 0,13) SWAP( 1, 4) 15 13 11  5 10  9  8  4  3 12  1  2  6
DH( 0,13) SWAP( 4, 9) 15 13 11  5 12  9  8  4  3 10  1  2  6
SWAP( 0,12)  6 13 11  5 12  9  8  4  3 10  1  2 15
DH( 0,12) SWAP( 0, 1) 13  6 11  5 12  9  8  4  3 10  1  2 15
DH( 0,12) SWAP( 1, 4) 13 12 11  5  6  9  8  4  3 10  1  2 15
DH( 0,12) SWAP( 4, 9) 13 12 11  5 10  9  8  4  3  6  1  2 15
SWAP( 0,11)  2 12 11  5 10  9  8  4  3  6  1 13 15
DH( 0,11) SWAP( 0, 1) 12  2 11  5 10  9  8  4  3  6  1 13 15
DH( 0,11) SWAP( 1, 4) 12 10 11  5  2  9  8  4  3  6  1 13 15
DH( 0,11) SWAP( 4, 9) 12 10 11  5  6  9  8  4  3  2  1 13 15
SWAP( 0,10)  1 10 11  5  6  9  8  4  3  2 12 13 15
DH( 0,10) SWAP( 0, 2) 11 10  1  5  6  9  8  4  3  2 12 13 15
DH( 0,10) SWAP( 2, 5) 11 10  9  5  6  1  8  4  3  2 12 13 15
SWAP( 0, 9)  2 10  9  5  6  1  8  4  3 11 12 13 15
DH( 0, 9) SWAP( 0, 1) 10  2  9  5  6  1  8  4  3 11 12 13 15
DH( 0, 9) SWAP( 1, 4) 10  6  9  5  2  1  8  4  3 11 12 13 15
SWAP( 0, 8)  3  6  9  5  2  1  8  4 10 11 12 13 15
DH( 0, 8) SWAP( 0, 2)  9  6  3  5  2  1  8  4 10 11 12 13 15
DH( 0, 8) SWAP( 2, 6)  9  6  8  5  2  1  3  4 10 11 12 13 15
SWAP( 0, 7)  4  6  8  5  2  1  3  9 10 11 12 13 15
DH( 0, 7) SWAP( 0, 2)  8  6  4  5  2  1  3  9 10 11 12 13 15
SWAP( 0, 6)  3  6  4  5  2  1  8  9 10 11 12 13 15
DH( 0, 6) SWAP( 0, 1)  6  3  4  5  2  1  8  9 10 11 12 13 15
DH( 0, 6) SWAP( 1, 3)  6  5  4  3  2  1  8  9 10 11 12 13 15
SWAP( 0, 5)  1  5  4  3  2  6  8  9 10 11 12 13 15
DH( 0, 5) SWAP( 0, 1)  5  1  4  3  2  6  8  9 10 11 12 13 15
DH( 0, 5) SWAP( 1, 3)  5  3  4  1  2  6  8  9 10 11 12 13 15
SWAP( 0, 4)  2  3  4  1  5  6  8  9 10 11 12 13 15
DH( 0, 4) SWAP( 0, 2)  4  3  2  1  5  6  8  9 10 11 12 13 15
SWAP( 0, 3)  1  3  2  4  5  6  8  9 10 11 12 13 15
DH( 0, 3) SWAP( 0, 1)  3  1  2  4  5  6  8  9 10 11 12 13 15
SWAP( 0, 2)  2  1  3  4  5  6  8  9 10 11 12 13 15
SWAP( 0, 1)  1  2  3  4  5  6  8  9 10 11 12 13 15
DONE:::::::  1  2  3  4  5  6  8  9 10 11 12 13 15
```


---
### 実行例(3)
---
- 入力データ
```
7 7 6 5 4 3 2 1
```
- 出力例
```
INIT:::::::  7  6  5  4  3  2  1
SWAP( 0, 6)  1  6  5  4  3  2  7
DH( 0, 6) SWAP( 0, 1)  6  1  5  4  3  2  7
DH( 0, 6) SWAP( 1, 3)  6  4  5  1  3  2  7
SWAP( 0, 5)  2  4  5  1  3  6  7
DH( 0, 5) SWAP( 0, 2)  5  4  2  1  3  6  7
SWAP( 0, 4)  3  4  2  1  5  6  7
DH( 0, 4) SWAP( 0, 1)  4  3  2  1  5  6  7
SWAP( 0, 3)  1  3  2  4  5  6  7
DH( 0, 3) SWAP( 0, 1)  3  1  2  4  5  6  7
SWAP( 0, 2)  2  1  3  4  5  6  7
SWAP( 0, 1)  1  2  3  4  5  6  7
DONE:::::::  1  2  3  4  5  6  7
```

---
## ヒント
---

- 降順の二分ヒープ木は配列を使って表現することができる．その時の二分ヒープ木の節点番号と配列のインデックスの対応は以下の図のようになる．ただし，以下の図は昇順の二分ヒープ木の例である．
<br>

![](../images/radix_sort.png
参照:https://medium.com/@yasufumy/data-structure-heap-ecfd0989e5be

<br>

ヒープソートの基本的な流れは以下のようになる．
- 1, 配列を先頭を根とする降順の二分ヒープ木に並べ替える．

- 2, 二分ヒープ木の根の値（最大値）を取り出し，二分ヒープ木の末尾と入れ替える．

- 3, 二分ヒープ木の大きさを1減らす．

- 4, 二分ヒープ木の根を節点としてdownheapを呼び出すことで二分ヒープ木を再構築する．

- 5, 2$\~$4をソートが完了するまで繰り返す．




