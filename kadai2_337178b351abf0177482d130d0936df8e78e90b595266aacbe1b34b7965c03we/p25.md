---
layout: page
title: 2-5. 基数ソート
---


ここでは，<font color="red">比較に基づかないソート</font>の一種である<font color="red">基数ソート (radix sort)</font>を実装してみよう．

基数ソートとは，これまでのソートとは異なり，要素どうしを比較せずにソートする方法である．
ただし，基数ソートをおこなうためには，ソートの対象となるデータが整数といった基数を設定できる場合に限る．
つまり，可変長の文字列や二項間の大小関係しか定義できないデータでは一般的に使えない．
また，整数であった場合でも非常に大きな値の場合は効率がわるくなるため，比較に基づくソートを使った方が効率がよい場合が多い．
一般論として，世の中にはそういったデータの方が多いため基数ソートはあまり用いられていないが，基数ソートの考え方はきちんと知っておくべきである．


基数ソートでは，まず基数を決める．
最もわかりやすいのは10である．

基本的な処理は，以下のようになる．
- （データの最大値を取得する．これは効率よく計算するためである）
- M進数における、乗数に対応する桁の値を取り出す。
  - 例：値aのM進数表記におけるi桁目の値は以下の式で取り出すことができる。
  - $a / M^{i - 1} % M$
  - それぞの値を基数で割った値の余りを用いて，割り当て先となるバケット番号を取得
- 割り当て先のバケットに値を割り当てる．ただし，この時に同じ割り当て先になる要素が多数あることが想定されるが，割り当て前の値の順序を保持したまま割り当てることが条件となる．
  - この割り当て処理は，実際に実装する際にはいろいろ課題がある．割り当て先への割り当て数が事前にわからないと，余計な記憶領域を確保しておかなくてはいけなくなり，効率が悪くなる．
  - 割り当ての方法は限定されないが，ここでは以下の手順に限定する．
    - まず基数で割った余りの値のそれぞれの個数を数える．
    - 例：10  2  8  4 11  9 11  5  3 13  1  2  6　で基数3の場合
      - 0: 3つ：9 3 6
      - 1: 4つ：10 4 13 1
      - 2: 6つ：2 8 11 11 5 2
    - 要素数$N(=13)$の作業用配列を用意し，そこに対してそれぞれの個数の先頭位置から値をコピー
      - 0の場合：要素番号0から2までの範囲に値をコピー
      - 1の場合：要素番号3から6までの範囲に値をコピー
      - 2の場合：要素番号7から12までの範囲に値をコピー
    - こうすることで挿入先を重複させることなく値のコピーができる．
    - コピーした値を元の配列の場所にもどす．
- 基数を乗数を一つ増やして処理を繰り返す．
  - 基数の乗数が最大値を超えたら処理が完了．

---
## 問題
---
与えられた配列データを<font color="red">基数ソート</font>により<font color="red">昇順</font>に並べ替えるプログラムを作成せよ．

---
### 仕様
---

- 課題2-0に記載の仕様全て

- 入力データ
  - <font color="red">＊＊</font>本課題の入力データは，これまでと異なり，入力データの最後に基数$M$が追加される．つまり，データの個数$N$，データ1,...,データ$N$，基数$M$という$N+2$個の整数となる．

- 基数ソートを実行するためには，割り当て操作を行う際にデータの配列とは別に作業用記憶領域が必要となる．
  - データを読み込む配列を動的確保する際に，2倍の領域を確保する．つまりデータの要素数が$N$なら$2N$個のメモリを確保すること．
  - 余計に確保した記憶領域を作業用記憶領域として利用すること．つまり，データ配列の値を作業用記憶領域を含めた$2N$個の記憶域から外に取り出してはいけない．


- 配列操作に利用可能な関数
  - <font color="red">＊＊</font> 配列内の要素を配列内の別の場所にコピーする手続きとして`func_copy_val_`関数を用いること．これは，挿入対象の値を退避したり挿入する場合も含まれる．
    - <font color="red">＊＊</font>（`func_swap_` は用いない）
  - 配列内のある範囲の要素を表示する手続きとして`print_array_`関数を用いること．

- 配列を選択ソートによって並び替える `rad_sort` 関数を作成すること．また，以下の仕様を満すこと．
  - 配列の要素を並び替える操作は全てこの関数内で行うこと．
    - ただし，この関数内で呼ばれる別の関数を作成してもよい．その際は必ず前方宣言すること．
  - 入力データ用に動的に確保した配列，入力データの個数，割り当て先を決定する配列，基数の4つを引数とすること．
    - 例：
    ```
    int rad_sort(int *array, int N, int* bucket, int M) ...
    ```
  - 処理に必要な基数の最大の乗数を`rad_sort` 関数の戻り値とすること．

- 表示
  - <font color="red">＊＊</font> 一回の割り当て処理が終わる度に，配列全体の要素を以下の書式で表示すること．
    - <font color="red">＊＊</font> 用いた基数の乗数の値$i$を用いて RAD$(M^{i})$ と表示し，空白後に配列の全要素を表示する．
  	- 例：入力データ：10  2  8  4 11  9 11  5  3 13  1  2  6，基数が3,乗数が1の場合
	  ```
      RAD(⊔⊔⊔⊔⊔3)⊔⊔9⊔10⊔⊔1⊔⊔2⊔11⊔11⊔⊔2⊔⊔3⊔⊔4⊔13⊔⊔5⊔⊔6⊔⊔8↩︎
      ```
    - RAD$(i)$の$i$の桁数は6桁とする．

- 以下のプログラムを必ず用いてプログラムを完成せること．

```
#include <stdio.h>
#include <stdlib.h>

int* func_copy_val_(   // ???
    int* const array,  // ???
    const int pos_a,   // ???
    const int pos_b    // ???
) {
  array[pos_b] = array[pos_a];  // ???
  return array;                 // ???
}

void print_array_(           // ???
    const int* const array,  // ???
    const int N              // ???
) {
  int ri = 0;
  for (; ri < N; ++ri) {        // ???
    printf(" %2d", array[ri]);  // ???
  }
  printf("\n");  // ???
}

int* func_mallocation_(  // ???
    const int N          // ???
) {
  int* data = (int*)malloc(N * sizeof(int));  // ???
  if (data == NULL) {                         // ???
    printf("Can not allocate memory. 'data' is NULL.\n");
    exit(EXIT_FAILURE);  // ???
  }
  return data;  // ???
}

///////

int rad_sort(int *, int , int *, int );

int main() {

  ...(省略)...

  return 0;               //
}

int rad_sort(int* array, int N, int* bucket, int M) {

  ...(省略)...

}
```



---
## 実行例
---
---
### 実行例(1)
---
- 入力データ
```
7 2 1 3 7 4 6 5 2
```
- 出力例
```
INIT:::::::  2  1  3  7  4  6  5
RAD(     1)  2  4  6  1  3  7  5
RAD(     2)  4  1  5  2  6  3  7
RAD(     4)  1  2  3  4  5  6  7
DONE:::::::  1  2  3  4  5  6  7
2
```


---
### 実行例(2)
---
- 入力データ
```
13 10 2 8 4 11 9 11 5 3 13 1 2 6 3
```
- 出力例
```
INIT::::::: 10  2  8  4 11  9 11  5  3 13  1  2  6
RAD(     1)  9  3  6 10  4 13  1  2  8 11 11  5  2
RAD(     3)  9 10  1  2 11 11  2  3  4 13  5  6  8
RAD(     9)  1  2  2  3  4  5  6  8  9 10 11 11 13
DONE:::::::  1  2  2  3  4  5  6  8  9 10 11 11 13
2
```


---
### 実行例(3)
---
- 入力データ
```
7 2 1 1 2 3 1 2 2
```
- 出力例
```
INIT:::::::  2  1  1  2  3  1  2
RAD(     1)  2  2  2  1  1  3  1
RAD(     2)  1  1  1  2  2  2  3
DONE:::::::  1  1  1  2  2  2  3
1
```
