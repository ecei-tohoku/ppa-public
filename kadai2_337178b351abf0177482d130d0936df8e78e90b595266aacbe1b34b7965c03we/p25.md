---
layout: page
title: 2-5. 基数ソート
---


ここでは，<font color="red">比較に基づかないソート</font>の一種である<font color="red">基数ソート (radix sort)</font>を実装してみよう．

基数ソートとは，これまでのソートとは異なり，要素どうしを比較せずにソートする方法である．
ただし，基数ソートをおこなうためには，ソートの対象となるデータが整数といった基数を設定できる場合に限る．
つまり，可変長の文字列や二項間の大小関係しか定義できないデータでは一般的に使えない．
また，整数であった場合でも非常に大きな値の場合は効率がわるくなるため，比較に基づくソートを使った方が効率がよい場合が多い．
一般論として，世の中にはそういったデータの方が多いため基数ソートはあまり用いられていないが，基数ソートの考え方はきちんと知っておくべきである．

---
## 問題
---
与えられた配列データを<font color="red">基数ソート</font>により<font color="red">昇順</font>に並べ替えるプログラムを作成せよ．

---
### 仕様
---

- 課題2-0に記載の仕様全て

  - ただし，本課題に限り一部の操作は自由に行って良いこととする．(仕様をよく確認すること)

<br>

- 入力データ

  - <font color="red">＊＊</font>本課題の入力データは，これまでと異なり，入力データの最後に基数$M$が追加される．つまり，データの個数$N$，データ1,...,データ$N$，基数$M$という$N+2$個の整数となる．

<br>     

- 配列操作

  - <font color="red">＊＊</font> 本課題では，配列に値を代入する操作は自由に行って良いものとする．(データ配列からバケット配列に値を移す操作や，バケット配列からデータ配列に値を戻す操作など．)
  - 配列内のある範囲の要素を表示する手続きとして`print_array_`関数を用いること．

<br>


- 配列を基数ソートによって並び替える `rad_sort` 関数を作成すること．

  - バケット配列はこの関数内で宣言すること．この時，<font color="red">バケット配列は自由に確保しても良いものとする．</font>

  - 配列の要素を並び替える操作は全てこの関数内で行うこと．
    - ただし，この関数内で呼ばれる別の関数を作成してもよい．その際は必ず前方宣言すること．
  - 入力データ用に動的に確保した配列，入力データの個数，基数の3つを引数とすること．
    ```
    void rad_sort(int *array, int N, int M) ...
    ```

<br>

- 表示

  - <font color="red">＊＊</font> 一回の割り当て処理が終わる度に，配列全体の要素を以下の書式で表示すること．
    - ソートに用いた桁$i$を用いて RAD$(i)$ と表示し，空白後に配列の全要素を表示する．
  	- 例：入力データ：10  2  8  4 11  9 11  5  3 13  1  2  6，基数が3,桁が2の場合
	  ```
      RAD(⊔⊔⊔⊔⊔2)⊔⊔9⊔10⊔⊔1⊔⊔2⊔11⊔11⊔⊔2⊔⊔3⊔⊔4⊔13⊔⊔5⊔⊔6⊔⊔8↩︎
      ```

<br>

- 題2-0に提示してある関数と題2-1に提示してある`func_copy_val_`と`print_array_range_`を`ppa_extra_h/p2_header.h`というファイルにおいてある．`#include "ppa_extra_h/p2_header.h"`という宣言を通して含めたら、こちらの関数を書かなくても呼べる：`func_swap_`、`comp_`、`print_array_`、`func_mallocation_`、`func_copy_val_`、`print_array_range_`

<br>


- 以下のプログラムを必ず用いてプログラムを完成せること．

```
#include <stdio.h>
#include <stdlib.h>
#include “ppa_extra_h/p2_header.h”

void rad_sort(int *, int, int );

int main() {

  ...(省略)...

  return 0;               //
}

void rad_sort(int* array, int N, int M) {

  ...(省略)...

}
```


---
## 実行例
---
---
### 実行例(1)
---
- 入力データ
```
7 2 1 3 7 4 6 5 2
```
- 出力例
```
INIT:::::::  2  1  3  7  4  6  5
RAD(     1)  2  4  6  1  3  7  5
RAD(     2)  4  1  5  2  6  3  7
RAD(     3)  1  2  3  4  5  6  7
DONE:::::::  1  2  3  4  5  6  7
```


---
### 実行例(2)
---
- 入力データ
```
13 10 2 8 4 11 9 11 5 3 13 1 2 6 3
```
- 出力例
```
INIT::::::: 10  2  8  4 11  9 11  5  3 13  1  2  6
RAD(     1)  9  3  6 10  4 13  1  2  8 11 11  5  2
RAD(     2)  9 10  1  2 11 11  2  3  4 13  5  6  8
RAD(     3)  1  2  2  3  4  5  6  8  9 10 11 11 13
DONE:::::::  1  2  2  3  4  5  6  8  9 10 11 11 13
```


---
### 実行例(3)
---
- 入力データ
```
7 2 1 1 2 3 1 2 2
```
- 出力例
```
INIT:::::::  2  1  1  2  3  1  2
RAD(     1)  2  2  2  1  1  3  1
RAD(     2)  1  1  1  2  2  2  3
DONE:::::::  1  1  1  2  2  2  3
```

---
## ヒント
---
#### **基数ソートの基本的な流れは以下のようになる．**

  1. 各値をM進数表記で考える．(プログラム中で実際にM進数に直す必要はない)
  2. 小さい桁の方から，その桁の値をもとにソートする．
  3. 見ている桁がデータの最大の桁数を超えたら終了．

<br>

#### **1.各値をM進数表記で考える．**
- 基数ソートでは，M進数おける各桁の値が必要になる．

- 値$a$が$M$進数で$c_3c_2c_1c_0$と表される時，

  $$a=c_3\times M^3+c_2\times M^2+c_1\times M^1+c_0\times M^0$$

  である．例として ${47_{(10)}=1201_{(3)}}$は，以下のようになる．

  $$47_{(10)}=1\times 3^3+2\times 3^2+0\times 3^1+2\times 3^0$$


- ここで$M$進数の$i$桁目($=c_{i - 1}$)を取り出す方法を考える．

  $$a=...c_{i}\times M^i+c_{i-1}\times M^{i-1}+...c_1\times M^1+c_0\times M^0$$

  で与えられる時，両辺を$M^{i-1}$で割ると，

  $$a / M^{i-1}=...c_{i+1}\times M^2+c_i\times M^1+c_{i-1}\times M^0$$

  となり，さらに両辺をMで割った余りを求めると，

  $$a/M^{i-1} \% M=c_{i-1}$$

  となり，$M$進数における$i$桁目の値を取り出すことができる．

<br>

#### **2.小さい方の桁から，その桁の値をもとにソートする．**
- 上記の方法で値を取り出すことができたら，その値を用いてデータをソートすることを考える．
- 具体的に$i$桁目での操作は以下のようになる．

    - 上記の方法でi桁目の値を取り出す．
    - 取り出した値が，そのデータを追加するバケット番号に対応している．
    - 全てのデータをバケットに入れたら，バケット番号の小さい方から値を取り出してデータを復元する．

<br>

- 例：$array={10,2,8,4,11,9,11,5,3,13,1,2,6}$で基数=$3$での操作
    ```
            　  データ:  10   2   8   4  11   9  11   5   3  13   1   2   6  
    ３進数における１桁目:   1   2   2   1   2   0   2   2   0   1   1   2   0
    ```
    ↓bucketに挿入
    ```   
    bucket[0]:  9   3   6   -   -   -   -   -
    bucket[1]: 10   4  13   1   -   -   -   -
    bucket[2]:  2   8  11  11   5   2   -   -
    ```
    ↓復元
    ```
    データ: 9 3 6 10 4 13 1 2 8 11 11 5 2
    ```

    <br>

    ```
            　  データ:   9   3   6  10   4  13   1   2   8  11  11   5   2  
    ３進数における２桁目:   0   1   2   0   1   1   0   0   2   0   0   1   0
    ```
    ↓bucketに挿入
    ```   
    bucket[0]:  9  10   1   2  11  11   2   -
    bucket[1]:  3   4  13   5   -   -   -   -
    bucket[2]:  6   8   -   -   -   -   -   -
    ```
    ↓復元
    ```
    データ: 9 10 1 2 11 11 2 3 4 13 5 6 8
    ```

    <br>

    ```
    　　　　　　　データ:   9  10   1   2  11  11   2   3   4  13   5   6   8  
    ３進数における２桁目:   1   1   0   0   1   1   0   0   0   1   0   0   0
    ```
    ↓bucketに挿入
    ```   
    bucket[0]:  1   2   2   3   4   5   6   8
    bucket[1]:  9  10  11  11  13   -   -   -
    bucket[2]:  -   -   -   -   -   -   -   -
    ```
    ↓復元
    ```
    データ: 1 2 2 3 4 5 6 8 9 10 11 11 13
    ```

    <br>

<!--
  |array|10|2|8|4|11|9|11|5|3|13|1|2|6|
  |:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
  |3進数における1桁目|1|2|2|1|2|0|2|2|0|1|1|2|0|

  ↓bucketに挿入

  |要素番号|0|1|2|3|4|5|6|7|
  |:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
  |bucket[0]|9|3|6|-|-|-|-|-|
  |bucket[1]|10|4|13|1|-|-|-|-|
  |bucket[2]|2|8|11|11|5|2|-|-|

  ↓復元

  |array|9|3|6|10|4|13|1|2|8|11|11|5|2|
  |:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|


  |array|9|3|6|10|4|13|1|2|8|11|11|5|2|
  |:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
  |3進数における2桁目|0|1|2|0|1|1|0|0|2|0|0|1|0|

  ↓bucketに挿入

  |要素番号|0|1|2|3|4|5|6|7|
  |:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
  |bucket[0]|9|10|1|2|11|11|2|-|
  |bucket[1]|3|4|13|5|-|-|-|-|
  |bucket[2]|6|8|-|-|-|-|-|-|

  ↓復元

  |array|9|10|1|2|11|11|2|3|4|13|5|6|8|
  |:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|


  |array|9|10|1|2|11|11|2|3|4|13|5|6|8|
  |:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
  |3進数における3桁目|1|1|0|0|1|1|0|0|0|1|0|0|0|

  ↓bucketに挿入

  |要素番号|0|1|2|3|4|5|6|7|
  |:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
  |bucket[0]|1|2|2|3|4|5|6|8|
  |bucket[1]|9|10|11|11|13|-|-|-|
  |bucket[2]|-|-|-|-|-|-|-|-|

  ↓復元

  |array|1|2|2|3|4|5|6|8|9|10|11|11|13|
  |:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
-->



- 考察点
    - bucket配列は上の表からわかるように素直な実装では２次元配列として表現される．
    どの程度の大きさの配列を確保すれば十分か考えてみましょう．(上の例は不十分です)


    - 基数ソートでは前の桁のソート結果を保ったままソートする必要がある．
      つまり，挿入先のバケットが同じ場合に無闇に順番を入れ替えてはいけないということである．
      このことを踏まえて，どのような順番でバケットに挿入し，どのような順番で取り出せば良いか考えてみましょう．

<br>

#### **3．見ている桁がデータの最大の桁数を超えたら終了．**
- 値$a$の桁数が$p$である時，$a<M^{p}$ が成り立つ．
- よって，現在見ている桁が$i$桁目である時，array中の全てのデータ$a$対して$a < M^i$であれば終了して良いということになる．
- これは，array中の最大値を予め求めておくことで，高速に判定することができる．
