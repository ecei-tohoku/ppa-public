---
layout: page
title: 2-4. マージソート
---


ここでは，<font color="red">分割/統合に基づくソート</font>である<font color="red">マージソート (merge sort)</font>を実装してみよう．

マージソートのアルゴリズムは与えられた配列データを小さな部分配列に分割し，部分配列ごとにソートを行なう分割統治法の代表的アルゴリズムの一つである．
マージソートでは<font color="red">再帰関数</font>を使って効率的にアルゴリズムを構築することを学ぶ．

今回は、補助関数mergeを利用する。 mergeは2つの並べ替えられた配列を受け取り、以下のプロセスで結合する．

- 0, 入力配列の長さの合計に等しい長さの空の出力配列を準備する．
- 1, 各入力配列から出力配列にまだ追加されていない最初の要素を比較し、最小のものを$ m $とする．
- 2, 出力配列の最初の空のスペースに$ m $を追加する．
- 3, 入力配列が両方とも出力配列に完全に追加されていない場合は、（2）に戻る．
- 4, 出力配列にまだ追加されていない入力配列をそのまま出力配列の最後にコピーする．

次に、マージソートは、以下のプロセスに従って、mergeと再帰を使用して入力配列をソートする．

- 0, 入力配列の長さが1の場合、すでに並べ替えられているため、そのまま返す．
- 1, 入力配列の長さが1より大きい場合、入力配列を同じ長さの2つの配列に分割する．
- 2, マージソートを2回呼ぶ。新しく作成された半分の長さの配列のそれぞれに対して1回である．
- 3, ソートされた半分の長さの配列に対してmergeを呼び、それらを1つの全体の長さの並べ替えられた配列に結合する．

![Merge Sort](https://i.imgur.com/KVKxFuE.png)
![Merge Sort](https://i.imgur.com/QQUmTtI.png)

---
## 問題
---
与えられた配列データを<font color="red">マージソート</font>により<font color="red">昇順</font>に並べ替えるプログラムを作成せよ．

---
### 仕様
---


- 課題2-0に記載の仕様全て

- マージソートを実行するためには，マージ操作を行う際にデータの配列とは別にマージ用記憶領域が必要となる．
  - データを読み込む配列を動的確保する際に，2倍の領域を確保する．つまりデータの要素数が$N$なら$2N$個のメモリを確保すること．
  - 余計に確保したメモリをマージ用記憶領域として利用すること．つまり，データ配列の値をマージ用記憶領域を含めた$2N$個の記憶域から外に取り出してはいけない．


- 配列操作に利用可能な関数
  - 配列内の要素を配列内の別の場所にコピーする手続きとして`func_copy_val_`関数を用いること．これは，挿入対象の値を退避したり挿入する場合も含まれる．
  - `func_swap_` は用いない
  - 配列内の二つの要素を比較する手続きとして`comp_`関数を用いること．
  - 配列内のある範囲の要素を表示する手続きとして`print_array_range_`関数を用いること．
  - `print_array_`関数をは用いない

- 配列をマージソートによって並び替える `mrg_sort` 関数を作成すること．また，以下の仕様を満すこと．
  - 配列の要素を並び替える操作は全てこの関数内で行うこと．
    - ただし，この関数内で呼ばれる別の関数を作成してもよい．その際は必ず前方宣言すること．
  - 入力データ用に動的に確保した配列，入力データの個数，mergeの対象となる範囲として始まりの要素番号，終わりの要素番号の4つを引数とすること．
    - 例：
    ```
    int mrg_sort(int *array, int N, int p, int q) ...
    ```
  - 要素間の比較`comp_`の呼び出し回数を`mrg_sort` 関数の戻り値とすること．
  - 要素の値が同じ場合など，入れ替える必要がない場合は入れ替えてはいけない．
  - 配列を分割する際に，奇数で割り切れない場合は，必ず配列の先頭側を一つ多くすること．

- 二つのソート済み配列をマージする`merge`関数を作成すること．また，以下の仕様を満すこと．
  - `mrg_sort`関数内で呼ばれる．
  - 配列の要素をマージする操作は全てこの関数内で行うこと．
    - ただし，この関数内で呼ばれる別の関数を作成してもよい．その際は必ず前方宣言すること．
  - 入力データ用に動的に確保した配列，入力データの個数，mergeの対象となる範囲として始まりの要素番号，終わりの要素番号，中間の要素番号の5つを引数とすること．
    - 例：
    ```
    int merge(int *array, int N, int p, int q, int r) ...
    ```

- 表示
  ```
  void print_array_range_(
      const int* const array,
  　  const int N,
  　  const int p, const int r) {
    int ri = 0;
    for (; ri < N; ++ri) {
      if (ri < p || r < ri) {
        printf(" **");
      } else {
        printf(" %2d", array[ri]);
      }
    }
    printf("\n");
  }
  ```
  - 上の関数を使って値のマージ処理が終わる度に，マージした範囲と配列全体の要素を以下の書式で表示すること．
    - マージした範囲の要素番号$i,j(i<j)$を用いて MERG$(i,j)$ と表示し，空白後に交換後の配列の全要素を表示する．
    - 例：要素番号 0,4の範囲をマージした場合
    ```
    MERG(⊔2,⊔4)⊔**⊔**⊔⊔8⊔⊔4⊔11⊔**⊔**⊔**⊔**⊔**⊔**↩︎
    ```

- 題2-0に提示してある関数と題2-1に提示してある`func_copy_val_`と`print_array_range_`を`ppa_extra_h/p2_header.h`というファイルにおいてある．`#include "ppa_extra_h/p2_header.h"`という宣言を通して含めたら、こちらの関数を書かなくても呼べる：`func_swap_`、`comp_`、`print_array_`、`func_mallocation_`、`func_copy_val_`、`print_array_range_`

- 以下のプログラムを必ず用いてプログラムを完成せること．

```
#include <stdio.h>
#include <stdlib.h>
#include “ppa_extra_h/p2_header.h”

int mrg_sort(int *, int , int , int );
int merge(int *, int , int , int , int );

int main() {

  ...(省略)...

  return 0;
}

int mrg_sort(int* array, int N, int p, int q) {

  ...(省略)...

}

int merge(int* array, int N, int p, int q, int r) {

  ...(省略)...

}
```


---
## 実行例
---
---
### 実行例(1)
---
- 入力データ
```
7 2 1 3 7 4 6 5
```
- 出力例
```
INIT:::::::  2  1  3  7  4  6  5
MERG( 0, 1)  1  2 ** ** ** ** **
MERG( 2, 3) ** **  3  7 ** ** **
MERG( 0, 3)  1  2  3  7 ** ** **
MERG( 4, 5) ** ** ** **  4  6 **
MERG( 4, 6) ** ** ** **  4  5  6
MERG( 0, 6)  1  2  3  4  5  6  7
DONE:::::::  1  2  3  4  5  6  7
13
```


---
### 実行例(2)
---
- 入力データ
```
13 10 2 8 4 11 9 11 5 3 13 1 2 6
```
- 出力例
```
INIT::::::: 10  2  8  4 11  9 11  5  3 13  1  2  6
MERG( 0, 1)  2 10 ** ** ** ** ** ** ** ** ** ** **
MERG( 2, 3) ** **  4  8 ** ** ** ** ** ** ** ** **
MERG( 0, 3)  2  4  8 10 ** ** ** ** ** ** ** ** **
MERG( 4, 5) ** ** ** **  9 11 ** ** ** ** ** ** **
MERG( 4, 6) ** ** ** **  9 11 11 ** ** ** ** ** **
MERG( 0, 6)  2  4  8  9 10 11 11 ** ** ** ** ** **
MERG( 7, 8) ** ** ** ** ** ** **  3  5 ** ** ** **
MERG( 7, 9) ** ** ** ** ** ** **  3  5 13 ** ** **
MERG(10,11) ** ** ** ** ** ** ** ** ** **  1  2 **
MERG(10,12) ** ** ** ** ** ** ** ** ** **  1  2  6
MERG( 7,12) ** ** ** ** ** ** **  1  2  3  5  6 13
MERG( 0,12)  1  2  2  3  4  5  6  8  9 10 11 11 13
DONE:::::::  1  2  2  3  4  5  6  8  9 10 11 11 13
36
```


---
### 実行例(3)
---
- 入力データ
```
7 2 1 1 2 3 1 2
```
- 出力例
```
INIT:::::::  2  1  1  2  3  1  2
MERG( 0, 1)  1  2 ** ** ** ** **
MERG( 2, 3) ** **  1  2 ** ** **
MERG( 0, 3)  1  1  2  2 ** ** **
MERG( 4, 5) ** ** ** **  1  3 **
MERG( 4, 6) ** ** ** **  1  2  3
MERG( 0, 6)  1  1  1  2  2  2  3
DONE:::::::  1  1  1  2  2  2  3
14
```







