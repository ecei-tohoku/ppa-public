---
layout: page
title: 2-1. 選択ソート【1, 2週目のみ採点】
---

与えられたデータを一定の大小関係に基づいて並べ替えることを**ソート**と呼ぶ．
「並べ替える」というと単純そうだが，ソートの手順（**アルゴリズム**）には様々なバリエーションが存在し，またこれらを学ぶ中で**計算量**（complexity）や**再帰**（recursion）といった重要な概念に触れることができるため，ソートは計算機科学のカリキュラムに必ず登場する基本的なトピックとなっている．


ここではもっともシンプルなソートアルゴリズムのひとつである**選択ソート**（selection sort）を実装しよう．

選択ソートは，次の手順で配列を並べ替えるアルゴリズムである．ただしここでは昇順（小さい方から順番に並べる）を想定している．

1. 配列全体から，もっとも値の小さいデータを探し，配列の先頭(1番目)に移動する．
2. 配列の<font color="red">残りのデータ</font>の中から，もっとも値の小さいデータ（全体で2番目に値の小さいデータ）を探し，配列の先頭から2番目に移動する．
3. 配列の<font color="red">残りのデータ</font>の中から，もっとも値の小さいデータ（全体で3番目に値の小さいデータ）を探し，配列の手前から3番目に移動する．
4. 以下同様

当然，ほぼ同じ考えとして，配列内の大きい値から選択し，配列の後ろから並べていく手順でも配列の先頭から昇順に並べ替えることができる．

---
## 問題
---
与えられた配列データを**選択ソート**（selection sort）により<font color="red">昇順</font>に並べ替えるプログラムを作成せよ．
ただし，配列の先頭から並べていく方法と，配列の末尾から並べていく方法の両方を順番に実行し，それぞれの手順で「ふたつの数の比較」の回数を数えよ．

- 入力データの仕様
    - データファイルは，半角スペースにより区切られた $n+1$ 個の正の整数が記載されている．
    - 先頭の正の整数は，残りの整数の個数$n$である．
    - 2番目以降の正の整数は，ソートの対象となるデータである．

プログラムは以下の仕様を満たすこと（以下の仕様を満たさない場合は減点する）．

- グローバル変数や静的変数を使用してはいけない．
- `include`するファイルは`<stdio.h>`および`<stdlib.h>`のみとする．
- プログラム全体の構成を以下に従うようにする．
  - `main`関数の正常終了時の戻り値0にする．
  - 関数の前方宣言を用い，関数本体は`main`関数の下に記述する．
    ```
      #include <stdio.h>
      #include <stdlib.h>

        ... 関数前方宣言 ...

      int main()
      {
        ...
        return 0;
      }

        ... 関数本体 ...
      ```

- 配列の動的確保
  - ソートすべき $n$ 個のデータを読み込む際には，以下の`malloc`を用いて，データの格納に必要なメモリ領域を動的に確保すること．
      ```
      int N;
      int *x;

        ...　データの個数$N$を読み込み　
      x = ( int * ) malloc ( N * sizeof ( int ) );
      ``` 
  - 動的に確保したメモリ領域は処理が完了した後に解放すること．
- データファイルの読み込は`main` 関数内で行うこと.
- 配列を選択ソートによって並び替える `selsort` 関数を作成すること．ただし，`selsort` 関数は以下の仕様を満すこと．
	- 動的に確保した配列とデータの個数 $n$ を引数とすること．
	- ソートの際に実行された比較命令の回数を`selsort` 関数の戻り値とすること．
  - 値を入れ替える関数として以下の関数`func_swap`を用いること
    ```
    int* func_swap(int* array, int posa, int posb)
    {
      int tmp=array[posa];
      array[posa]=array[posb];
      array[posb]=tmp;  
      printf("SWAP(%d,%d) ", posa, posb);
      return array;
    }
    ```



- 配列データの表示(出力)
  - 全ての表示は標準出力にすること．
  - 入力データを読み込んだ直後に配列データを以下の書式で表示すること．
    配列データの表示例（`⊔` は半角スペースを示す．）
    ```
    INIT:::::⊔1⊔3⊔2⊔4⊔6⊔5
	  ```
  - ソート後の配列データの各要素を先頭から順番に書き出すること．ただし，`selsort` 関数内で表示してはいけない．必ず`main`関数でおこなうこと．
    - 配列データの表示は各要素を半角スペースで区切り，各表示の末尾には改行文字 `\n` を付けること．
    - ただし，最終要素と改行文字 `\n` の間には半角スペースをいれないこと．
  - 前記ソート後の配列データを出力後，比較回数を書き出すこと．ただし，`selsort` 関数内で表示してはいけない．必ず`main`関数でおこなうこと．
  - ソート処理が終わった後の配列データ，および，比較回数の表示例（`⊔` は半角スペースを示す．）　配列データ 1 2 3 4 5 6 ($n=6$), 比較回数 15 の場合
	  ```
	  DONE:::::⊔1⊔2⊔3⊔4⊔5⊔6
    15
	  ```

  - 配列を表示する関数として以下の関数を用いること
    ```
    void print_array(int* array, int N)
    {
      int i=0;
      for (; i<N-1; i++) printf("%d ", array[i]);
      printf("%d\n", array[N-1]);
    }
    ```
- ソート時の表示
	- 関数内で配列の要素を交換した場合は，交換した 2 要素の添字$i,j(i<j)$を用いて SWAP$(i,j)$ と表示し，空白後に交換後の配列データを表示する．ただし，交換が実行されなかった場合は何も表示してはいけない．
	- 添字0,3の要素を交換した場合の表示例（`⊔` は半角スペースを示す．）
		```
		SWAP(0,3)⊔1⊔3⊔2⊔4⊔6⊔5
		```

---
## 実行例
---
---
### 実行例(1)
---
- 入力データ
```
4 1 2 3 4
```
- 出力例
```
INIT::::: 1 2 3 4
DONE::::: 1 2 3 4
6
```
---
### 実行例(2)
---
- 入力データ
```
5 7 1 3 4 5
```
- 出力例
```
INIT::::: 7 1 3 4 5
SWAP(0,1) 1 7 3 4 5
SWAP(1,2) 1 3 7 4 5
SWAP(2,3) 1 3 4 7 5
SWAP(3,4) 1 3 4 5 7
DONE::::: 1 3 4 5 7
10
```
---
### 実行例(3)
---
- 入力データ
```
8 2 4 3 1 8 7 6 5
```
- 出力例
```
INIT::::: 2 4 3 1 8 7 6 5
SWAP(0,3) 1 4 3 2 8 7 6 5
SWAP(1,3) 1 2 3 4 8 7 6 5
SWAP(4,7) 1 2 3 4 5 7 6 8
SWAP(5,6) 1 2 3 4 5 6 7 8
DONE::::: 1 2 3 4 5 6 7 8
28
```


---
## 参考情報
---
---
### 関数
---

C 言語のプログラムは，`main` 関数内に動作させたい内容を記述すればよいが，プログラムの規模が大きくなるにつれて，`main` 関数の内容が膨大になってしまう．このような場合，適当な大きさの関数に分割してプログラムを書くことが多い．たとえば，繰り返し計算する部分を関数として実装することで，別の箇所から何回も呼び出すことができる．ここでは，関数を使ったプログラムを作成しよう．

---
### メモリ領域の動的確保
---

C言語では, int a[5]; のように, 配列を宣言して使用するためには具体的に要素数を指定する必要があります．
しかしこの仕組みは，今回の課題のように，配列の要素数が入力等から得られるまで不定の場合には不都合が生じてしまいます．
例えば，int a[5]; として用意した配列に10個の配列要素を読み込ませることはできませんし，
かといってあらかじめ int a[500]; のように多めに配列を用意していても，実際に入力される要素数が10や20だった場合は貴重なメモリ容量の無駄遣いになってしまいます．

C言語ではこのようにプログラムを実行するまで配列の要素数が決まらない場合に
必要に応じて必要なだけ配列要素を確保する `malloc`(えむあろっく，まろっく)と言う関数が用意されています．
今回の課題のように標準入力から配列の要素数が 10 と入力された場合は 
```
int *x;
x = ( int * ) malloc ( 10 * sizeof ( int ) );
```
のように `malloc` 関数を使用します．
`malloc` 関数は確保した領域の先頭ポインタを返すため、[] 演算子を用いることで
x[0],x[1],x[5] 等のようにポインタ x をあたかも配列 int x[10]; と宣言した場合のように扱うことができます．
(`malloc`関数を用いる場合は必ず確保に失敗した場合のエラー処理と `free` による解放処理を行ってください．)

- 高橋：10.4 文字列の操作
- 林：17.3 メモリ管理
- [課題解説資料](./kadai2-intro.pdf)

---
### 配列を引数にとる関数
---
C言語では以下のように記述することで配列を引数とする関数を作ることができます．

- 記述例(1): int func ( int *array ){ ・・・ };

例えば配列要素の総和を計算するプログラムは

```
#include <stdio.h>
#include <stdlib.h>

int func ( int *a, int n )

int main ()
{
	int sum, N=5;
	int *data;

  data = ( int * ) malloc ( N * sizeof ( int ) );
  if (data==NULL) {
    printf("Can not allocate memory. 'data' is NULL.\n");
    return 1;
  }

	sum = func ( data, N );
	printf ( "%d\n", sum );

  free(data);
	return 0;
}

int func ( int *a, int n )
{
	int i, ans = 0;
	for ( i=0; i < n; i++ )
	{
		ans += a[i];
	}
	return ans;
}
```

のように記述できます．

参考として配列を引数にとる場合は

- 記述例(2): int func ( int array[] ){ ・・・ };

のように通常の配列とポインタ型を区別するために，`int a[5];` のように宣言した配列を引数とする場合にはこのように書くことが推奨されます．

本課題では，`int *a = (int*)malloc(SIZE);` のように動的に確保した配列を使用するので前記(1)の記述法を用いることが推奨されます．
