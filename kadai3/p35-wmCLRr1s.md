---
layout: page
title: 3-5. 共通部分文字列のマッチング数【基本】
---

長さ $m$ の文字列 $X=(x_1 x_2 x_3 \dots x_m)$ が与えられたときに,

+ $X$を構成する文字を0文字以上取り除く
+ 残った文字を元の順番で並べる

ことによって得られる文字列を $X$ の部分文字列と呼ぶ.
例として, $X=edcba$ を考えると,二文字目と五文字目を取り除いた $ecb$ は部分文字列であるが,それを並び替えた $ebc$ や $bce$ は部分文字列ではない.


二つの文字列 $X=(x_1,x_2,\cdots,x_m)$ と $Y=(y_1, y_2,\cdots, y_n)$ が与えられたときに, $X$ と $Y$ の共通部分文字列のマッチング数 $N_{\rm match}$ を求める問題を考えよう.<font color="red">ただし, $X$ や $Y$ から取り除いてできる部分文字列が同じものだとしても,取り除き方の異なる操作によって生じる部分文字列は,異なる部分文字列として見なすことにする.</font> 例として, $X=aab$, $Y=ba$ の場合を考えると, $X$ から二文字目と三文字目を取り除いてできる $a$ と, $X$ から一文字目と三文字目を取り除いてできる $a$ を区別するということを意味する.したがって、共通部分文字列のマッチング数 $N_{\rm match}$ は, $(a,a,b)$ の3通りである<font color="red">(空文字は含めない)</font>.

次に,一般的な場合を考えよう.編集距離を求めた時と同じように,マッチング数を求めるために,漸化式を定義したい.
素朴には, $X$ と $Y$ の接頭辞をそれぞれ $X_{i}, Y_{j}$として, $X_{i-1}$ と $Y_{j-1}$のマッチング数, $X_{i-1}$ と $Y_{j}$のマッチング数, $X_{i}$ と $Y_{j-1}$のマッチング数の三つを用いて, $X_i$ と $Y_j$ のマッチング数を表せば良いと考えられるが,数え上げに重複が生じてしまい計算が非常に複雑になる.

そこで、数え上げに重複のない漸化式を得るために、用いる量の定義を工夫しよう. ${\rm dp}[i][j]$を次のように定義する. 

$$
{\rm dp}[i][j]:=\begin{cases}
&&\text{($X_i$ と $Y_j$からできる共通部分文字列のうち,}
\\
&&\text{$x_i$と$y_i$を共に含む共通部分文字列の個数)} & (x_i = y_j) 
\\
&&0 & (x_i \neq y_j)
\end{cases},\tag{1}
$$

(ここでは, $i=1,2,\cdots m$, $j=1,2,\cdots, n$としてカウントしていることに注意せよ.0からのカウントではない.)
このように定義すれば, ${\rm dp}[i][j]$ には数え上げに重複が存在せず,　$N_{\rm match}$ と ${\rm dp}[i][j]$ の間には次の関係が成立する.

$$
N_{\rm match} = \sum_{i=1}^m \sum_{j=1}^n {\rm dp}[i][j].\tag{2}
$$

また、定義より,${\rm dp}[i][j]$ には次のような漸化式が成立する.

$$
{\rm dp}[i][j] =
\begin{cases}
\sum_{k=1}^{i-1} \sum_{\ell=1}^{j-1}{\rm dp}[k][\ell]+1 & (x_i = y_j) 
\\
0 & (x_i \neq y_j)
\end{cases},\tag{3}
$$

これを視覚的に理解するために，$X = eat$, $Y = ate$の場合を考えよう．

| $i \setminus j$ |  $(Y_0)$  | a $(Y_1)$ | t $(Y_2)$ | e $(Y_3)$ |
|:---------------:|:---------:|:---------:|:---------:|:---------:|
|                 |           |     0     |     0     |     0     |
|       $(X_0)$   |     0     |     0     |     0     |     0     |
|  **e  $(X_1)$** |     0     |     0     |     0     |     1     |
|  **a  $(X_2)$** |     0     |     1     |     0     |     0     |
|  **t  $(X_3)$** |     0     |     0     |     2     |     0     |
{: .table .table-striped}

例えば，$X_3 = Y_2 = t$ なので　${\rm dp}[3][2] = \sum_{k=1}^{2} \sum_{\ell=1}^{1}{\rm dp}[k][\ell]+1 = 2$　になる．
また，$X_3 \neq Y_3$ なので　${\rm dp}[3][3] = 0$　になる．他の値も同様に計算される．

式(3)の漸化式を用いれば, 原理的には動的計画法によりマッチング数を求めることができるが,計算量が大きくなってしまう.
そこで,さらに新しい変数

$${\rm sumdp}[i][j]=\sum_{k=1}^{i} \sum_{\ell=1}^{j}{\rm dp}[k][\ell],\tag{4}
$$

を導入すると, 単純な計算により,次のような漸化式が成立することが分かる.

$$
{\rm sumdp}[i][j]={\rm sumdp}[i-1][j] + {\rm sumdp}[i][j-1] -{\rm sumdp}[i-1][j-1] + {\rm dp}[i][j].\tag{5}
$$

以上をまとめると,マッチング数 $N_{\rm match}={\rm sumdp}[m][n]$ を求めるためには,次の漸化式を解けば良い.

$$
{\rm dp}[i][j] = \begin{cases}
{\rm sumdp}[i-1][j-1] +1. & (x_i = y_j) \\
0 & (x_i \neq y_j)
\end{cases},\tag{6}
$$


ただし,$i=0$ または $j=0$ のとき,

$$
{\rm sumdp}[i][j]={\rm dp}[i][j]=0,\tag{7}
$$

である.

以下では$X = eat$, $Y = ate$の場合のsumdpの具体例を示す．

| $i \setminus j$ | 0 | 1 | 2 | 3 |
|:---------------:|:-:|:-:|:-:|:-:|
|                 |   | 0 | 0 | 0 |
|        0        | 0 | 0 | 0 | 0 |
|        1        | 0 | 0 | 0 | 1 |
|        2        | 0 | 1 | 1 | 2 |
|        3        | 0 | 1 | 3 | 4 |
{: .table .table-striped}

例えば，${\rm sumdp}[3][2] = {\rm sumdp}[2][2] + {\rm sumdp}[3][1] - {\rm sumdp}[2][1] + {\rm dp}[3][2] = 1 + 1 - 1 + 2 = 3$ になる．
また，sumdpを使って式(6)によりdpの次の値を計算できる．


---
## 問題
---
二つの文字列 $X$ と $Y$ が与えられる．
この $X$ と $Y$ の共通部分文字列のマッチング数 $N_{\rm match}$ を動的計画法を用いて求めよ．


---
## <font color="red">！！重要！！　問題全体を通しての仕様</font>
---

問題を通してのデフォルトの仕様を以下に説明する．ただし，各ステップで追加の仕様や注意書きがある場合はそちらを優先すること．

- グローバル変数や静的変数を使用してはいけない．
- `include`するファイルは`<stdio.h>`および`<stdlib.h>`のみとする．
- プログラム全体の構成を以下に従うようにする．
  - `main`関数の正常終了時の戻り値を0にする．
  - 関数は前方宣言を用い，関数本体は`main`関数の下に記述（定義）する．
 
    ```
    #include <stdio.h>
    #include <stdlib.h>

    ... 関数の前方宣言 ...

    int main(){

      ...（main関数本体）...

      return 0;
    }

      ... 関数の定義 ...
    ```

- 入力データの読み込み
  - 入力データの読み込は`main` 関数内で行うこと．
  + 入力用の文字列$X$や$Y$とその要素数は標準入力から与えられる．文字列はスペースを除く可読文字（アルファベット，数字，記号）のみで構成されていると仮定してよい．
  + 各文字列はスペースや改行で区切られる．

- 事前に定義されている関数(基本的に関数名の最後に`_`がついているもの)の中身を書き換えてはいけない．これらの関数は例えば，`printf`や`scanf`と同様に中身を書き換えられない関数として扱うこと．

- 表示例の`⊔` は半角スペース，`↩︎`は改行を表す．
- 表示(出力)
  - 全ての表示は標準出力にすること．
  - 全ての出力には改行文字 `\n` を付けること．特に最後の行の改行の有無に注意すること．
  - 各要素の間には空白文字を一つ入れる．
  - 改行前の空白文字などの表示されない文字を出力しないこと．



---
## ステップに分けてプログラミング
---
この問題では，「共通部分文字列のマッチング数」の計算を2ステップにより行う．ステップ1/2では式(2)と式(3)を用いて計算します．ステップ2/2では式(5)と式(6)に基づく，計算量の少アルゴリズムを用いて実装する．ステップごとに”動作確認”に成功しなければ，”TAに提出”が出来ないようになっている．以下では，各ステップをさらに細分化して説明する． 

---
## ステップ1/2 「共通部分文字列のマッチング数の計算」
---

---
### 仕様
---

+ 共通部分列のマッチング数を求めるために，動的計画法用の二次元配列テーブル`dp`を,`malloc_2d_`を用いて用意すること．
  + `dp`の大きさは文字列の長さに合わせて必要十分な大きさとすること．
  + `free_2d_`を用いて`dp`の開放を行うこと.

+ 共通部分列のマッチング数を求める関数`common_subseq`を作成すること．
  + 関数`common_subseq`は，文字列 $X$ ，文字列 $X$ の長さ $m$ ，文字列 $Y$ ，文字列 $Y$ の長さ $n$ ，動的計画法用の二次元配列テーブル`dp`を引数にとる．
    ```
    int common_subseq(char* X, int m, char* Y, int n, int** dp);
    ```
  + 関数`common_subseq`の戻り値は文字列 $X$ と文字列 $Y$ のマッチング数とする．
  + `common_subseq`関数は**式(2)，式(3)と式(7)**に基づいて作成すること. (注意：`sumdp`は使わない)

+ 表示

  + 一行目に文字列 $X$ とその長さ $m$ を、二行目に文字列 $Y$ とその長さ $n$ を表示すること.  
  + 三行目から,動的計画法用の二次元配列テーブル`dp`の計算結果を実行例に従って表示すること．
    + 関数`show_table`を用いること．
      + 引数は，表示する動的計画法用の二次元配列テーブル $data$ ，その行数 $M$ および 列数 $N$ の3種.
      ```
      void show_table(int M, int N, int** data);
      ```
    + 全ての整数は三桁分の表示スペースを確保する．つまり，表示対象が二桁の場合は三桁目に空白を,表示対象が一桁の場合は二桁目と三桁目に空白を入れること．

  + 最後の行に共通部分文字列のマッチング数を出力すること．
  + 実行例(1)の場合
    ```
    eat⊔3↩︎
    ate⊔3↩︎
    ###⊔dp↩︎
    #⊔⊔⊔0⊔⊔⊔0⊔⊔⊔0⊔⊔⊔0↩︎
    #⊔⊔⊔0⊔⊔⊔0⊔⊔⊔0⊔⊔⊔1↩︎
    #⊔⊔⊔0⊔⊔⊔1⊔⊔⊔0⊔⊔⊔0↩︎
    #⊔⊔⊔0⊔⊔⊔0⊔⊔⊔2⊔⊔⊔0↩︎
    4↩︎
    ```

+ 問題3-1に提示してある関数を`ppa_extra_h/p3_header.h`というファイルにおいてある．`#include "ppa_extra_h/p3_header.h"`という宣言を通して含め、以下の関数を必要に応じて用いること．
  + `vmax_`
  + `vmax3_`
  + `vmin_`
  + `vmin3_`
  + `zeros_`
  + `malloc_string_`
  + `read_string_`
  + `malloc_2d_`
  + `free_2d_`
  

+ 以下のプログラムを必ず用いてプログラムを完成せること．
  + `???` の部分は適宜補完すること
  + 適切なコメントを入れること
  

```
#include <stdio.h>
#include <stdlib.h>

#include "ppa_extra_h/p3_header.h"

void show_table(int M, int N, int** data);    
int common_subseq(char* X, int m, char* Y, int n, int** dp);    

int main() {
  int len_x, len_y ;                        
  scanf(“%d”, &len_x);                      
  scanf(“%d”, &len_y);                       
  char* data_x = malloc_string_(len_x);
  char* data_y = malloc_string_(len_y);
  read_string_(data_x, len_x);
  read_string_(data_y, len_y);
  int** dp = malloc_2d_(???, ???);  

  ...(省略)...

  free_2d_(dp, ???);      
  free(data_x);               
  free(data_y);               
  return 0;
}

void show_table(int M, int N, int** data){

  ...(省略)...

}


int common_subseq(char* X, int m, char* Y, int n, int** dp){
  //式(7)よりdpの初期化
  ...(省略)...
  
  for (int i=1; i<m+1; i++) {
    for (int j=1; j<n+1; j++) {   
      //dp[i][j]とマッチング数の計算
      ...(省略)...
    }
  }
  ...(省略)...
}
```

---
## 実行例
---
---
### 例(1)
---

+ 入力データ
```
3 3 eat ate
```

+ 出力例
```
eat 3
ate 3
### dp
#   0   0   0   0
#   0   0   0   1
#   0   1   0   0
#   0   0   2   0
4
```

---
### 例2
---

+ 入力データ
```
8 9 abababab abcabcabc
```

+ 出力例
```
abababab 8
abcabcabc 9
### dp
#   0   0   0   0   0   0   0   0   0   0
#   0   1   0   0   1   0   0   1   0   0
#   0   0   2   0   0   3   0   0   4   0
#   0   1   0   0   4   0   0   8   0   0
#   0   0   3   0   0  10   0   0  22   0
#   0   1   0   0   8   0   0  26   0   0
#   0   0   4   0   0  22   0   0  70   0
#   0   1   0   0  13   0   0  61   0   0
#   0   0   5   0   0  40   0   0 171   0
482
```

---
## ステップ2/2 「sumdp配列を利用し計算量を削減する方法を用い共通部分文字列のマッチング数の計算」
---

+ ステップ1/2の`common_subseq`関数を削除あるいはコメントアウトする．

+ 共通部分列のマッチング数を求めるために，動的計画法用の二次元配列テーブル`dp`, `sumdp`の二種類を,`malloc_2d_`を用いて用意すること．
  + `dp`, `sumdp`の大きさは文字列の長さに合わせて必要十分な大きさとすること．
  + + `free_2d_`を用いて`dp`, `sumdp`の開放を行うこと.

+ `main`関数の最後では，動的に確保した二次元配列を`free_2d_`を用いてメモリの開放を行うこと.

+ 共通部分列のマッチング数を求める関数`ssk`を作成すること．
  + 関数`ssk`は，文字列 $X$ ，文字列 $X$ の長さ $m$ ，文字列 $Y$ ，文字列 $Y$ の長さ $n$ ，動的計画法用の二次元配列テーブル`dp`, `sumdp`の6つを引数にとる．
    ```
    int ssk(char* X, int m, char* Y, int n, int** dp, int** sumdp);
    ```
  + 関数`ssk`の戻り値は文字列 $X$ と文字列 $Y$ のマッチング数とする．
  + `ssk`関数の作成の際に**式(5)，式(6)と式(7)**を参考にすること．（つまり，`dp`の計算に必ず`sumdp`を利用すること）
    + `dp`<font color="red">の計算にステップ1/2の方法( 式(2),式(3) )を使わないこと．</font>
    + `sumdp`を式(4)の様に計算しないこと．

+ 表示

  + 一行目に文字列 $X$ とその長さ $m$ を、二行目に文字列 $Y$ とその長さ $n$ を表示すること.  
  + 三行目から,動的計画法用の二次元配列テーブル`dp`, `sumdp`の計算結果を実行例に従って表示すること．
    + 関数`show_table`を用いること．
      + 引数は，表示する動的計画法用の二次元配列テーブル $data$ ，その行数 $M$ および 列数 $N$ の3種.
      ```
      void show_table(int M, int N, int** data);
      ```
    + 全ての整数は三桁分の表示スペースを確保する．つまり，表示対象が二桁の場合は三桁目に空白を,表示対象が一桁の場合は二桁目と三桁目に空白を入れること．

  + 最後の行に共通部分文字列のマッチング数を出力すること．
  + 実行例(1)の場合
    ```
    eat⊔3↩︎
    ate⊔3↩︎
    ###⊔dp↩︎
    #⊔⊔⊔0⊔⊔⊔0⊔⊔⊔0⊔⊔⊔0↩︎
    #⊔⊔⊔0⊔⊔⊔0⊔⊔⊔0⊔⊔⊔1↩︎
    #⊔⊔⊔0⊔⊔⊔1⊔⊔⊔0⊔⊔⊔0↩︎
    #⊔⊔⊔0⊔⊔⊔0⊔⊔⊔2⊔⊔⊔0↩︎
    ###⊔sumdp↩︎
    #⊔⊔⊔0⊔⊔⊔0⊔⊔⊔0⊔⊔⊔0↩︎
    #⊔⊔⊔0⊔⊔⊔0⊔⊔⊔0⊔⊔⊔1↩︎
    #⊔⊔⊔0⊔⊔⊔1⊔⊔⊔1⊔⊔⊔2↩︎
    #⊔⊔⊔0⊔⊔⊔1⊔⊔⊔3⊔⊔⊔4↩︎
    4↩︎
    ```

+ 問題3-1に提示してある関数を`ppa_extra_h/p3_header.h`というファイルにおいてある．`#include "ppa_extra_h/p3_header.h"`という宣言を通して含め、以下の関数を必要に応じて用いること．
  + `vmax_`
  + `vmax3_`
  + `vmin_`
  + `vmin3_`
  + `zeros_`
  + `malloc_string_`
  + `read_string_`
  + `malloc_2d_`
  + `free_2d_`



+ 以下のプログラムを必ず用いてプログラムを完成せること．
  + `???` の部分は適宜補完すること
  + 適切なコメントを入れること



```
#include <stdio.h>
#include <stdlib.h>

#include "ppa_extra_h/p3_header.h"

void show_table(int M, int N, int** data);    
int ssk(char* X, int M, char* Y, int N, int** dp, int** sumdp);    

int main() {
  int len_x, len_y ;                        
  scanf(“%d”, &len_x);                      
  scanf(“%d”, &len_y);                         
  char* data_x = malloc_string_(len_x);
  char* data_y = malloc_string_(len_y);
  read_string_(data_x, len_x);
  read_string_(data_y, len_y);
  int** dp = malloc_2d_(???, ???); 
  int** sumdp = malloc_2d_(???, ???);

  ...(省略)...

  free_2d_(dp, ???); 
  free_2d_(sumdp, ???); 
  free(data_x);               
  free(data_y);               
  return 0;
}

void show_table(int M, int N, int** data){

  ...(省略)...

}


int ssk(char* X, int M, char* Y, int N, int** dp, int** sumdp){
  
  ...(省略)...
  
}
```

---
## 実行例
---
---
### 例(1)
---

+ 入力データ
```
3 3 eat ate
```

+ 出力例
```
eat 3
ate 3
### dp
#   0   0   0   0
#   0   0   0   1
#   0   1   0   0
#   0   0   2   0
### sumdp
#   0   0   0   0
#   0   0   0   1
#   0   1   1   2
#   0   1   3   4
4
```

---
### 例2
---

+ 入力データ
```
8 9 abababab abcabcabc
```

+ 出力例
```
abababab 8
abcabcabc 9
### dp
#   0   0   0   0   0   0   0   0   0   0
#   0   1   0   0   1   0   0   1   0   0
#   0   0   2   0   0   3   0   0   4   0
#   0   1   0   0   4   0   0   8   0   0
#   0   0   3   0   0  10   0   0  22   0
#   0   1   0   0   8   0   0  26   0   0
#   0   0   4   0   0  22   0   0  70   0
#   0   1   0   0  13   0   0  61   0   0
#   0   0   5   0   0  40   0   0 171   0
### sumdp
#   0   0   0   0   0   0   0   0   0   0
#   0   1   1   1   2   2   2   3   3   3
#   0   1   3   3   4   7   7   8  12  12
#   0   2   4   4   9  12  12  21  25  25
#   0   2   7   7  12  25  25  34  60  60
#   0   3   8   8  21  34  34  69  95  95
#   0   3  12  12  25  60  60  95 191 191
#   0   4  13  13  39  74  74 170 266 266
#   0   4  18  18  44 119 119 215 482 482
482
```
