---
layout: page
title: 3-1. 課題３導入問題【初歩】
---

この問題では，以降の問題で使用する文字配列，整数の二次元配列，整数の最大／最小に関する関数群の一部を実装してもらう．

---
## <font color="red">！！重要！！　課題全体を通しての仕様</font>
---

課題を通してのデフォルトの仕様を以下に説明する．ただし，各問題で追加の仕様や注意書きがある場合はそちらを優先すること．

- グローバル変数や静的変数を使用してはいけない．
- `include`するファイルは`<stdio.h>`および`<stdlib.h>`のみとする．
- プログラム全体の構成を以下に従うようにする．
  - `main`関数の正常終了時の戻り値を0にする．
  - 関数は前方宣言を用い，関数本体は`main`関数の下に記述（定義）する．
 
    ```
    #include <stdio.h>
    #include <stdlib.h>

    ... 関数の前方宣言 ...

    int main(){

      ...（main関数本体）...

      return 0;
    }

      ... 関数の定義 ...
    ```

- 入力データの読み込み
  - 入力データの読み込は`main` 関数内で行うこと．
  + 入力用の文字列$X$や$Y$とその要素数は標準入力から与えられる．文字列はスペースを除く可読文字（アルファベット，数字，記号）のみで構成されていると仮定してよい．
  + 各文字列はスペースや改行で区切られる．

- 事前に定義されている関数(基本的に関数名の最後に`_`がついているもの)の中身を書き換えてはいけない．これらの関数は例えば，`printf`や`scanf`と同様に中身を書き換えられない関数として扱うこと．

- 表示例の`⊔` は半角スペース，`↩︎`は改行を表す．
- 表示(出力)
  - 全ての表示は標準出力にすること．ただし，標準エラー出力への表示が必要な場合は各課題の仕様に記載する．
  - 全ての出力には改行文字 `\n` を付けること．特に最後の行の改行の有無に注意すること．
  - 各要素の間には空白文字を一つ入れる．
  - 改行前の空白文字などの表示されない文字を出力しないこと．

---
## 問題
---
以下に説明する関数群を実装し，それらの動作確認を行なうプログラムを書け．

---
### 整数引数の大小を判定する関数群とその仕様
---

+ 2つの値のうち大きい／小さい値を取得する関数`vmax_`／`vmin_`を，"三項演算子"を用いて実装すること：

  ```
  int vmax_(int a, int b){
    return a>b ? a:b;
  }

  int vmin_(int a, int b){
    ...
  }
  ```

  `vmax_(2, 3)` なら戻り値は`3`，`vmin_(1, 3)` なら戻り値は`1`．三項演算子については，[こちら](#ternary_operator)を参照のこと．
+ 3つの値のうち最も大きい／小さい値を取得する関数`vmax3_`／`vmin3_`を，`vmax_`／`vmin_`のみを用いて実装すること：
  
  ``` 
  int vmax3_(int a, int b，int c){
    vmax_(vmax_(a, b), c);
  }
  
  int vmin3_(int a, int b，int c){
    ...
  }
  ```
    
  `vmax3_(3, 2 ,1)` なら戻り値は`3`，`vmin3_(2, 1, 3)` なら戻り値は`1`．

---
### 文字配列処理の関数群とその仕様
---
+ 文字配列専用でメモリ確保する関数`malloc_string_`を以下のコードを参考にして実装すること：

  ```
  char* malloc_string_(int N){
    char* str  = (???)malloc(???);  // 配列に動的メモリを割り当てる
  
    if (str == NULL) {       // メモリ確保に失敗した際のエラー処理
      fprintf(stderr, “malloc_string_(): Cannot allocate memory.\n”);
      exit(1);  // メモリ確保に失敗したら、プログラムを強制終了
    }
    
    zeros_(str, N+2);   // 配列dataを関数zeros_で初期化
    return ???;
  }
  ```

  + 引数は文字列の長さNで，エラー処理用の1文字と，末尾のヌル文字分を足してN+2の長さの文字配列を確保すること．
  + 戻り値は，配列の先頭を指すポインタとすること．
  ※動的に確保したメモリ領域は，処理が完了した後に`free`関数で解放すること．
+ 標準入力から決められた長さの文字列を読み込む関数 `read_string_`を，以下のコードを参考にして実装すること：

  ```
  void read_string_(char *str, int N){
    // N+1文字を標準入力から読み込む
    fgets(str, N+2, stdin);
    
    // 文字列の長さがNよりも短い場合はエラー出力して強制終了
    for(int i=0; i<N; i++){
      if(str[i]=='\n' || str[i]==' ' || str[i]=='\0'){
        fprintf(stderr, “read_string_(): Invalid string\n”);
        exit(1);
      }
    }
    
    // 文字列の長さがNよりも長い場合はエラー出力して強制終了
    if( !(str[N]=='\n' || str[N]==' ' || str[N]=='\0') ){
      fprintf(stderr, “read_string_(): Invalid string\n”);
      exit(1);
    }

    // fgetsで改行かスペースも読み込んでいる場合があるので，ヌル文字で上書き
    str[N] = ???;
    
    return str;
  }
  ```
  
  + 引数は文字列の長さ`N`と，あらかじめ動的メモリ確保された文字配列のポインタ`str`で，エラー処理用の1文字と，末尾のヌル文字分を足して`N+2`の長さの文字配列を確保されていると仮定してよい．
  + 戻り値は，読み込んだ文字配列の先頭を指すポインタとすること．
  + `fgets`関数を用いて文字列の読み込みをすること．
  + 文字列の長さが引数Nよりも短い／長い場合はエラー出力して強制終了すること．
+ 文字配列をヌル文字で初期化する関数`zeros_`を，以下のコードを参考に実装すること：

  ```
  void zeros_(char* str,  int N){
    for (int i = 0; i < ???; ++i){
      ???;  // 配列のi番目の要素をヌル文字で初期化
    }
  }
  ```

  + 引数は初期化したい文字列$X$と文字列＄X$の長さ．
  + N+2個の要素を初期化すること．

---
### 二次元配列を動的メモリ確保／解放する関数群とその仕様
---
+ 二次元配列とは，インデックスが二つある配列のことを指し，`a[i][j]`のようにアクセスする配列である．ここでは，数学でいう$M$行$N$列の行列のことを指す．
+ C言語においては，固定長の二次元配列は`int a[3][4]`のように書けるが，２番目のサイズを関数に明示的に指定しなければいけないため，非常に使い勝手が悪い（詳しくは「[固定長二次元配列を関数に渡す際の注意](#2D_array_to_func)」を参照）．
+ 動的メモリ確保によって二次元配列を実現する方法はいくつかあるが，ここではよく使われている方法で実装する（他の実現方法については，「[二次元配列を実現するその他の方法](#2D_array_others)]」を参照）．
+ C言語では二次元配列の動的メモリ確保は直接的にサポートされていないため，$1$行$N$列の一次元配列を$M$行，動的メモリ確保し，さらにそれぞれの先頭アドレスを格納するためのポインタ型の一次元配列（ポインタ配列）を動的メモリ確保する（下の図を参照）．

<img src="p31-2D-array-1.png" width="750px">

+ このようにすると，`a[i][j]`と書いたとき，`a[i]`は`i`行目の配列の先頭アドレスとして解釈され，`a[i][j]`は`i`行目の配列の`j`列目の要素になる．
+ `int`型の二次元配列を動的メモリ確保する関数`malloc_2d_`は，以下のとおり実装することができる：

  ```
  int** malloc_2d_(const int len_x, const int len_y){
    int** array_2d = (int **)malloc(sizeof(int *) * len_x);
    
    if(array_2d == NULL){
      fprintf(stderr, "malloc_2d_(): Cannot allocate memory.\n");
      exit(1);
    }
    
    for(int i = 0; i < len_x; ++i){
      array_2d[i] = (int*)malloc(sizeof(int) * len_y);
      if(array_2d[i] == NULL){
        fprintf(stderr, "malloc_2d_(): Cannot allocate memory.\n");
        exit(1);
      }
    }
    
    return array_2d;
  }
  ```
  
+ この二次元配列を解放する関数`free_2d_`は，以下のとおりである：

  ```
  void free_2d_(int **array_2d, int len_x){
    for(int i = 0; i < len_x; ++i) free(array_2d[i]);
    free(array_2d);
  }
  ```

+ 先にポインタ配列を解放してしまうと`int`型の配列$M$行が解放できなくなってしまうため，解放の順番には注意が必要である．


---
### プログラム全体の仕様
---
+ 上述した課題全体の仕様．
+ 以下のプログラムを必ず用いて完成させること．
  + コードが`???`となっている箇所は，コメント文で書かれた処理を行なうコードを書くこと．
  + 関数群の中身は，上記の仕様に書いてあるコードを参考にしてよい．`???`となっている箇所は自分で考えて書くこと．
  + すでに書いてあるコメント文は書き写さなくてよい．

```
#include <stdio.h>
#include <stdlib.h>


// 関数群の前方宣言

int vmax_(int x, int y);
int vmax3_(int a, int b, int c);
int vmin_(int x, int y);
int vmin3_(int a, int b, int c);

void zeros_(char* str, int N);
char* malloc_string_(int N);
void read_string_(char *str, int N);

int** malloc_2d_(int len_x, int len_y);
void free_2d_(int **array_2d, int len_x);


// 関数群をテストするmain関数

int main(){
  // 最大／最小を判定する関数群のテスト
  int x, y, z;
  
  scanf("%d%d%d", x, y, z);
  printf("%d %d %d\n", vmax_(x, y), vmax_(y, z), vmax_(z, x));
  printf("%d %d %d\n", vmin_(x, y), vmin_(y, z), vmin_(z, x));
  printf("%d\n", vmax3_(x, y, z));
  printf("%d\n", vmin3_(x, y, z));
    
  // 文字配列処理の関数群のテスト
  int len;
  scanf(“%d”, &len); 
  char* str = malloc_string_(len);
  read_string_(str, len);
  ???;  // 動的に確保された配列strの解放

  // 二次元配列の確保／解放の関数群のテスト
  

  return 0;
} 


// 関数群の定義
...

```


---
## 実行例
---

---
### 例（1）
---

+ 入力
```
3 3 eat ate
```

+ 出力
```
eat 3
ate 3
a
e
t
```

---
### 例（2）
---

+ 入力
```
8 7 abababab abababc
```

+ 出力
```
abababab 8
abababc 7
a
b
```


---
## 参考情報
---
---
### 三項演算子<a name="ternary_operator"></a>
---
- 関数`vmax_`等で用いられている`(条件式) ? (真式) : (偽式)`という記法は，三項演算子と呼ばれ，(条件式)が真であれば(真式)を，偽であれば(偽式)を評価して値を返す．例えば`vmax_`は以下と等価である：

  ```
  int vmax_(int x, int y){
   if( x > y ){
     return x;
   }
    else {
      return y;
    }
  }
  ```
 
- 簡単な式であればよいが，カッコ書きや三項演算子を入れ子にするような複雑な式の場合は，if文を使用した方が見やすい：

  ```
  d = (a>b) ? ((b>c) ? c : b) : ((a>c) ? c : a );
  
  if( a > b ){
    if( b > c ) d = c;
    else d = b;
  }
  else {
    if( a > c ) d = c;
    else d = a;
  }
  ```
  
- 「真偽判定の結果に応じて異なる値を代入する」という処理はわりと登場頻度が高いので，C言語では演算子としてサポートされている．（もともと導入された経緯としては，Intelプロセッサなどで提供している"conditional move"などの条件付き命令を積極的に用いるためというのも一つある．）

---
### 固定長二次元配列を関数に渡す際の注意<a name="2D_array_to_func"></a>
---
一次元配列を引数に取る関数を書くとき，`void test(int a[]){ ... }`のように書くことができる．その延長線上で，二次元配列を引数に取る関数も`void test(int a[][]){ ... }`と書きたくなってしまうが，この書き方ではコンパイルエラーが出てしまう．正しい書き方は，`void test(int a[][10]){ ... }`のように列のサイズを明示的に渡さないといけない．その上，この書き方は固定長の二次元配列に限られる．

なぜこのような書き方しか許されないのか？それは，メモリのアドレスが一次元で並んでいることに起因している．C言語の場合，固定長の二次元配列はメモリ上では一次元に以下の図のように並んでおり，$M$行$N$列の場合，`a[i][j]`は先頭から`i*N+j`番目にある．列のサイズ`N`が分からないと`a[i][j]`がどこにあるのか分からないため，`void test(int a[][]){ ... }`のような書き方ではコンパイルエラーが出る，というわけである．

<img src="p31-2D-array-2.png" width="750px">

この書き方は，列のサイズがコンパイル時に決まっているとき限定でしかできず，列のサイズが異なる場合には違う関数を用意する必要がある（`void test5(int a[][5]){ ... }`など）．可変長配列では`void test(int N, int a[][N]){ ... }`のように書きたくなるが，これもやはりコンパイルエラーになる．このように二次元配列をそのまま関数に渡すことはC言語では実用的ではないが，そのまま渡すことができる言語もある（FortranやJavaなど）．

---
### 二次元配列を実現するその他の方法<a name="2D_array_others"></a>
---

上述の二次元配列の実装方法は，「行間で不連続なメモリが割り当てられてしまう可能性がある」「直接的にアドレス取得できない」といった効率上の欠点があり，特に大規模数値計算には向かない．また，メモリ確保と解放をループ処理しないといけないため，煩雑になってしまう．ここでは，より実践的な方法について補足説明する．

1. 一次元配列を二次元的にアクセスする
- $M\times N$の一次元配列を`a = (int *)malloc(sizeof(int)*M*N);`と確保し，`a[i*N+j]`のようにアクセスすれば，メモリ上で連続した"二次元"配列が実現できる（下図参照）．この方法では直接的に変数にアクセスするため，より高速である．また，メモリ確保／解放は一度だけ行えばよい．

  ```
  int *a = (int *)malloc(sizeof(int)*M*N);

  for(int i=0; i<M; i++){
    for(int j=0; j<N; j++){
      a[i*N+j] = ...;
    }
  }

  free(a);
  ```

- ただし，`a[i][j]`という簡便な書き方はできない．

<img src="p31-2D-array-3.png" width="750px">

1. 一次元配列の各行の先頭アドレスを格納するポインタ配列を用意する
- 一番目の方法では`a[i][j]`というアクセスの仕方ができないが，各行の先頭に対応するアドレスを格納するポインタ配列を用意することで可能になる：

  ```
  int *a = (int *)malloc(sizeof(int)*M*N);
  int **p = (int **)malloc(sizeof(int*)*M);
  
  for(int i=0; i<M; i++) p[i] = &a[i*N];
  
  for(int i=0; i<M; i++){
    for(int j=0; j<N; j++){
      p[i][j] = ...;
    }
  }

  free(p);
  free(a);
  ```

  - この方法では間接なアドレス取得によるアクセスにはなってしまうが，「行間で連続なメモリが割り当てられる」ため，簡便性と高速性を両立させた書き方と言える．

<img src="p31-2D-array-4.png" width="750px">
