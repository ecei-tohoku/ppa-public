---
layout: page
title: 1-5. 正規表現【発展】
---

文章の中で，ある語が登場する位置を検索したい．例えば，

    ```
    My favorite color is blue.
    ```

という文章では，`color`という単語は13字目（配列でいうと12番目）から始まる（空白も1文字にカウントしていることに注意）．この探索をプログラムに実装する場合は，文章が入っている文字配列の先頭から順に，探したい語が入っている文字配列と照合していくのが最も簡単なアルゴリズムである（より高速なアルゴリズムは存在するが，この問題では触れない）．このような問題を文字列マッチングと呼ぶ．
一方で，`color`とは綴りが異なる`colour`でも検索に引っかかるようにしたい場合もある：

    ```
    My favorite colour is blue.
    ```

このように，検索したい語に複数パターンを含めたい場合，**正規表現**(**Regular Expression**あるいは**regex**)という特殊な記法を用いることで，`color`と`colour`を“一語”で表現することができる．具体的には，

    ```
    colou?r
    ```
    
という正規表現が，`color`と`colour`の二つを同時に表す．`?`は「直前の文字が0個または1個ある」ことを表す正規表現の一つである．
この問題では，文字列$a$から，正規表現を含む文字列$b$にマッチする全ての文字列を出力するプログラムを作成する．用いる正規表現は，実装が比較的容易なものに限定し，使用条件も一部限定する．より詳細かつ厳密な正規表現の説明は[こちらを参照](https://ja.wikipedia.org/wiki/%E6%AD%A3%E8%A6%8F%E8%A1%A8%E7%8F%BE)のこと．

---
## 正規表現
---
1. `?`は，直前の文字0個または1個にマッチする．例は上に述べたとおり．

2. `.`は，任意の文字1個にマッチする．例えば，文字列`abcdef`の中では`c.e`は`cde`にマッチングする．また，連続での使用`c..f`や先頭文字への使用`.b`も許されていることに注意が必要である．

3. `^`は，文字列の先頭のみマッチングすることを指定する．例えば，`abcdef`の中では`^bc`としてもマッチングはしない．`^ab`とすると、先頭の`ab`がマッチングする．

4. `$`は，文字列の末尾のみマッチングすることを指定する．例えば，`defdef`の中では`def$`は4文字目の`def`にしかマッチングしない．実装上で注意するべき点は，`def?$`のような正規表現も許されるということである．この場合には末尾が`de`あるいは`def`で終わっていればマッチングする．

5.`“[…]`は，カッコ内に書かれた複数文字の中から１個にマッチングする．例えば，`GooglegoogleHooglehoogle`の中では`[Ggh]oogle`は1文字目の`Google`，7文字目の`google`，20文字目の`hoogle`にマッチングする．

---
## 入力の仕様
---

    ```
    m
    sentence
    n
    matching_expression
    ```
    
`m`は`1`以上、`1000`以下。`n`は`1`以上、`32`以下。正規表現の“文法エラー”はないと仮定してよい．`sentence`はアルファベットのみ．`matching_expression`はアルファベット，正規表現用の記号のみ．正規表現については，`^`と`$`は同時には出てこない，`?`の前には必ずアルファベットのみとする．

---
## 出力の仕様
---

    ```
    インデックス1 マッチングした文字列1
    インデックス2 マッチングした文字列2
    ```

一つもマッチングしなかった場合は“No matching found.”と出力すること．改行．

ヒント１
テストケースは機能1~5を順に実装していけば，単体のテスト，前の機能との組み合わせのテストが順にできるようになっている．
ヒント２
機能２の実装では，特に?との組み合わせの場合に複雑な処理が必要になる恐れがあるので，マッチングの処理時間を気にして末尾だけマッチングを確かめるようなコードを書く必要はない．
