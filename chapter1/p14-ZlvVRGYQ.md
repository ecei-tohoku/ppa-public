---
layout: page
title: 1-4. Luhnアルゴリズム【基本】
---

クレジットカード番号に誤りがないか確認するため，[Luhnアルゴリズム](https://ja.wikipedia.org/wiki/Luhn%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0)が用いられている．このアルゴリズムは，入力された番号が「正しい」か「間違っている」かを，以下の手順で求める．

1. 右端から数えて偶数番目の数字をすべて2倍する
2. 1.の計算の後，すべての数字の総和を求める．ただし，1.の処理で数字が2桁になった場合は，1桁目と2桁目の数字を足す．
3. 求めた総和の1の位が0であれば「正しい」，そうでなければ「間違っている」と判定する

例えば，49927398716という番号が入力されたとき，

<div align="left">
<img src="p14-luhn.png" width="600px">
</div>

これより$70$が求まり，1の位が0であるため，このカード番号は「正しい」と判定される．

---
## 問題
---
標準入力よりカード番号を読み取り，
Luhnアルゴリズムで正当性を検証し，正しければ`true`，間違っていれば`false`と標準出力に書き出すプログラムを作成せよ．

ただし，プログラムは以下の仕様を満たすこと．

1. 入力は必ず1文字以上あると仮定してよい．
1. 入力される整数$x$が$1$桁以上$60$桁以下の場合は受理し，それ以外の入力の場合は，`Too long!`と表示して終了する．
1. 入力される整数$x$が$0$より小さい値の場合や，$0$から$9$までの10文字以外の文字が代入された場合は，`Not a number!`と表示して終了する．
1. 各表示は標準出力に出力し，それぞれ末尾には改行文字`\n`を付けること．
1. `#include` していいのは `<stdio.h>`のみとする．
1. 入力を保持する配列の大きさは，必要かつ最小の文字数分を確保すること．
1. scanfを使わないこと（理由は下記1-2.に書いてある）．
1. <font color="red">プログラムの要約や意図を記述するコメントを書くこと．</font>書き方については第２回演習の説明資料を参照のこと．

---
## 文字と文字列
---
- これまでの問題では，`scanf("%d", &xxx);`のように整数値を読み込んでいた．
- しかし，仕様に「標準入力より60桁までのカード番号を読み取り，．．．」とあり，[C言語では扱えないほど大きい整数](#int_size)も入力されてくる可能性がある．
- この問題では，カード番号を（数字を表す）文字の配列，すなわち文字列として読み込む．

### 文字型`char`

- C言語で文字を扱うためには`char`型を用いる．`char`型は, **ASCII** （American Standard Code for Information Interchange; アスキーと読む）と呼ばれる，英数字やキーボードに打刻されている記号類などを整数に対応させるコードを用いて，文字を表現する．
  - たとえば`'a'`は`97`で表される．
  - 数字文字`'1'`（アスキーコードで`1`に対応），記号文字`'/'`（`47`），空白文字`' '`（`32`）などもアスキーコードに含まれる．
  - 特殊文字として，これまで`printf`文で使ってきた改行`'\n'`（`10`）なども含まれる．
  - さらに”文字列の終わりを表す文字”として”ヌル文字”`\0`（`0`）がある．詳しくは後述する．
  - 対応表は **ASCIIコード**，**文字コード** などの用語で検索して各自調べること．
  - より深く知りたい人へ：日本語ではASCIIの範囲外の文字（ひらがな，漢字など）を多く用いるため，日本語文を計算機に取り扱わせる際はASCIIよりも表現力の高い文字コードが必要となる（Shift JIS，UTF-8など）．
- `char`型変数の入出力は以下のようにできる：
  ```
  char c;
 
  scanf("%c", &c);
  printf("%c\n", c);
  ```

- コード内で`char`型に値を代入する場合，数字のように直接文字を表すには，シングルクォーテーション`'`で文字を囲えばよい：
  ```
  c = '3';
  
  if( c == 'a' ) ...;
  ```

- `char`型としての数字`'3'`と`int`型としての`3`は，計算機の中では別のものとして扱われていることに注意．文字の`'3'`を数字の`3`にするためには，`'3' - '0'`のように**`'0'`を引けば良い**：
   ```
   ...
   int v = c - '0';
    ```

- 理由をASCIIコード表を見ながら考えてみよう．`char`型は計算機の内部では`int`として扱われることと，ASCIIコード表では`'0'`から`'9'`までが順番に並んでいることがミソである．仕様にある「$0$から$9$までの数字以外の文字が入力される場合」の判定も，このことを上手く利用する．


### 文字列（文字配列）

- C言語には文字列を格納するための型が **無い**．代わりに文字（`char`型）の **配列** として文字列を表現する．
- 文字配列の定義の仕方：
   ```
   char str[100] = "I am fine.\n";
   ```
   
- これまでどおり`scanf`を使った文字配列の読み込みは可能だが，セキュリティの観点から非推奨である（詳細は[こちら](#scanf)）．この問題では，`fgets`関数を用いて，文字配列の変数に値を読み込む方法を採用する：
    ```
    char str[100]; // ここでは適当に1000要素の配列を確保している．
    ...
    fgets(str, N, stdin);
    ...
    ```

- `fgets`は，一行から`N`個未満の文字を読み込み，配列strに格納する関数である（`stdin`で，標準入力から読むことを指定している）．一行に`N`個以上の文字がある場合、先頭から`N-1`個の文字が読み込まれる．一行に`N`個未満しか文字がない場合は，それらの文字全てが格納される．
- 文字列の末尾には，特殊な文字コードである`\0`（ヌル文字）が挿入されている（`\0`については1-3.を参照）．
- `scanf`と異なり，改行を表す文字コード`\n`も文字として読み込まれることに注意．例えば`abc\n`が入力されると，`str`には`abc\n\0`が格納される．
- 仕様「入力を保持する配列の大きさは，必要かつ最小の文字数分を確保すること」を満たすには，適当な大きさ（1000）ではなく，適切な大きさが何なのか考えないといけない．

---
## ステップに分けてプログラミング
---

処理を細分化し，ステップごとにテストして進めていくのがプログラミングの鉄則である．  
この問題では，「標準入力の読み込みと入力テストの実装」「Luhnアルゴリズムの実装」の2ステップに分けてプログラミングしてもらう．ステップごとに"動作確認"に成功しなければ，"TAに提出"が出来ないようになっている．以下では，各ステップをさらに細分化して説明する．

**ステップ1/2**  
1-1. 準備  
1-2. 標準入力から整数$x$を，文字列として読み込む  
1-3. 入力された数字を各桁ごとに処理  
1-4. 正しい入力かテスト

**ステップ2/2**  
2-1. ステップ1/2のテスト用コードをコメントアウト
2-2. 各桁の値の総和を計算（右から数えて偶数の桁は値を2倍，さらに数字が2桁になった場合は，1桁目と2桁目の数字を足す）．
2-3. カード番号の正当性を検証

---
### ステップ1/2
---
#### 1-1. 準備

- これまでの問題と同様に，まず，確実に必要と思われるC言語のメインの構造を作ってみる．


#### 1-2. 標準入力から整数$x$を，文字列として読み込む

- これまでの問題では，`scanf("%d", &xxx);`のように整数値を読み込んでいた．

- しかし，仕様に「標準入力より60桁までのカード番号を読み取り，．．．」とあり，[C言語では扱えないほど大きい整数](#int_size)も入力されてくる可能性がある．

- この問題では，カード番号を（数字を表す）文字の配列，すなわち文字列として読み込む．


#### 1-3. 入力された数字を各桁ごとに処理

- 1-2.の入力読み込み後は，各桁ごとに繰り返し処理を行う．そのために，入力された整数の桁数（ここでは文字数）を計算する方法を考える必要がある．

- 通常，文字列の末尾には特殊な文字コードである`\0`（ヌル文字）が挿入されており，末尾であることが判別できるようになっている．例えば，`abc`を読み込んだ場合に，実際のメモリ上には`abc\0`の4文字分(`\0`で一文字という計算)が記録されている．よって，`\0`の場所がわかれば桁数（文字列長）がわかる．コード例：

    ```
    for(i=0;i<N;++i){
      if(str[i] == '\0'){
        break;
      }
    }
    ...
    ```


#### 1-4. 正しい入力かテスト

- 60桁より桁数が多い場合をどう判別すればよいか？fgetsでちょうど60桁読むだけでは判別ができない．簡単な例として以下のコードを実行し，4桁より桁数が多いかを判別できるか，入力を$123$，$1234$，$12345$と変えていって確かめてみよう．その次に，`N = 5;`を`N = 6;`に変えると何が起こるか，確かめてみよう．そうすることで，何桁読み込めばよいか，何文字分の文字配列を確保するべきかが分かるはずである．

    ```
    #include <stdio.h>

    int main(){
    int i, N = 5;
    char str[1000]; // 例として適当に大きい配列を確保しているが，本当は✕
      
    fgets(str, N, stdin); // (N-1)文字分かそれ以下を読み込む
    
    for(i=0; str[i]!='\0'; i++){
      if( str[i] == '\n' ) printf("%d \\n\n", i+1);
      else printf("%d %c\n", i+1, str[i]);
    }
    
    return 0;
    }
    ```
- 正常に動作しているか確認するために，仕様1~2のエラー処理を行うこと．入力が正常だった場合，入力数値を一桁ごとに空白文字一つで区切って出力させ，改行すること．末尾には空白を出力しないように注意！

---
### ステップ1/2の実行例

`#`は標準入力，`>`は標準出力を表す．

```
# 49927398716
> 4 9 9 2 7 3 9 8 7 1 6
```

```
# a49927398714
> Not a number!
```

```
# 1234567890123456789012345678901234567890123456789012345678901234567890
> Too long!
```

---
### ステップ2/2
---
#### 2-1. ステップ1/2のテスト用コードをコメントアウト

- テスト用に標準出力させていたコードは，削除せずにコメントアウトしておく．仕様が変更されてもう一度テストしなくてはいけない場合のため．


#### 2-2. 各桁の値の総和を計算（右から数えて偶数の桁は値を2倍，さらに数字が2桁になった場合は，1桁目と2桁目の数字を足す）

- 右から数えるので，`for` 文の回し方を考える必要がある．というのも，例えば配列の先頭`str[0]`から値をみた場合は，「右から」ではなく「左から」になるため，判定の仕方を考える必要がある．


#### 2-3. カード番号の正当性を検証

- `true`か`false`を判定して，標準出力．


---
### ステップ2/2の実行例

`#`は標準入力，`>`は標準出力を表す．

```
# 49927398716
> true
```

```
# 49927398714
> false
```

```
# 1982049058395830128494
> true
```



---
## 参考情報
---

### <a name="int_size"></a>整数型の値の範囲
---
- 計算機は，無限の数値を記憶できるわけではなく，物理的な記憶メモリに収まる大きさの数値しか表現できない．C言語では，32 (or 64) bitのint型では$-2^{31}<=x<=2^{31}-1$ (or $-2^{63}<=x<=2^{63}-1$)，32 (or 64) bitのunsigned int型では$0<=x<=2^{32}-1$ (or $0<=x<=2^{64}-1$)の範囲の整数しか表現できない．10進法では，$2^{32}$は9桁，$2^{64}$は20桁である．

---
### <a name="scanf"></a>scanfを使った文字列の読み込み
---
- これまでどおり，`scanf`を使って文字列型の変数（文字の配列を指す変数）に値を読み込むコードは以下のようになる：
```
char str[100];
scanf("%s", str); // %sは文字列入力用の変換指定子．strはポインタなので，&strとしてはいけない．
...
```
  - （より深く知りたい人へ）`int x[10]`のように配列変数`x`を宣言し，`x`を関数に渡すと，関数には配列`x`の最初の要素へのポインタ，すなわち`&x[0]`が渡される（`int*`型の値が渡る）．つまり，上で`str`という名前で`scanf`に渡っているものはポインタ（`char*`型）である．

- ただしこのやり方では，読み込む文字列長が配列のサイズを超える場合は，エラーの原因になる（いわゆる”バッファオーバーフロー”と呼ばれるセキュリティホールである）．

- 想定されるより十分大きいサイズの配列（100万など）を確保する応急措置も考えられるが，本質的な解決ではない．また，本問題の仕様で「入力を保持する配列の大きさは，必要かつ最小の文字数分を確保する」としているため，その方法では仕様を満たすことはできない．
