---
layout: page
title: 2-3. デバッグ問題【基本】
---

プログラムの中に発生するエラー（バグ）は以下の４種類に分類できる．
- 構文エラー
- リンカーエラー
- ランタイムエラー
- 論理エラー
これらのエラーを直すことはデバッグである．
この中でリンカーエラーとは複数のバイナリをリンクするときのエラーであり、プログラミング演習Aのスコープから対象外である．
その他のエラーについて以下の表により説明する．


|  エラーの種類     |  エラーの説明            |  エラーの発見方法                                    |
| --------------  | ---------------------  | ------------------------------------------------  |
|  構文エラー       |  言語の構文や規則に違反   | コンパイルが失敗することで発見                          | 
|  ランタイムエラー  |  実行の失敗に関するエラー  | プログラムの強制終了，または異常な動作により実行時に発見    |
|  論理エラー       |  期待と異なる出力        |  テストパターンを入れ，期待と異なる動作を確認することで発見  |

<br> 
<span style="color:red">この問題全体では、すでに書かれている初期コードが自動採点システムの中のエディタ上に表示されるようになっている．
自分で仕様に書かれているコードを手入力するのではなく、自動採点システムの中の初期コードから問題を解くことに注意せよ．
また、修正の途中で初期コードに戻りたい場合は”初期コードのロード”ボタンを押す．</span>
初期コードの一番上に以下のような文章が表示され、エラーを含む初期コードであることを表す．
```
//////////////////////////////////////////////////////
//  東北大学　プログラミング演習A           
//  問題 p23a 用のエラーを含む初期コードです。         
//  この初期コードを修正し問題を解いてください．  
//////////////////////////////////////////////////////
```


---
## 問題 (a)
---

この問題は構文エラーのデバッグについての演習問題である．サンプルプログラムの中では，標準入力から受け取る8個の数値に関して処理を行う．
数値が4より小さい場合、４に等しい場合、５と8の間にある場合、それ以外の場合のいずれかに分類し、その分類結果を出力する．


---
## 仕様
---

- 以下は構文エラーが含む初期コードであり、このままコンパイルするとコンパイルが失敗する．
  ```
  #include <stdio.h>

  int main() {
    int b[8];
    int i;

    for(i=0; i<8: i++) {                    //8個の数字を標準入力から受け取る
      scanf("%d", &b[i]);
    }

    for(i=0; i<8; i++) {
      if(b[i] < 4) {                        //??
        printf("Value[%d] < 4\n", i)
      }
      else if(b[i] == 4) {                  //??
        printf("Value[%d] == 4\n", i);
      }
        else if(b[i] < 8) {                 //??  
          printf("5 <= Value[%d] < 8\n", i);
        }
        else {                              //??
          printf("Value[%d] >= 8\n", i);
        }
      }
    }

    return 0
  }
  ```
- プログラムの正しい動作は以下に示す．ここで”$”は0から７の数字のいずれかである．
  - 値が4より小さい場合は以下のように出力される
  ```
  Value[$] < 4
  ```
  - ４に等しい場合は以下のように出力される
  ```
  Value[$] == 4
  ```
  - ５と8の間にある場合は以下のように出力される
  ```
  5 <= Value[$] < 8
  ```
  - 8以上の場合は以下のように出力される
  ```
  Value[$] >= 8
  ```
  

---
## 手順
---

以下はこの問題限ることではなく一般的なデバッグ方法の一部である．

1 まずはコードのインデントを揃うように書き直す．この段階でも間違いが見つかる可能性がある．
2 コンパイルし、エラーの出る行番号を確認する．
3 一番上のエラーから直していく．
4 実際のエラーはコンパイル結果の行ではなく，その前の行にある場合もあるので注意が必要．
5 一つの間違いにより複数の箇所にエラー表示が出る場合もある．このような混乱を防ぐためエラーを直すたびにコンパイルし，その結果を見て次のデバッグを行うほうが良い．


---
## 実行例
---

---
### 実行例(1)
---
- 入力データ
```
9 8 0 2 5 12 5 1
```
- 出力例
```
Value[0] >= 8
Value[1] >= 8
Value[2] < 4
Value[3] < 4
5 <= Value[4] < 8
Value[5] >= 8
5 <= Value[6] < 8
Value[7] < 4
```

---
## 問題 (b)
---

この問題では当選番号VLA（可変長配列）の範囲外アクセスによるランタイムエラーのデバッグを行う．

宝くじの表面には以下の図に示すように，当選番号，２次元バーコードとバーコード関連の数字が書かれている．
<p align="center">
  <img src="prob2-2-1.jpg" width="400">
  <figcaption align = "center"><b>図１ - ユークリッドの互除法アルゴリズムのフローチャート</b></figcaption>
</p>．
当選番号のチェックのため以下の順番にシステムに入力する
1. 入力者の歳
2. 当選番号の数
3. 当選番号
4. バーコードの１２桁の数字


---
## 仕様
---

サンプルプログラムの中では，１等賞の番号で配列が初期化されている．
入力される当選番号を保存するため可変長配列を用意する．色々な宝くじに対応するように可変長配列が使われており，入力される当選番号の数に合わせて配列の長さが実行時に設定される．
また，バーコード番号を保存するためにも長さ12の配列を用意する．

入力に対してシステムが以下の処理をする
- 入力者の年が10歳以下の場合以下のように出力され，プログラムが終了される．
  ```
   You are not eligible↩︎
  ```
- 当選番号の数が５の場合１等の番号と入力された番号を比較する．また，バーコード番号も標準入力から受け取る．その後以下のように出力される．
  ```
   ===  Enshu Loto Jumbo 2023  ===↩︎  	
   Winning numbers :	10 23 44 45 21↩︎
   -----------------------------------↩︎
   Your barcode    :  12-34-56-8-6-10-0-45-3-23-91-1↩︎
  ```
  一致した場合は以下のように表示される．
  ```
   You won 1,000,000,000↩︎
  ```
  一致しない場合は以下のように表示される．
  ```
   You lose↩︎
  ```
- 当選番号の数が５でない場合は以下のように表示され，終了される．
  ```
   Ticket not found↩︎
  ```
  
  
---
## 手順
---

- 以下のサンプルコードをコピーする．このコードでは構文エラーは含まれていない．コンパイルエラーの場合は正しくコピーされているのかをチェックする．
  ```
  #include <stdio.h>

  int main() {
    int N, M;
    scanf("%d%d", &M, &N);                                    //年齢と番号の数を標準入力から受け取る

    int yourNumber[N];                                        //??
    int winningNumber[5] = {10,23,44,45,21};                  //１等賞の番号を記憶するための配列
    int barcode[12];                                          //??
    int minAge = 10;                                          //??

    for(int i=0; i<M; i++) {                                  //??
      scanf("%d", &yourNumber[i]);
    }

    if(M < minAge) {                                          //??
      printf("You are not eligible\n");
    }
    else if(N == 5) {                           
      int match = 1;
      for(int i=0; i<5; i++) {                                //??
        if(yourNumber[i] != winningNumber[i]) {
          match = 0;
          break;
        }
      }

      for(int i=0; i<12; i++) scanf("%d", &barcode[i]);       //??

      printf("=== Enshu Loto Jumbo 2023 ===\n");
      printf("Winning numbers : ");
      for(int i=0; i<5; i++) printf("%d ", winningNumber[i]); //??
      printf("\n");
      printf("-----------------------------\n");

      printf("Your barcode : ");
      for(int i=0; i<10; i++) printf("%d-", barcode[i]);      //??
      printf("%d\n", barcode[11]);

      if(match == 0) {                                        //??
        printf("You won 1,000,000,000\n");
      }
      else {                                                  //??
        printf("You lose\n");
      }
    }
    else {                                                    //??
      printf("Ticket not found\n");
    }   

    return 0;
  }
   ```
   
- コンパイルして以下のテストケースに対して正しく動くのかを確認する．
- 動かない場合はデバッグする．
- デバッグする際に配列外にアクセスされているのかを確認する．そのため配列のインデックスをプリントしてみることができる．
- 動作確認とおらに場合はさらにデバッグを行う

---
## 実行例
---

---
### 実行例(1)
---
- 入力データ
```
17 5 6 76 55 45 33 8 89 9 5 19 49 17 6 76 55 45 33
```
- 出力例
```
=== Enshu Loto Jumbo 2023 ===
Winning numbers : 10 23 44 45 21 
-----------------------------
Your barcode : 8-89-9-5-19-49-17-6-76-55-45-33
You lose
```

---
### 実行例(2)
---
- 入力データ
```
42 5 10 23 44 45 21 12 3 88 9 9 51 45 78 7 61 87 56
```
- 出力例
```
=== Enshu Loto Jumbo 2023 ===
Winning numbers : 10 23 44 45 21 
-----------------------------
Your barcode : 12-3-88-9-9-51-45-78-7-61-87-56
You won 1,000,000,000
```


---
### 実行例(3)
---
- 入力データ
```
9 5 45 67 34 12 98 98 4 56 78 3 49 34 3 29 54 37 28 11
```
- 出力例
```
You are not eligible
```

---
## 問題 (c)
---

この問題の目的はアクセス不可能なメモリ領域にアクセスしようとすると起こる”Segmentation fault”エラーのデバッグである．
動的メモリ確保については問題p32では詳しく学習するが，本問題では配列のメモリ領域を実行時に確保するため，動的メモリ確保を利用する．
配列を利用するときに今まで通りの配列と同じ使い方で問題ない．
この配列外にアクセするときに，その領域はアクセス不可能な場合”Segmentation fault”が発生し，プログラムが強制終了される．

---
## 仕様
---

- 以下のサンプルプログラムが用意されている．
  ```
  #include <stdio.h>
  #include <stdlib.h>

  int main() {
    int nStudents;

    scanf("%d", &nStudents);
    int* seseki = (int*)malloc(sizeof(int)*nStudents);   //成績を記憶する配列の動的確保
    int* bangou = (int*)malloc(sizeof(int)*nStudents);   //学籍番号を記憶する配列の動的確保

    for(int i=0; i<nStudents; i++) {                     //??
      scanf("%d", &seseki[i]);
    }

    int end = nStudents - 1;
    int begin = 0;
    for(int i=0; i<nStudents; i++) {                     
      if(seseki[i] >= 60) {                              //??
        bangou[end] = i+1;                               //??
        end--;                                           //??
      }
      else {                                             //??
        bangou[begin] = i;                               //??
        begin++;                                         //??
      }
    }

    printf("Failed students\n");
    for(int i=0; i<=end; i++) {                          //??
      printf("Gakuseki bangou = %d, Marks = %d\n", bangou[i], seseki[bangou[i]]);
    }

    printf("\nPassed students\n");
    for(int i=nStudents-1; i>end; i++) {                 //??
      printf("Gakuseki bangou = %d, Marks = %d\n", bangou[i], seseki[bangou[i]]);
    }

    free(seseki);
    free(bangou);

    return 0;
  }
  ```

- サンプルプログラムではまず学生の数を標準入力から受け取り，学生の成績を入れる配列と学籍番号を入れる配列を動的メモリ確保により作成する．
- 学籍番号順になっている学生の成績を標準入力から受け取り，その成績を配列に保存する．ここで学籍番号は１から順番になっていると仮定する．
- 次に成績の配列の最初から順番に見ながら，６０以上の合格の学生の学籍番号は，学籍番号の配列の最後から左へ詰めていく．
- 不合格の学生の学生の学籍番号は，学籍番号の配列の最初から右へ詰めていく．
- 次に不合格の学生は学籍番号の小さい方から順番に表示する．
- 最後に合格の学生は学籍番号が小さい方から順番に表示する．

---
## 手順
---

- 左下にある”回答例のロード”ボタンをクリックすると解答例がロードされる．解答例にはコンパイルエラーは含まれていない．
- ”回答例のロード”ボタンを押す代わりに仕様にあるコードを手入力しても良いが，コンパイルエラーは発生したら，入力間違いであるのでサンプルコードは正しくコピーされているのかを確認する．
- 以下にある実行例に関してプログラムを実行し，エラーを確認する．
- どの配列のどこに範囲外アクセスになっているのかをデバッグにより確認する．
- 一つのデバッグ手法としては，コードを部分ごとにコメントアウトしエラーを確認することである．しかしながら，範囲外アクセスが含まれていても，そのアクセスが最終結果に影響しない場合はコンパイラーの最適化により実際にアクセスしないように実行される場合がある．
- 別の手法としては，配列のアクセスるインデックスを出力して確認する方法もある．
- 部分実行とンデックスを出力することは一緒に利用すると効率よくデバッグできる．

---
## 実行例
---

---
### 実行例(1)
---
- 入力データ
```
9 8 0 2 5 12 5 1
```
- 出力例
```
Value[0] >= 8
Value[1] >= 8
Value[2] < 4
Value[3] < 4
5 <= Value[4] < 8
Value[5] >= 8
5 <= Value[6] < 8
Value[7] < 4
```
