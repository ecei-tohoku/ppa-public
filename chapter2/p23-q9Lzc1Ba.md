---
layout: page
title: 2-3. デバッグ問題【基本】
---

アプリケーション開発における重要なステップはプログラミングである．しかしながら，プログラムの中にエラーが発生することは普通であり，そのエラーを削除することはデバッグと呼ぶ．エラーは以下の４種類に分類できる．
- 構文エラー
- リンカーエラー
- ランタイムエラー
- 論理エラー

この中でリンカーエラーとは複数のバイナリをリンクするときのエラーでありプログラミング演習Aのスコープから対象外である．それ以外のエラーについて以下の表に表す．

|  エラーの種類     |  エラーの説明            |  エラーの発見方法                                    |
| --------------  | ---------------------  | ------------------------------------------------  |
|  構文エラー       |  言語の構文や規則に違反   | コンパイルが失敗することで発見                          | 
|  ランタイムエラー  |  実行の失敗に関するエラー  | プログラムの強制終了，または異常な動作により実行時に発見    |
|  論理エラー       |  期待と異なる出力        |  テストパターンを入れ，期待と異なる動作を確認することで発見  |



---
## 問題 (a)
---

この問題では構文エラーのデバッグを行う．サンプルプログラムの中では，標準入力から受け取る8個の数値に関して以下の処理を行う．
- 値が4より小さい場合はそのことを標準出力に出す
- ４に等しいとそのことを標準出力に出す
- ５と8の間にある場合そのことを標準出力に出す
- 8以上の場合，そのことを標準出力に出す

---
## 仕様
---

-  この問題では構文エラーのデバッグを行う．構文エラー以外のエラーは含まれていない．
-  ？？？ボタンを押すと構文エラーが含まれているコードが表示される．
<span style="color:red">ここでは絶対に自分で仕様にあるコードをエディターに手入力することを避ける</span>
手入力により関係のないエラーも入る可能性があるので，？？？ボタンを押してからデバッグを開始する．
   

```
#include <stdio.h>

int main() {
  int b[8];
  int i;
  
  for(i=0; i<8: i++)
    scanf("%d", &b[i]);
  
  for(i=0; i<8; i++) {
    if(b[i] < 4) {
      printf("Value[%d] < 4\n", i)
    }
    else if(b[i] == 4) {
      printf("Value[%d] == 4\n", i);
    }
      else if(b[i] < 8) {
        printf("5 <= Value[%d] < 8\n", i);
      }
      else {
        printf("Value[%d] >= 8\n", i);
      }
    }
  }
  
  return 0
}
```

---
## 手順
---

- まずはコンパイルする．
- 一番上のエラーから直していく．エラーの表示の時の行番号を確認し直していく．
- 実際のエラーはコンパイル結果の行ではなく，その前の行にある場合もあるので確認が必要．
- エラーを直すたびにコンパイルし，その結果を見て次のデバッグを行う．


---
## 実行例
---

---
### 実行例(1)
---
- 入力データ
```
9 8 0 2 5 12 5 1
```
- 出力例
```
Value[0] >= 8
Value[1] >= 8
Value[2] < 4
Value[3] < 4
5 <= Value[4] < 8
Value[5] >= 8
5 <= Value[6] < 8
Value[7] < 4
```

---
## 問題 (a)
---

この問題ではVLA（可変長配列）の範囲外アクセスによるランタイムエラーのデバッグを行う．
宝くじの表面には以下の図に示すように，当選番号，２次元バーコードとバーコード関連の数字が書かれている．
<p align="center">
  <img src="prob2-2-1.jpg" width="400">
  <figcaption align = "center"><b>図１ - ユークリッドの互除法アルゴリズムのフローチャート</b></figcaption>
</p>．
当選番号のチェックのため以下の順番にシステムに入力する
1. 入力者の歳
2. 当選番号の数
3. 当選番号
4. バーコードの１２桁の数字

プログラムの中では，１等賞の番号で配列が初期化されている．
入力される当選番号を保存するため可変長配列を用意する．色々な宝くじに対応するように可変長配列が使われており，入力される当選番号の数に合わせて配列の長さが実行時に設定される．
また，バーコード番号を保存するためにも長さ12の配列を用意する．

入力に対してシステムが以下の処理をする
- 入力者の年が10歳以下の場合以下のように出力され，プログラムが終了される．
  ```
   You are not eligible↩︎
  ```
- 当選番号の数が５の場合１等の番号と入力された番号を比較する．また，バーコード番号も標準入力から受け取る．その後以下のように出力される．
  ```
   ===  Enshu Loto Jumbo 2023  ===↩︎  	
   Winning numbers :	10 23 44 45 21↩︎
   -----------------------------------↩︎
   Your barcode    :  12-34-56-8-6-10-0-45-3-23-91-1↩︎
  ```
  一致した場合は以下のように表示される．
  ```
   You won 1,000,000,000↩︎
  ```
  一致しない場合は以下のように表示される．
  ```
   You lose↩︎
  ```
- 当選番号の数が５でない場合は以下のように表示され，終了される．
  ```
   Ticket not found↩︎
  ```

---
## 仕様
---
