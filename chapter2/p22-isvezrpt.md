---
layout: page
title: 2-2. 最小値検索【基本】
---

## 学習内容と関連問題
---
1. [関数](https://www.ppa.riec.tohoku.ac.jp/ppa/practice/function1)，[関数（配列引数）](https://www.ppa.riec.tohoku.ac.jp/ppa/practice/function2)
1. 配列処理については，[p1-4](https://ecei-tohoku.github.io/ppa-public/chapter1/p14-ZlvVRGYQ.html)を参照のこと．
1. 第５章「ソート」のうち，「選択ソート」（p5-1）で最小値探索を使う予定．

---
## 導入文
---
C言語のプログラムは，`main`関数内に動作させたい内容を記述すればよいが，プログラムの規模が大きくなるにつれて，`main`関数の内容が膨大になってしまう．このような場合，適当な大きさの関数に分割してプログラムを書くことが多い．たとえば，繰り返し計算する部分を関数として実装することで，別の箇所から何回も呼び出すことができる．ここでは，複数の関数が連携して1つのタスクを解決するプログラムを作成しよう．



---
## 問題
---
標準入力から正整数`N`と`N`個の正整数の配列を読み込み、配列の最小要素を見つけ、この要素を配列の先頭に移動するプログラムを作成せよ．

ただし，プログラムは以下の仕様を満たすこと．

1. `#include` していいのは `<stdio.h>`のみとする．
1. 関数は全て前方宣言すること．前方宣言については、このページの後半で説明する．
1. グローバル変数を使用しないこと．グローバル変数についてはこの問題では深く触れないが，参考情報で簡単に説明している．「使ってはいけない」ので，ここでは理解する必要はない．
1. 三つの関数を作成すること．一つ目の関数は配列全体を出力する．二つ目の関数は最小の要素を見つける．三つ目の関数は配列の二つの要素を交換する．この三つの関数をかならず使うこと．
1. 入力からすべての要素を読み取った後、配列全体を出力すること．
1. 2 つの要素が比較されるたびに、これまでの比較の総数、これまでの最小要素の値、およびこれまでの最小要素のインデックスを出力すること．最小値を持つ要素が 2 つある場合は、インデックスが小さい要素が選択されること.
1. 最小要素と配列の先頭の値を交換することで、最小要素を配列の先頭に移動し、配列全体を出力すること．
1. 配列全体を出力し、最小の要素を見つけ、その要素を配列の先頭に移動する別の関数を作成すること．


---
## 実行例
---
- 入力

```
16 74 93 26 48 65 47 38 46 59 20 93 72 39 58 3 9
```

- 出力

```
  74,   93,   26,   48,   65,   47,   38,   46,   59,   20,   93,   72,   39,   58,    3,    9, 
comp = 1, minValue = 74, minIndex = 0
comp = 2, minValue = 26, minIndex = 2
comp = 3, minValue = 26, minIndex = 2
comp = 4, minValue = 26, minIndex = 2
comp = 5, minValue = 26, minIndex = 2
comp = 6, minValue = 26, minIndex = 2
comp = 7, minValue = 26, minIndex = 2
comp = 8, minValue = 26, minIndex = 2
comp = 9, minValue = 20, minIndex = 9
comp = 10, minValue = 20, minIndex = 9
comp = 11, minValue = 20, minIndex = 9
comp = 12, minValue = 20, minIndex = 9
comp = 13, minValue = 20, minIndex = 9
comp = 14, minValue = 3, minIndex = 14
comp = 15, minValue = 3, minIndex = 14
   3,   93,   26,   48,   65,   47,   38,   46,   59,   20,   93,   72,   39,   58,   74,    9, 
```

---
### 手順例
---

問題を分解して考える．

1. 標準入力から正整数`N`を読み込む
1. `N`要素の正の整数の配列を作成
1. 配列のすべての要素を読み込む
1. 配列のすべての要素を出力
1. 配列の最小要素を見つける
1. 配列の最小要素を配列の先頭に移動
1. 配列のすべての要素をもう一度出力

---
#### 0. 準備

これまでと同様に，まず，確実に必要と思われるC言語のメインの構造を作る．

```
#include <stdio.h>

// 必要な関数の前方宣言

int main()
{
  // 必要な入力を読み込む

  // 配列を出力

  // 配列の最小要素を見つける

  // 最小要素を配列の先頭に移動

  // 配列を出力

  return 0;
}

// 必要な関数の実装
```

---
#### 1. 必要な入力を読み込む

次に，読み込み部分を考える．自動採点システムに用意したテストケースでは，配列の要素数がテストケースごとに異なる．このため，「可変長配列」を用いて配列の要素数を宣言する必要がある．可変長配列では，以下の例のように，配列を宣言するときの要素数を変数にできる．

```
#include <stdio.h>

// 必要な関数の前方宣言

int main()
{
  int N;
  scanf("%d", &N);
  int data[N];
  ???  // 配列の要素を読み込む

  // 配列を出力

  // 配列の最小要素を見つける

  // 最小要素を配列の先頭に移動

  // 配列を出力

  return 0;
}

// 必要な関数の実装
```

---
#### 2. 配列を出力

次に，配列を出力の部分を考える．ここでは，配列を出力するための`void`型関数`print_array`を作成する．入力データの配列と入力データの個数の二つを引数とすること．

```
void print_array(int array[], int N) ...
```

配列の各要素の出力は4桁とすること．要素1つを出力後にカンマと空白を加えること．配列の最後の要素の出力後は改行せよ．

出力例:

```
⊔⊔⊔6,⊔⊔⊔⊔2,⊔⊔⊔11,⊔⊔⊔⊔9,⊔⊔⊔12,⊔⊔⊔13,⊔⊔⊔⊔1,⊔⊔⊔10,⊔↩︎
```

```
#include <stdio.h>

// 必要な関数の前方宣言
void print_array(int array[], int N);

int main()
{
  int N;
  scanf("%d", &N);
  int data[N];
  ???  // 配列の要素を読み込む

  print_array(???);

  // 配列の最小要素を見つける

  // 最小要素を配列の先頭に移動

  print_array(???);

  return 0;
}

// 必要な関数の実装
void print_array(int array[], int N) {
  ???
}
```

---
#### 3. 配列の最小要素を見つける

次に，配列の最小要素を見つける部分を考える．最小値を見つける`int`型の関数`find_min`を作成せよ．入力データの配列と入力データの個数の二つを引数とすること．配列の最小要素のインデックスを返すこと．配列の最小要素の値を返さないように注意．

```
int find_min(int array[], int N) ...
```

配列の最初の要素をこれまでの最小要素と見なすことから始めること．次に、配列の 2 番目の要素から配列の最後の要素まで、各要素の値をそれまでの最小要素と比較．各比較の後、必要に応じて最小要素のインデックスを更新．さらに、各比較の後、これまでの比較の数、これまでの最小要素の値、およびこれまでの最小要素のインデックスを出力．毎回の後に改行を出力するように注意．

出力例:

```
comp⊔=⊔15,⊔minValue⊔=⊔3,⊔minIndex⊔=⊔14↩︎
```

```
#include <stdio.h>

// 必要な関数の前方宣言
void print_array(int array[], int N);
int find_min(int array[], int N);

int main()
{
  int N;
  scanf("%d", &N);
  int data[N];
  ???  // 配列の要素を読み込む

  print_array(???);

  ??? = find_min(???);

  // 最小要素を配列の先頭に移動

  print_array(???);

  return 0;
}

// 必要な関数の実装
void print_array(int array[], int N) {
  ???
}

int find_min(int array[], int N) {
  ???
}
```

---
#### 4. 最小要素を配列の先頭に移動

次に，最小要素と配列の先頭の値を交換することで、最小要素を配列の先頭に移動する部分を考える．2 つの要素を交換する`void`型関数`swap`を作成せよ．入力データの配列と入れ替える配列の要素インデクス`x`と`y`の三つを引数とすること．

```
void swap(int array[], int x, int y) ...
```

```
#include <stdio.h>

// 必要な関数の前方宣言
void print_array(int array[], int N);
int find_min(int array[], int N);
void swap(int array[], int x, int y);

int main()
{
  int N;
  scanf("%d", &N);
  int data[N];
  ???  // 配列の要素を読み込む

  print_array(???);

  ??? = find_min(???);

  swap(???);

  print_array(???);

  return 0;
}

// 必要な関数の実装
void print_array(int array[], int N) {
  ???
}

int find_min(int array[], int N) {
  ???
}

void swap(int array[], int x, int y) {
}
```

---
## 参考情報
---

---
### 変数のスコープについて
---

関数を正しく使う上で理解する必要があるプログラミングの概念として，変数の”スコープ”がある．スコープとは，定義された変数が存在できるプログラム上の領域（範囲）のことを指し，それを超えると変数にアクセスできなくなる．次の例では，変数`x`が`main`関数の外に存在しないため，コンパイルできない．つまり，変数`x`のスコープは`main`関数の中のみであり，関数`foo`は変数`x`にアクセスできない．

```
#include <stdio.h>

void foo ();

int main () {
  int x;

  x = 100;

  foo();

  printf(“main x = %d\n”, x);

  return 0;
}

void foo () {
  x = 200;

  printf(“foo x = %d\n”, x);
}
```

さらに，関数`foo`を変更して変数`x`を宣言すると，その内部にのみスコープを持つ新しい変数`x`が作成される．関数`main`の変数`x`と関数`foo`の変数`x`は，名前は同じであるが異なる変数である．このため，`foo`の`x`の値を変更しても，`main`の`x`の値は変更されない．

```
#include <stdio.h>

void foo ();

int main () {
  int x;

  x = 100;

  foo();

  printf(“main x = %d\n”, x);

  return 0;
}

void foo () {
  int x;

  x = 200;

  printf(“foo x = %d\n”, x);
}
```

出力例:

```
foo x = 200
main x = 100
```

より一般的には，変数のスコープは関数の中というよりは，（厳密な言い方ではないが）`{}`で囲われた範囲で規定される．例えば
```
if( ... ){
   int i;
}
```
のように書くと，変数`i`のスコープは`if`文内に留まり，`if`文の外では使用できない．また，
```
for(int i=0; i<10; i++){
  ...
}
```
のように書くと，変数`i`は`for`文内でしか使用できない（`{}`で囲われた範囲ではないが，`for`文については特別扱い）．

---
### ローカル変数とグローバル変数
---

上述のスコープが限られる変数を”ローカル変数”と呼ぶが，C言語では，プログラム内の全領域（全関数）で共通で使用することができる”グローバル変数”を定義できる．グローバル変数は，プログラムの全ての関数からアクセスできる．以下の例では，`x`がグローバル変数として宣言されており，関数`main`と 関数`foo`の両方が x にアクセスできる．さらに、`foo`で`x`の値を変更すると、関数`main`の出力が変更される．

```
#include <stdio.h>

int x;

void foo ();

int main () {
  x = 100;

  foo();

  printf(“main x = %d\n”, x);

  return 0;
}

void foo () {
 x = 200;

  printf(“foo x = %d\n”, x);
}
```

出力例:

```
foo x = 200
main x = 200
```

グローバル変数は便利である一方，セキュリティホールの原因になる，プログラムが大きくなるとどの関数でいつ値が変更されるか分からなくなりバグを誘発する要因になるなどデメリットも多いので，限られた場合にのみ使用させるべきである．
