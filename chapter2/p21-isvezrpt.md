---
layout: page
title: 2-1. 最小値検索【初歩】
---

## 学習内容
---
1. p1-1~p1-5で使った機能全て，特に`for`文，`if`文の複雑な組み合わせ．

---
## 導入文
---
C言語のプログラムは，`main`関数内に動作させたい内容を記述すればよいが，プログラムの規模が大きくなるにつれて，`main`関数の内容が膨大になってしまう．このような場合，適当な大きさの関数に分割してプログラムを書くことが多い．たとえば，繰り返し計算する部分を関数として実装することで，別の箇所から何回も呼び出すことができる．ここでは，複数の関数が連携して1つのタスクを解決するプログラムを作成しよう．

---
## 関数について
---
### 関数とは？
プログラミングでいう関数とは，与えられた入力（引数）に対してある特定の処理を行い，出力（返り値）を返すブロックのことである．C言語における関数定義の一般的な形式は以下のとおりである：

```
return_type function_name (parameter_list) {
  return_type return_value;
  
  ...function_body...
  
  return return_value;
}
```

- `parameter_list`は関数の”引数”（入力）のリストである．引数の個数は0個でもよいし，複数個でもよい．一つの引数につき，その型と変数名を指定する．
- `return_type`は”返り値”の型であり，`int`，`char`，`double`などの型を指定する．値を返さずに必要な操作を関数内で実行したい場合は，`return_type`には`void`と書く．
- `return_value`は”返り値”を格納するための変数である．
- `function_name`は関数名であり，関数を呼び出すときに使用される．`printf`，`scanf`，`fgets`も関数である．
- `function_body`は関数の動作を定義する文である．引数を使って処理を行い，返り値を計算する．
- `return`は返り値を返すための文法である．標準的なケースでは関数の最後に書かれるが，for文やif文の中で書いてもよく，その場合は`return`文が書かれた行でその関数呼び出しは終了する．
- 引数は何個でも取ることができるが，返り値は１つしか指定できないことに注意．

### 関数の例
以下の関数は，整数`x`と正の整数`n`を引数に取って，`x`の`n`乗を計算し，その値を返す：

```
int pow (int x, int n) {
  int ret;

  ret = 1;
  while(n > 0) {
    ret = ret * x;
    n = n - 1;
  }

  return ret;
}
```

以下の関数は，整数配列`x`を引数に取って，0~2番目の要素の二乗を計算し，それぞれを`x`に代入する．C言語の仕様上，関数の返り値は１つしか指定できないため，関数で複数の値を計算させたい場合は，配列を引数に渡して，その配列（あるいは別の配列）に計算結果を格納させる．こういった場合，関数の返り値は不要なので，型は`void`型で，”何も返さない”ことを意味する`return;`を関数の最後あるいは途中に書く（省略することも可能）．

```
void powArray (int x[]) {
  x[0] = x[0] * x[0];
  x[1] = x[1] * x[1];
  x[2] = x[2] * x[2];
  
  return;
}
```

返り値用の新しい変数は必ずしも必要ではなく，以下の引数`a`と`b`の和を返す関数のように，計算式を直接`return`の後に書いてもOK．

```
double add(double a, double b){
  return a+b;
}
```

引数も返り値も使わない関数もありうる．以下の関数はエラーメッセージを標準出力する関数である．

```
void print_errmsg(){
  printf("ERROR!\n");
}
```

### 関数の宣言・定義・呼び出し

これまで書いてきた
```
int main(){
   ...
   return 0;
}
```
は`main`関数と呼ばれ，C言語のプログラムでは必ず１つだけ定義する必要がある，特殊な関数である．（`main`関数の引数や返り値についてはこの授業では触れない．）１つのファイルでプログラムを完結させる場合は，`main`関数以外の関数は，`main`関数の前方に”宣言”される必要があり（前方宣言），それらの”定義”は`main`関数の後方でされることが推奨される．

関数の宣言とは，中身を書かずに返り値の型，関数名，引数リストのみを明記しておくことを意味する．書き方は以下のとおり：
```
return_type function_name (parameter_list);
```

C言語ではプログラムは上の行から順にコンパイルされるため，`main`関数で使用される前に「こういう書式の関数を使う予定ですよ」ということをコンパイラに宣言（言い換えると，予告）する必要がある．

関数の定義とは，「関数とは？」で記載したように関数の中身も全て書くことを意味する．前方宣言と同時に定義をすることも可能だが，見やすさ・書きやすさの観点から，本演習では関数の後方定義を仕様としている．

関数を実際に使うことを関数の”呼び出し”と言い，以下のように返り値と引数を指定して行う：
```
  int a = 10, b;
  b = pow(a, 4);
```

引数は変数でも，固定の値でも，計算式（`pow(2*a, 2+3)`など）でもよい．

以下に，関数宣言・定義・呼び出しの例を挙げる．

#### 例1
```
#include <stdio.h>

int pow (int x, int n);

int main () {
  int a = 3, n = 4, b;

  b = pow(a, n);
  printf("%d^%d = %d\n", a, n, b);

  return 0;
}

int pow (int x, int n) {
   // 「関数とは？」で既出なので省略
}
```
[〈このコードを実行する〉](https://www.ppa.riec.tohoku.ac.jp/ppa/practice/function1)

#### 例1の出力

```
3^4 = 81
```


#### 例2

```
#include <stdio.h>

void powArray (int x[]);

int main () {
  int a[] = {1, 2, 3};

  printf("%d, %d, %d\n", a[0], a[1], a[2]);
  powArray(a);
  printf("%d, %d, %d\n", a[0], a[1], a[2]);
  powArray(a);
  printf("%d, %d, %d\n", a[0], a[1], a[2]);

  return 0;
}

void powArray (int x[]) {
  ... // 「関数とは？」で既出なので省略
}
```
[〈このコードを実行する〉](https://www.ppa.riec.tohoku.ac.jp/ppa/practice/function2)

#### 例2の出力

```
1, 2, 3
times powArray called = 1
1, 4, 9
times powArray called = 2
1, 16, 81
```


---
## 問題
---
標準入力から正整数`N`と`N`個の正整数の配列を読み込み、配列の最小要素を見つけ、この要素を配列の先頭に移動するプログラムを作成せよ．

ただし，プログラムは以下の仕様を満たすこと．

1. `#include` していいのは `<stdio.h>`のみとする．
1. 関数は全て前方宣言すること．前方宣言については、このページの後半で説明する．
1. グローバル変数を使用しないこと．グローバル変数についてはこの問題では深く触れないが，参考情報で簡単に説明している．「使ってはいけない」ので，ここでは理解する必要はない．
1. 三つの関数を作成すること．一つ目の関数は配列全体を出力する．二つ目の関数は最小の要素を見つける．三つ目の関数は配列の二つの要素を交換する．この三つの関数をかならず使うこと．
1. 入力からすべての要素を読み取った後、配列全体を出力すること．
1. 2 つの要素が比較されるたびに、これまでの比較の総数、これまでの最小要素の値、およびこれまでの最小要素のインデックスを出力すること．最小値を持つ要素が 2 つある場合は、インデックスが小さい要素が選択されること.
1. 最小要素と配列の先頭の値を交換することで、最小要素を配列の先頭に移動し、配列全体を出力すること．
1. 配列全体を出力し、最小の要素を見つけ、その要素を配列の先頭に移動する別の関数を作成すること．


---
## 実行例
---
- 入力

```
16 74 93 26 48 65 47 38 46 59 20 93 72 39 58 3 9
```

- 出力

```
  74,   93,   26,   48,   65,   47,   38,   46,   59,   20,   93,   72,   39,   58,    3,    9, 
comp = 1, minValue = 74, minIndex = 0
comp = 2, minValue = 26, minIndex = 2
comp = 3, minValue = 26, minIndex = 2
comp = 4, minValue = 26, minIndex = 2
comp = 5, minValue = 26, minIndex = 2
comp = 6, minValue = 26, minIndex = 2
comp = 7, minValue = 26, minIndex = 2
comp = 8, minValue = 26, minIndex = 2
comp = 9, minValue = 20, minIndex = 9
comp = 10, minValue = 20, minIndex = 9
comp = 11, minValue = 20, minIndex = 9
comp = 12, minValue = 20, minIndex = 9
comp = 13, minValue = 20, minIndex = 9
comp = 14, minValue = 3, minIndex = 14
comp = 15, minValue = 3, minIndex = 14
   3,   93,   26,   48,   65,   47,   38,   46,   59,   20,   93,   72,   39,   58,   74,    9, 
```

---
### 手順例
---

問題を分解して考える．

1. 標準入力から正整数`N`を読み込む
1. `N`要素の正の整数の配列を作成
1. 配列のすべての要素を読み込む
1. 配列のすべての要素を出力
1. 配列の最小要素を見つける
1. 配列の最小要素を配列の先頭に移動
1. 配列のすべての要素をもう一度出力

---
#### 0. 準備

これまでと同様に，まず，確実に必要と思われるC言語のメインの構造を作る．

```
#include <stdio.h>

// 必要な関数の前方宣言

int main()
{
  // 必要な入力を読み込む

  // 配列を出力

  // 配列の最小要素を見つける

  // 最小要素を配列の先頭に移動

  // 配列を出力

  return 0;
}

// 必要な関数の実装
```

---
#### 1. 必要な入力を読み込む

次に，読み込み部分を考える．自動採点システムに用意したテストケースでは，配列の要素数がテストケースごとに異なる．このため，「可変長配列」を用いて配列の要素数を宣言する必要がある．可変長配列では，以下の例のように，配列を宣言するときの要素数を変数にできる．

```
#include <stdio.h>

// 必要な関数の前方宣言

int main()
{
  int N;
  scanf("%d", &N);
  int data[N];
  ???  // 配列の要素を読み込む

  // 配列を出力

  // 配列の最小要素を見つける

  // 最小要素を配列の先頭に移動

  // 配列を出力

  return 0;
}

// 必要な関数の実装
```

---
#### 2. 配列を出力

次に，配列を出力の部分を考える．ここでは，配列を出力するための`void`型関数`print_array`を作成する．入力データの配列と入力データの個数の二つを引数とすること．

```
void print_array(int array[], int N) ...
```

配列の各要素の出力は4桁とすること．要素1つを出力後にカンマと空白を加えること．配列の最後の要素の出力後は改行せよ．

出力例:

```
⊔⊔⊔6,⊔⊔⊔⊔2,⊔⊔⊔11,⊔⊔⊔⊔9,⊔⊔⊔12,⊔⊔⊔13,⊔⊔⊔⊔1,⊔⊔⊔10,⊔↩︎
```

```
#include <stdio.h>

// 必要な関数の前方宣言
void print_array(int array[], int N);

int main()
{
  int N;
  scanf("%d", &N);
  int data[N];
  ???  // 配列の要素を読み込む

  print_array(???);

  // 配列の最小要素を見つける

  // 最小要素を配列の先頭に移動

  print_array(???);

  return 0;
}

// 必要な関数の実装
void print_array(int array[], int N) {
  ???
}
```

---
#### 3. 配列の最小要素を見つける

次に，配列の最小要素を見つける部分を考える．最小値を見つける`int`型の関数`find_min`を作成せよ．入力データの配列と入力データの個数の二つを引数とすること．配列の最小要素のインデックスを返すこと．配列の最小要素の値を返さないように注意．

```
int find_min(int array[], int N) ...
```

配列の最初の要素をこれまでの最小要素と見なすことから始めること．次に、配列の 2 番目の要素から配列の最後の要素まで、各要素の値をそれまでの最小要素と比較．各比較の後、必要に応じて最小要素のインデックスを更新．さらに、各比較の後、これまでの比較の数、これまでの最小要素の値、およびこれまでの最小要素のインデックスを出力．毎回の後に改行を出力するように注意．

出力例:

```
comp⊔=⊔15,⊔minValue⊔=⊔3,⊔minIndex⊔=⊔14↩︎
```

```
#include <stdio.h>

// 必要な関数の前方宣言
void print_array(int array[], int N);
int find_min(int array[], int N);

int main()
{
  int N;
  scanf("%d", &N);
  int data[N];
  ???  // 配列の要素を読み込む

  print_array(???);

  ??? = find_min(???);

  // 最小要素を配列の先頭に移動

  print_array(???);

  return 0;
}

// 必要な関数の実装
void print_array(int array[], int N) {
  ???
}

int find_min(int array[], int N) {
  ???
}
```

---
#### 4. 最小要素を配列の先頭に移動

次に，最小要素と配列の先頭の値を交換することで、最小要素を配列の先頭に移動する部分を考える．2 つの要素を交換する`void`型関数`swap`を作成せよ．入力データの配列と入れ替える配列の要素インデクス`x`と`y`の三つを引数とすること．

```
void swap(int array[], int x, int y) ...
```

```
#include <stdio.h>

// 必要な関数の前方宣言
void print_array(int array[], int N);
int find_min(int array[], int N);
void swap(int array[], int x, int y);

int main()
{
  int N;
  scanf("%d", &N);
  int data[N];
  ???  // 配列の要素を読み込む

  print_array(???);

  ??? = find_min(???);

  swap(???);

  print_array(???);

  return 0;
}

// 必要な関数の実装
void print_array(int array[], int N) {
  ???
}

int find_min(int array[], int N) {
  ???
}

void swap(int array[], int x, int y) {
}
```

---
## 参考情報
---

---
### 変数のスコープについて
---

関数を正しく使う上で理解する必要があるプログラミングの概念として，変数の”スコープ”がある．スコープとは，定義された変数が存在できるプログラム上の領域（範囲）のことを指し，それを超えると変数にアクセスできなくなる．次の例では，変数`x`が`main`関数の外に存在しないため，コンパイルできない．つまり，変数`x`のスコープは`main`関数の中のみであり，関数`foo`は変数`x`にアクセスできない．

```
#include <stdio.h>

void foo ();

int main () {
  int x;

  x = 100;

  foo();

  printf(“main x = %d\n”, x);

  return 0;
}

void foo () {
  x = 200;

  printf(“foo x = %d\n”, x);
}
```

さらに，関数`foo`を変更して変数`x`を宣言すると，その内部にのみスコープを持つ新しい変数`x`が作成される．関数`main`の変数`x`と関数`foo`の変数`x`は，名前は同じであるが異なる変数である．このため，`foo`の`x`の値を変更しても，`main`の`x`の値は変更されない．

```
#include <stdio.h>

void foo ();

int main () {
  int x;

  x = 100;

  foo();

  printf(“main x = %d\n”, x);

  return 0;
}

void foo () {
  int x;

  x = 200;

  printf(“foo x = %d\n”, x);
}
```

出力例:

```
foo x = 200
main x = 100
```

より一般的には，変数のスコープは関数の中というよりは，（厳密な言い方ではないが）`{}`で囲われた範囲で規定される．例えば
```
if( ... ){
   int i;
}
```
のように書くと，変数`i`のスコープは`if`文内に留まり，`if`文の外では使用できない．また，
```
for(int i=0; i<10; i++){
  ...
}
```
のように書くと，変数`i`は`for`文内でしか使用できない（`{}`で囲われた範囲ではないが，`for`文については特別扱い）．

---
### ローカル変数とグローバル変数
---

上述のスコープが限られる変数を”ローカル変数”と呼ぶが，C言語では，プログラム内の全領域（全関数）で共通で使用することができる”グローバル変数”を定義できる．グローバル変数は，プログラムの全ての関数からアクセスできる．以下の例では，`x`がグローバル変数として宣言されており，関数`main`と 関数`foo`の両方が x にアクセスできる．さらに、`foo`で`x`の値を変更すると、関数`main`の出力が変更される．

```
#include <stdio.h>

int x;

void foo ();

int main () {
  x = 100;

  foo();

  printf(“main x = %d\n”, x);

  return 0;
}

void foo () {
 x = 200;

  printf(“foo x = %d\n”, x);
}
```

出力例:

```
foo x = 200
main x = 200
```

グローバル変数は便利である一方，セキュリティホールの原因になる，プログラムが大きくなるとどの関数でいつ値が変更されるか分からなくなりバグを誘発する要因になるなどデメリットも多いので，限られた場合にのみ使用させるべきである．
