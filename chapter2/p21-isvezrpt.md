---
layout: page
title: 2-1. 関数とスコープ [初歩]
---

関数は、一緒にタスクを実行する複数の文だ．
すべてのC言語のプログラムには少なくとも 1 つの関数 (`main`) があり、最も単純なプログラムでも追加の関数が定義される．

複数の関数を使用すると、プログラムは複数のスコープを作成することになる．
スコープ（可視範囲）は、定義された変数が存在できるプログラムの領域だ．
変数は、そのスコープを超えてアクセスできない．

ここでは、複数の関数が連携して 1 つのタスクを解決するプログラムを作成する．

---
## 問題
---
標準入力から正整数`N`と`N`個の正整数の配列を読み込み、配列の最小要素を見つけ、この要素を配列の先頭に移動するプログラムを作成せよ．



ただし，プログラムは以下の仕様を満たすこと．

1. `#include` していいのは `<stdio.h>`のみとする．
1. 関数は全て前方宣言すること．前方宣言については、このページの後半で説明する．
1. グローバル変数や静的変数を使用しないこと．グローバル変数と静的変数については、このページの後半で説明する．
1. 入力からすべての要素を読み取った後、配列全体を出力すること．
1. 2 つの要素が比較されるたびに、これまでの比較の総数、これまでの最小要素の値、およびこれまでの最小要素のインデックスを出力すること．
1. 最小要素を配列の先頭に移動した後、配列全体を出力すること．
1. 配列全体を出力し、最小の要素を見つけ、その要素を配列の先頭に移動する別の関数を作成すること．

---
## 実行例
---
`#`は標準入力，`>`は標準出力を表す．

```
# 16 74 93 26 48 65 47 38 46 59 20 93 72 39 58 3 9
>   74,   93,   26,   48,   65,   47,   38,   46,   59,   20,   93,   72,   39,   58,    3,    9, 
> comp = 1, minValue = 74, minIndex = 0
> comp = 2, minValue = 26, minIndex = 2
> comp = 3, minValue = 26, minIndex = 2
> comp = 4, minValue = 26, minIndex = 2
> comp = 5, minValue = 26, minIndex = 2
> comp = 6, minValue = 26, minIndex = 2
> comp = 7, minValue = 26, minIndex = 2
> comp = 8, minValue = 26, minIndex = 2
> comp = 9, minValue = 20, minIndex = 9
> comp = 10, minValue = 20, minIndex = 9
> comp = 11, minValue = 20, minIndex = 9
> comp = 12, minValue = 20, minIndex = 9
> comp = 13, minValue = 20, minIndex = 9
> comp = 14, minValue = 3, minIndex = 14
> comp = 15, minValue = 3, minIndex = 14
>    3,   93,   26,   48,   65,   47,   38,   46,   59,   20,   93,   72,   39,   58,   74,    9, 
```

---
### 手順例
---

問題を分解して考える．

1. 標準入力から正整数`N`を読み込む
1. `N`要素の正の整数の配列を作成
1. 配列のすべての要素を読み込む
1. 配列のすべての要素を出力
1. 配列の最小要素を見つける
1. 配列の最小要素を配列の先頭に移動
1. 配列のすべての要素をもう一度出力

---
#### 0. 準備

これまでと同様に，まず，確実に必要と思われるC言語のメインの構造を作ってみる．

```
#include <stdio.h>

// 必要な関数の前方宣言

int main()
{
  // 必要な入力を読み込む

  // 配列を出力

  // 配列の最小要素を見つける

  // 最小要素を配列の先頭に移動

  // 配列を出力

  return 0;
}

// 必要な関数の実装
```

---
#### 1. 必要な入力を読み込む

次に，読み込み部分を考える．
自動採点システムに用意したテストケースでは，配列の要素数がテストケースごとに異なる．
このため，「可変長配列」を用いて配列の要素数を宣言する必要がある．
可変長配列では，以下の例のように，配列を宣言するときの要素数を変数にできる．

```
#include <stdio.h>

// 必要な関数の前方宣言

int main()
{
  int N;
  scanf("%d", &N);
  int data[N];
  ???  // 配列の要素を読み込む

  // 配列を出力

  // 配列の最小要素を見つける

  // 最小要素を配列の先頭に移動

  // 配列を出力

  return 0;
}

// 必要な関数の実装
```

---
#### 2. 配列を出力

次に，配列を出力の部分を考える．
配列を出力する`void`型関数`print_array`を作成せよ．
入力データの配列と入力データの個数の二つを引数とすること．

```
void print_array(int array[], int N) ...
```

配列の各要素の出力は4桁とすること．
要素1つを出力後にカンマと空白を加えること．
配列の最後の要素の出力後は改行せよ．
出力例:

```
⊔⊔⊔6,⊔⊔⊔⊔2,⊔⊔⊔11,⊔⊔⊔⊔9,⊔⊔⊔12,⊔⊔⊔13,⊔⊔⊔⊔1,⊔⊔⊔10⊔↩︎
```

```
#include <stdio.h>

// 必要な関数の前方宣言
void print_array(int array[], int N);

int main()
{
  int N;
  scanf("%d", &N);
  int data[N];
  ???  // 配列の要素を読み込む

  print_array(???);

  // 配列の最小要素を見つける

  // 最小要素を配列の先頭に移動

  print_array(???);

  return 0;
}

// 必要な関数の実装
void print_array(int array[], int N) {
  ???
}
```

---
#### 3. 配列の最小要素を見つける

次に，配列の最小要素を見つける部分を考える．
最小値を見つける`int`型の関数`find_min`を作成せよ．
入力データの配列と入力データの個数の二つを引数とすること．
配列の最小要素のインデックスを返すこと．
配列の最小要素の値を返さないように注意．

```
int find_min(int array[], int N) ...
```

配列の最初の要素をこれまでの最小要素と見なすことから始めること．
次に、配列の 2 番目の要素から配列の最後の要素まで、各要素の値をそれまでの最小要素と比較．
各比較の後、必要に応じて最小要素のインデックスを更新．
さらに、各比較の後、これまでの比較の数、これまでの最小要素の値、およびこれまでの最小要素のインデックスを出力．毎回の後に改行を出力するように注意．
出力例:

```
comp⊔=⊔15,⊔minValue⊔=⊔3,⊔minIndex⊔=⊔14↩︎
```

```
#include <stdio.h>

// 必要な関数の前方宣言
void print_array(int array[], int N);
int find_min(int array[], int N);

int main()
{
  int N;
  scanf("%d", &N);
  int data[N];
  ???  // 配列の要素を読み込む

  print_array(???);

  ??? = find_min(???);

  // 最小要素を配列の先頭に移動

  print_array(???);

  return 0;
}

// 必要な関数の実装
void print_array(int array[], int N) {
  ???
}

int find_min(int array[], int N) {
  ???
}
```

---
#### 4. 最小要素を配列の先頭に移動

次に，最小要素を配列の先頭に移動する部分を考える
2 つの要素を交換する`void`型関数`swap`を作成せよ．
入力データの配列と入れ替える配列の要素インデクス`x`と`y`の三つを引数とすること．

```
void swap(int array[], int x, int y) ...
```

```
#include <stdio.h>

// 必要な関数の前方宣言
void print_array(int array[], int N);
int find_min(int array[], int N);
void swap(int array[], int x, int y);

int main()
{
  int N;
  scanf("%d", &N);
  int data[N];
  ???  // 配列の要素を読み込む

  print_array(???);

  ??? = find_min(???);

  swap(???);

  print_array(???);

  return 0;
}

// 必要な関数の実装
void print_array(int array[], int N) {
  ???
}

int find_min(int array[], int N) {
  ???
}

void swap(int array[], int x, int y) {
}
```

---
## 参考情報
---
---
#### 関数について

コードを個別の関数に分割できる．
コードをさまざまな関数に分割する方法は、プログラマーによって異なる．
しかし、論理的には、各関数が特定のタスクを実行するように分割されている．

関数宣言は、コンパイラに関数の名前、返し値の型、および引数を伝える．
関数定義は、関数の実際の本体を提供する．
前方宣言とは、関数宣言が関数`main`の前にあり、関数定義が関数`main`の後にある場合だ．
前方宣言を使用すると、定義が`main`の後にしか現れない場合でも、関数を`main`内で呼び出すことができる．

C プログラミング言語での関数定義の一般的な形式は次のとおりだ．

```
return_type function_name (parameter_list) {
  function_body
}
```

- 返し値の型: 関数は値を返す場合がある．`return_type`は、関数が返す値のデータ型だ． 一部の関数は、値を返さずに必要な操作を実行する． この場合、`return_type`は`void`だ．
- 関数名:`function_name`は関数の実際の名前．名前は、関数を呼び出すときに使用される．
- 引数: 引数はプレースホルダーのようなものだ． 関数が呼び出されると、引数に値を渡す．`parameter_list`は、関数のパラメーターの型、順序、および数を定義する．関数には引数が含まれていない場合がある．
- 関数本体:`function_body`には、関数の動作を定義する文が含まれる．

例:

```
#include <stdio.h>

int pow (int x, int n);

int main () {
  int a = 3;
  int n = 4;
  int b;

  b = pow(a, n);

  printf("%d^%d = %d\n", a, n, b);

  return 0;
}

int pow (int x, int n) {
  int ret;

  ret = 1;
  while(n > 0) {
    ret = ret * x;
    n = n - 1;
  }

  return ret;
}
```

例の出力:

```
3^4 = 81
```

上記のプログラムが`b = max(a, n)`を実行すると、新しい変数 x と n が作成される．
次に、元の`a`と`n`の値が新しい`x`と`n`にコピーされる．
新しい`n`は元の`n`の単なるコピーであるため、`pow`内の`n`の値を変更しても、`main`内の元の`n`の値は変更されない．
通常、関数の引数と変数の値は、返されない限り、関数の終了後に失われる． ただし、変数が`static`（静的）として宣言されている場合、その値は関数の異なる呼び出し間で維持される．
さらに、この関数は、関数`main`(またはそれを呼び出した関数) の変数を変更できない． ただし、引数が値ではなく変数のアドレスを受け取った場合、関数は元の変数にアクセスして変更できる． これは、配列を引数として渡すときに起こることだ．

例:

```
#include <stdio.h>

void pow2Array (int x[]);

int main () {
  int a[] = {1, 2, 3};

  printf("%d, %d, %d\n", a[0], a[1], a[2]);

  powArray(a);

  printf("%d, %d, %d\n", a[0], a[1], a[2]);

  powArray(a);

  printf("%d, %d, %d\n", a[0], a[1], a[2]);

  return 0;
}

int powArray (int x[]) {
  static int count = 0;

  x[0] = x[0] * x[0];
  x[1] = x[1] * x[1];
  x[2] = x[2] * x[2];

  count = count + 1;
  printf("times powArray called = %d\n");
}
```

例の出力:

```
1, 2, 3
times powArray called = 1
1, 4, 9
times powArray called = 2
1, 16, 81
```

---
#### スコープについて

スコープは、定義された変数が存在できるプログラムの領域だ．
その領域を超えると、変数にアクセスできなくなる．
C プログラミング言語では、変数はローカルまたはグローバルにすることができる．

ローカル変数は、関数内で宣言されるか、関数の引数として宣言される．
ローカル変数は、それらが宣言されている関数内でのみ使用できる．
他の関数はこれらのローカル変数にアクセスできない．
次の例は、変数`x`が関数`main`の外に存在しないため、コンパイルできない． つまり、関数`foo`は変数`x`にアクセスできない．

```
#include <stdio.h>

void foo ();

int main () {
  int x;

  x = 100;

  foo();

  printf(“main x = %d\n”, x);

  return 0;
}

void foo () {
  x = 200;

  printf(“foo x = %d\n”, x);
}
```

さらに、関数`foo`を変更して変数`x`を宣言すると、新しい変数`x`が作成される．
関数`main`の変数`x`は、関数`foo`の変数`x`とは異なる変数だ．
このため、`foo`の`x`の値を変更しても、`main`の`x`の値は変更されない．

```
#include <stdio.h>

void foo ();

int main () {
  int x;

  x = 100;

  foo();

  printf(“main x = %d\n”, x);

  return 0;
}

void foo () {
  int x;

  x = 200;

  printf(“foo x = %d\n”, x);
}
```

出力例:

```
foo x = 200
main x = 100
```

グローバル変数は関数の外で、通常はプログラムの上で宣言される．
グローバル変数は、プログラムのすべての関数からアクセスできる．
以下の例では、`x`がグローバル変数として宣言されている．
関数`main`と 関数`foo`の両方が x にアクセスできる．
さらに、`foo`で`x`の値を変更すると、関数`main`の出力が変更される．

```
#include <stdio.h>

int x;

void foo ();

int main () {
  x = 100;

  foo();

  printf(“main x = %d\n”, x);

  return 0;
}

void foo () {
 x = 200;

  printf(“foo x = %d\n”, x);
}
```

出力例:

```
foo x = 200
main x = 200
```
