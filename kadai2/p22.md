---
layout: page
title: 2-2. 選択ソート【初歩】
---


ここではもっともシンプルなソートアルゴリズムのひとつである<font color="red">挿入に基づくソート</font>である <font color="red">選択ソート (selection sort)</font> を実装しよう．

まず，ソートには昇順（小さい方から大きい方へ）と降順（大きい方から小さい方へ）の通常二パターンが考えられるが，本課題では，簡単のため<font color="red">昇順</font>の場合のみを考える．以降，断りなく単に「ソート」と記載があった場合には，昇順ソートのこととする．

選択ソートの基本操作は，「<font color="red">ソートされていない要素</font>から最も小さい値を見つけ出す」である．
また，見つけた最小値を取り除き，同じ手順を行えば，2番目に小さい値，3番目に小さい値，と順番に抽出することができる．
よって，その時点での最小値を取得したら，それを，配列の先頭から並べていけばソートが完成する．という仕組みである．
直感的にもわかりやすいアルゴリズムと言える．

しかし，これを実際にプログラムで実装するためには，いろいろ考えることがある．
もうすこし具体的な処理手順としては以下のようになる．

1. 配列全体から，もっとも値の小さいデータを探し，配列の先頭(1番目)の要素と交換する．
2. 1番目の要素を除き，配列の<font color="red">残りのデータ</font>の中から，もっとも値の小さいデータ（全体で2番目に値の小さいデータ）を探し，配列の先頭から2番の要素と交換する．
3. 1,2番目の要素を除き，配列の<font color="red">残りのデータ</font>の中から，もっとも値の小さいデータ（全体で3番目に値の小さいデータ）を探し，配列の手前から3番目の要素と交換する．
4. 以下同様

次の図は、最初のステップで、もっとも値の小さいデータ (1) を見つけて、配列xの最初の先頭と交換する方法を示している.

![Select Sort](https://i.imgur.com/4amLHf9.png)

次の図は、アルゴリズムの各反復i後の配列xの状態を示している. 各反復に必要な比較の数に特に注意.

![Select Sort](https://i.imgur.com/ZurtE8b.png)

---
## 問題
---
与えられた配列データを<font color="red">選択ソート</font>により<font color="red">昇順</font>に並べ替えるプログラムを作成せよ．
なお入力データは，1列目が配列の要素数，2列目以降が配列の要素であるとする．
- （例）
```
5 1 2 3 4 5
```

---
### 仕様
---
- `#include` していいのは `<stdio.h>`のみとする．

- 可変長配列を用いて配列を確保すること．可変長配列については，ステップ1/3で説明する．

- 配列を選択ソートによって並び替えるvoid型の `sel_sort` 関数を作成すること．また，以下の仕様を満すこと．
  - 配列の要素を並び替える操作は全てこの関数内で行うこと．
  - 入力データと配列と入力データの個数の二つを引数とすること．
    - 例：
    ```
    void sel_sort(int *array, int N) ...
    ```
  - 要素間の比較回数を数えること．

- 配列を出力するvoid型の `print_array` 関数を作成すること．また，以下の仕様を満すこと．
  - `sel_sort`関数と同様に，入力データと配列と入力データの個数の二つを引数とすること．
  - 配列の各要素の出力は4桁とし，要素1つを出力後にカンマを加えること．
  - 配列の最後の要素の出力後はカンマを加えず，改行せよ．
  - 例：
    ```
    ⊔⊔⊔6,⊔⊔⊔2,⊔⊔11,⊔⊔⊔9,⊔⊔12,⊔⊔13,⊔⊔⊔1,⊔⊔10↩︎
    ```

- 2つの要素を入れ替える`swap` 関数を作成すること．また，以下の仕様を満すこと．
  - 入力データと入れ替える配列の要素番号$x$と$y$の三つを引数とすること．
    - 例：
    ```
    void swap(int *array, int x, int y) ...
    ```

- 表示
  - 配列を入力後，INIT. ARRAY : と表示し，その後入力した配列を`print_array` 関数を用いて出力すること
    - 例：
    ```
    INIT.⊔ARRAY⊔:⊔⊔⊔⊔6,⊔⊔⊔2,⊔⊔11,⊔⊔⊔9,⊔⊔12,⊔⊔13,⊔⊔⊔1,⊔⊔10↩︎
    ```
  - 配列全体から，もっとも値の小さいデータを探し，配列の先頭(1番目)の要素と交換した後，入れ替えた要素の場所と配列全体の要素を以下の書式で表示すること
    - 交換した2つの要素番号$i,j(i<j)$を用いて SWAP$(i,j)$ : と表示後に，交換後の配列の全要素を`print_array` 関数を用いて表示する．
    SWAP$(i,j)$の$i$と$j$は2桁で表示する．
    - 例：要素番号0,6の要素を交換した場合
    ```
    SWAP(⊔0,⊔6)⊔:⊔⊔⊔⊔1,⊔⊔⊔2,⊔⊔11,⊔⊔⊔9,⊔⊔12,⊔⊔13,⊔⊔⊔6,⊔⊔10↩︎
    ```
  - 配列の2番目の要素と交換した後，配列の2番目の要素と交換した後，・・・も同様の表示を行うこと
  - 配列の並べ替えが完了したら，comp = と表示し，比較回数を表示して改行せよ
    - 例
    ```
    comp⊔=⊔28↩︎
    ```

  - 全体的な出力例は実行例を参照のこと．



---
### ステップに分けてプログラミング
---
この問題では，「配列全体から最小値を検索し，それを左に移動させる」「残りの配列データに対して最小値探索を繰り返す」「配列の２つの値を交換する処理を関数化する」の3ステップに分けてプログラミングしてもらう．ステップごとに"動作確認"に成功しなければ，"TAに提出"が出来ないようになっている．以下では，各ステップをさらに細分化して説明する．

---
### ステップ1/3　「配列全体から最小値を検索し，それを左に移動させる」
---
#### 1-1. 準備

- これまでの問題と同様に，まず，確実に必要と思われるC言語のメインの構造を作る．

#### 1-2. 適当な配列を用意
- 標準入力から読み込むのではなく，まずは適当な配列を`main` 関数内で用意する．

#### 1-3. 2つの要素を入れ替える部分を実装
- 配列の0番目と1番目の要素を入れ替え，結果を標準出力してチェックする．

#### 1-4. 2-1のプログラムで配列全体の最小値を見つけ，配列の先頭と最小値の位置を交換する
- 結果を標準出力してチェックする．

#### 1-5. 配列の要素数と配列データを標準入力する．
- 自動採点システムに用意したテストケースでは，配列の要素数がテストケースごとに異なる．このため，配列の要素数をテストケースごとに宣言する必要がある．問題2-2〜2-4では，「可変長配列」を用いて配列の要素数を宣言する．可変長配列では，以下の例のように，配列を宣言するときの要素数を変数にできる．
    - 例：
    ```
    int main(){
      int n;             // 配列の要素数
      scanf("%d", &n)    // nを標準入力
      int data[n];       // 配列を宣言
      data[0] = 1;       // 0番目の要素を入力
      data[1] = 2;       // 1番目の要素を入力
      printf("%d %d\n", data[0], data[1]);	// dataを標準出力
      return 0;
    }
    ```
#### 1-6. 標準出力の部分を実装する．
- `main` 関数内で標準出力を行う．ステップ1/3では，以下の仕様とする．
  - 配列の各要素の出力は4桁とし，要素1つを出力後にカンマを加えること．
  - 配列の最後の要素の出力にもカンマを加え，改行せよ．


---
## 実行例
---
---
### 実行例(1)
---
- 入力データ
```
5 1 2 3 4 5
```
- 出力例
```
INIT:::::::  1  2  3  4  5
DONE:::::::  1  2  3  4  5
10
```

---
### 実行例(2)
---
- 入力データ
```
7 2 1 3 7 4 6 5
```
- 出力例
```
INIT:::::::  2  1  3  7  4  6  5
SWAP( 0, 1)  1  2  3  7  4  6  5
SWAP( 3, 4)  1  2  3  4  7  6  5
SWAP( 4, 6)  1  2  3  4  5  6  7
DONE:::::::  1  2  3  4  5  6  7
21
```

---
### 実行例(3)
---
- 入力データ
```
13 10 2 8 4 11 9 11 5 3 13 1 2 6
```
- 出力例
```
INIT::::::: 10  2  8  4 11  9 11  5  3 13  1  2  6
SWAP( 0,10)  1  2  8  4 11  9 11  5  3 13 10  2  6
SWAP( 2,11)  1  2  2  4 11  9 11  5  3 13 10  8  6
SWAP( 3, 8)  1  2  2  3 11  9 11  5  4 13 10  8  6
SWAP( 4, 8)  1  2  2  3  4  9 11  5 11 13 10  8  6
SWAP( 5, 7)  1  2  2  3  4  5 11  9 11 13 10  8  6
SWAP( 6,12)  1  2  2  3  4  5  6  9 11 13 10  8 11
SWAP( 7,11)  1  2  2  3  4  5  6  8 11 13 10  9 11
SWAP( 8,11)  1  2  2  3  4  5  6  8  9 13 10 11 11
SWAP( 9,10)  1  2  2  3  4  5  6  8  9 10 13 11 11
SWAP(10,11)  1  2  2  3  4  5  6  8  9 10 11 13 11
SWAP(11,12)  1  2  2  3  4  5  6  8  9 10 11 11 13
DONE:::::::  1  2  2  3  4  5  6  8  9 10 11 11 13
78
```

---
### 実行例(4)
---
- 入力データ
```
7 2 1 1 2 3 1 2
```
- 出力例
```
INIT:::::::  2  1  1  2  3  1  2
SWAP( 0, 1)  1  2  1  2  3  1  2
SWAP( 1, 2)  1  1  2  2  3  1  2
SWAP( 2, 5)  1  1  1  2  3  2  2
SWAP( 4, 5)  1  1  1  2  2  3  2
SWAP( 5, 6)  1  1  1  2  2  2  3
DONE:::::::  1  1  1  2  2  2  3
21
```

