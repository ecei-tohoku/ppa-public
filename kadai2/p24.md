---
layout: page
title: 2-4. 二分探索法【基本】
---

ここでは，2-3で実装したマージソートを用いた応用として，配列の中から条件に合う要素を見つけ出す”探索”を考える．

---
## 問題
---
与えられた整数配列データを読み込んで，ある整数の範囲$[a, b] (a<b)$に入る要素の数をカウントするプログラムを作成せよ．

---
### 仕様
---
- 配列の大きさ$n$は$1\le n \le 1,000$であり，配列の要素は全て整数であると仮定してよい．

- $a<b$であり，配列の中には$a$，$b$は入っていないと仮定してよい．

- 配列の要素$A_{i} (0\le i\le n)$が$a\le A_{i}\le b$を満たすときに，$[a, b]$の範囲に入っているとしてカウントする．

- 入力は，以下の順で与えられるとする：
```
n
A1 A2 ... An
a b
```

- 以下の二通りのアルゴリズムを実装する関数を作成した上で，それらを順に適用していき，範囲内の要素の数と，比較演算を実行した回数を出力すること：
1. 配列をソートせずに，配列の先頭から順に$[a, b]$の範囲内にあるか判定していく．関数名および引数は以下のとおりにすること：
```
struct Count search_unsorted(int array[], int N, int a, int b);
```
返り値のstruct Countは"構造体"と呼ばれるC言語の機能で，変数を複数まとめて一つの変数として扱える．詳細は[構造体](#structure)の章を読むこと

2. 配列をソートした後，下記に説明する<font color="red">二分探索法</font>を用いて$A_{i}< a<A_{i+1}$となる$i$，$A_{j}<b<A_{j+1}$となる$j$を探すことで，範囲内にいくつ要素があるか計算する．関数名および引数は以下のとおりにすること：
```
struct Count search_sorted(int array[], int N, int a, int b);
```

- 比較演算のカウントについて。。。

- それぞれのアルゴリズムについて，厳密な比較演算の回数は実装の仕方によって異なる（$a$と$b$のどちらかから比較するかなど）．ここでは，それぞれのアルゴリズムについて以下のとおりに縛りを入れることで，比較演算回数を一意的に定めることとする：
1. 各要素に対して，まず$a$から比較すること．その時点で範囲外であることが分かった場合，$b$とは比較を行わないこと．
2. 。。。

- 出力は，範囲内の要素数と比較演算回数の間に空白文字一つを入れ，それぞれのアルゴリズムについて末尾に改行文字を入れること．

---
### 構造体<a name="structure"></a>
---
- 以下の二通りのアルゴリズムを実装する関数を作成した上で，それらを順に適用していき，範囲内の要素の数と，比較演算を実行した回数を出力すること：
- 構造体の中の変数には，ピリオド"."を付けて書くことでアクセス可能．通常の変数と同様に演算ができる．
- 具体的には以下のように
```
// 構造体を定義
struct 構造体名 {
  int 変数1;
  int 変数2;
};
...
//
struct 構造体名 a;
...
// 通常の変数のように代入ができる
a.変数1 = 1;
b.変数2 = 2;
...
// 通常の変数のように演算ができる
int tmp = a.変数1+b.変数2;
printf("%d %d\n", 構造体名.変数1, 構造体名.変数2);
```


---
### 二分探索法
---

---
## 実行例
---
- 入力データ
```
5
1 3 5 7 9
2 8
```
- 出力例
```

```

---
## 補足
---
- この問題では「配列の中には$a$，$b$は入っていない」と仮定したが，より現実的には同じ要素が１つ以上入っていることもある．余力があれば，そのケースに対応するためにはどのように自分の書いたコードを拡張すればよいか，考えてみよう．

- 一度ソートとしておいて探索を高速化する手法は，データベースなどで重用されている．$m$回探索を行うとすると，ソートせずに全探索するアルゴリズムでは比較演算回数は$m\times n$に比例する一方，ソートしてから二分探索法するアルゴリズムでは$m\times log_2 n$に比例する．そのため，$m$が十分大きい場合には，後者の方が圧倒的に高速な手法である．
