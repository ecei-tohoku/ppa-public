---
layout: page
title: 2-4. 二分探索法【基本】
---

ここでは，2-3で実装したマージソートを用いた応用として，配列の中から条件に合う要素を見つけ出す”探索”を考える．

---
## 問題
---
与えられた整数配列データを読み込んで，ある整数の範囲$[a, b] (a<b)$に入る要素の数をカウントするプログラムを作成せよ．

---
### 仕様
---
- 配列の大きさ$n$は$1\le n \le 1,000$であり，配列の要素は全て整数であると仮定してよい．

- $a<b$であり，配列の中には$a$，$b$は入っていないと仮定してよい．

- 配列の要素$A_{i} (0\le i\le n)$が$a\le A_{i}\le b$を満たすときに，$[a, b]$の範囲に入っているとしてカウントする．

- 入力は，以下の順で与えられるとする：
```
n
A1 A2 ... An
a b
```

- 以下の二通りのアルゴリズムを実装する関数を作成した上で，それらを順に適用していき，範囲内の要素の数と，比較演算を実行した回数を出力すること：
1. 配列をソートせずに，配列の先頭から順に$[a, b]$の範囲内にあるか判定していく．関数名および引数は以下のとおりにすること：
```
struct Count search_unsorted(int array[], int N, int a, int b);
```
返り値のstruct Countは"構造体"と呼ばれるC言語の機能で，変数を複数まとめて一つの変数として扱える．定義の仕方や使い方については、["構造体"](#structure)を読むこと．
 
2. 配列をソートした後，下記に説明する["二分探索法"](#binary_search)を用いて$A_{i-1}< a<A_{i}$となる$i$，$A_{j-1}<b<A_{j}$となる$j$を探すことで，範囲内にいくつ要素があるか計算する．関数名および引数は以下のとおりにすること：
```
struct Count search_sorted(int array[], int N, int a, int b);
```

- 配列要素と`a`，`b`の比較演算としては`<`あるいは`>`のみを用いること．`if`文の条件式として書く場合は，一度に一回の比較のみ行うこと（例えば`if( a<x && x<b )`は，比較演算の回数は場合によって1回にも2回にもなるため，そのことに熟知していないかぎり推奨しない）．

- それぞれのアルゴリズムについて，厳密な比較演算の回数は実装の仕方によって異なる`a`と`b`のどちらかから比較するかなど）．ここでは，それぞれのアルゴリズムについて以下のとおりに縛りを入れることで，比較演算回数を一意的に定めることとする：
1. 各要素に対して，まず`a`から比較すること．その時点で範囲外であることが分かった場合，`b`とは比較を行わないこと．
2. 配列がソートされている場合，もし比較`a < array[0]`をして成り立てば，その他の要素に対しても成り立つため，二分探索する必要はない．それが成り立たない場合，比較`array[N-1] < a`をして成り立てば，他の要素に対しても成り立つため，同じく二分探索する必要はなくなる．この順でまずは比較を行い，どちらのケースにも当てはまらない場合，二分探索を行うこと．二分探索の比較回数については，["二分探索法"](#binary_search)に記載の仕様に従うこと．
- 出力は，範囲内の要素数と比較演算回数の間に空白文字一つを入れ，それぞれのアルゴリズムについて末尾に改行文字を入れること．

---
### 構造体<a name="structure"></a>
---
- 以下の二通りのアルゴリズムを実装する関数を作成した上で，それらを順に適用していき，範囲内の要素の数と，比較演算を実行した回数を出力すること：

- 構造体の中の変数には，ピリオド"."を付けて書くことでアクセス可能．通常の変数と同様に演算ができる．

- 具体的には以下のように使用する：
```
// 構造体を定義
struct 構造体名 {
  int 変数1;
  int 変数2;
};
...
//
struct 構造体名 a;
...
// 構造体中の変数は、通常の変数のように代入・演算ができる
a.変数1 = 1;
b.変数2 = 2;
int tmp = a.変数1+b.変数2;
printf("%d %d\n", 構造体名.変数1, 構造体名.変数2);
...
// 構造体変数自体も代入ができる
struct 構造体名 a, b;
...
a = function(...); // 構造体を返り値とする関数を呼び出し、a中の各変数に代入
b = a; // a中の各変数の値を、b中の各変数に代入
```

- 構造体の中には`int`型に限らず，ほかの型の変数も入れることができる（構造体変数も含む）．また，様々な使い方をすることができるが，ここでは詳細には立ち入らない．

- この問題で必要な構造体`struct Count`は以下のように定義すること：

```
#include <stdio.h>

struct Count {
  int comparison_count; // 比較回数のカウントをする変数
  int element_count; // 範囲内の要素数を保持する変数
};

...
```

---
### 二分探索法<a name=""></a>
---
- ここでは，ソートされた`N`要素の配列`array`に対して，ある数`x`がどこに”入る”かを探す，言い換えると`array[i-1]< x < array[i]`となる`i`を探す．そのために，ソートされていることを活かした<font color="red">二分探索法</font>を用いる．

- `array[0] < x < array[N-1]`であること，どの要素も`x`とは一致しないことを仮定する．

- 二分探索法は，2-4のマージソートと似た感じで配列を分割していき，二つの配列のうちどちらに`x`が入るのかを判定して，範囲を絞っていくというイメージ．

- 二分探索法では，以下の手順で行う：
1. 配列の長さが2の場合，それら2つの要素の間に`x`が入るので，終了．
2. 配列の長さが2より大きい場合、入力配列を同じ長さの2つの配列に分割する．長さが奇数の場合は，必ず前側の配列の長さを1つ長くすること．
3. 前側の配列の末尾の要素と`x`を比較し，`x`の方が小さければ`x`は前側の配列に入る．`x`の方が大きければ`x`は後ろ側の配列に入る．
4. `x`が入る方の配列について，また手順1.から繰り返す．



---
## 実行例
---
- 入力データ
```
5
1 3 5 7 9
2 8
```
- 出力例
```

```

---
## 補足
---
- この問題では「配列の中には$a$，$b$は入っていない」と仮定したが，より現実的には同じ要素が１つ以上入っていることもある．余力があれば，そのケースに対応するためにはどのように自分の書いたコードを拡張すればよいか，考えてみよう．

- 一度ソートとしておいて探索を高速化する手法は，データベースなどで重用されている．$m$回探索を行うとすると，ソートせずに全探索するアルゴリズムでは比較演算回数は$m\times n$に比例する一方，ソートしてから二分探索法するアルゴリズムでは$m\times log_2 n$に比例する．そのため，$m$が十分大きい場合には，後者の方が圧倒的に高速な手法である．
