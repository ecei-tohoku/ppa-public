---
layout: page
title: 2-3. マージソート【基本】
---


ここでは，<font color="red">分割/統合に基づくソート</font>である<font color="red">マージソート (merge sort)</font>を実装してみよう．

マージソートのアルゴリズムは与えられた配列データを小さな部分配列に分割し，部分配列ごとにソートを行なう分割統治法の代表的アルゴリズムの一つである．
マージソートでは<font color="red">再帰関数</font>を使って効率的にアルゴリズムを構築することを学ぶ．

今回は、補助関数mergeを利用する。 mergeは2つの並べ替えられた配列を受け取り、以下のプロセスで結合する．

- 0, 入力配列の長さの合計に等しい長さの空の出力配列を準備する．
- 1, 各入力配列から出力配列にまだ追加されていない最初の要素を比較し、最小のものを$ m $とする．
- 2, 出力配列の最初の空のスペースに$ m $を追加する．
- 3, 入力配列が両方とも出力配列に完全に追加されていない場合は、（1）に戻る．
- 4, 出力配列にまだ追加されていない入力配列をそのまま出力配列の最後にコピーする．

次に、マージソートは、以下のプロセスに従って、mergeと再帰を使用して入力配列をソートする．

- 0, 入力配列の長さが1の場合、すでに並べ替えられているため、そのまま返す．
- 1, 入力配列の長さが1より大きい場合、入力配列を同じ長さの2つの配列に分割する．
- 2, マージソートを2回呼ぶ。新しく作成された半分の長さの配列のそれぞれに対して1回である．
- 3, ソートされた半分の長さの配列に対してmergeを呼び、それらを1つの全体の長さの並べ替えられた配列に結合する．

![Merge Sort](https://i.imgur.com/KVKxFuE.png)
![Merge Sort](https://i.imgur.com/QQUmTtI.png)

---
## 問題
---
与えられた配列データを<font color="red">マージソート</font>により<font color="red">昇順</font>に並べ替えるプログラムを作成せよ．なお入力データは，1列目が配列の要素数，2列目以降が配列の要素であるとする．

---
### 仕様
---

- 今回は、入力配列に同じ値の要素がない

- `#include` していいのは `<stdio.h>`と`“ppa_extra_h/p2_header.h”`のみとする．(“ppa_extra_h/p2_header.h”については下記で説明する。malocを用いないので、<stdlib.h>は必要ない。)

- 関数は全て前方宣言すること．

- 問題2-2と同じく、可変長配列を用いて配列を確保すること．

- マージソートを実行するためには，マージ操作を行う際にデータの配列とは別にマージ用記憶領域が必要となる．
  - データを読み込む配列を動的確保する際に，2倍の領域を確保する．つまりデータの要素数が$N$なら$2N$個のメモリを確保すること．
  - 余計に確保したメモリをマージ用記憶領域として利用すること．つまり，データ配列の値をマージ用記憶領域を含めた$2N$個の記憶域から外に取り出してはいけない．


- 配列操作に利用可能な関数
  - 配列内の要素を配列内の別の場所にコピーする手続きとして`func_copy_val_`関数を用いること．これは，挿入対象の値を退避したり挿入する場合も含まれる．
    ```
    int* func_copy_val_(
    int* const array,
    const int pos_a,
    const int pos_b) 
    {
    array[pos_b] = array[pos_a];
    return array;
    }
    ```
  - 問題2-2で作成した2つの要素を入れ替える`swap`関数の使用は不可
  - 配列内の二つの要素を比較する手続きとして`comp_`関数を用いること．
    ```
    int comp_(             // 配列内の2つの要素を比較する関数
    int* const array,  // 要素の比較を行う配列
    const int pos_a,   // 1つ目の比較対象の要素番号
    const int pos_b    // 2つ目の比較対象の要素番号) 
    {
    if (array[pos_a] < array[pos_b]) return 1;  
    return 0;                                   
    }
    ```
  - 配列内のある範囲の要素を表示する手続きとして`print_array_range_`関数を用いること．
    ```
    void print_array_range_(
        const int* const array,
  　   const int N,
  　    const int p, const int r) {
     int ri = 0;
     for (; ri < N; ++ri) {
        if (ri < p || r < ri) {
          printf(" **");
        } else {
          printf(" %2d", array[ri]);
       }
      }
      printf("\n");
    }
    ```
  - 問題2-2で作成した`print_array`関数は用いない
  - これらの関数は、`#include "ppa_extra_h/p2_header.h"`という宣言を行えば、書かなくても使用することができる.
 

- 配列をマージソートによって並び替える `mrg_sort` 関数を作成すること．また，以下の仕様を満すこと．
  - 配列の要素を並び替える操作は全てこの関数内で行うこと．
    - ただし，この関数内で以下で説明する`merge`関数を呼び出してよい．その際は必ず前方宣言すること．
  - 入力データ用に動的に確保した配列，入力データの個数，mergeの対象となる範囲として始まりの要素番号，終わりの要素番号の4つを引数とすること．
    - 例：
    ```
    int mrg_sort(int *array, int N, int from, int to) ...
    ```
  - 要素間の比較`comp_`の呼び出し回数を`mrg_sort` 関数の戻り値とすること．
  - 配列を分割する際に，奇数で割り切れない場合は，必ず配列の先頭側を一つ多くすること．

- 二つのソート済み配列をマージする`merge`関数を作成すること．また，以下の仕様を満すこと．
  - `mrg_sort`関数内で呼ばれる．
  - 配列の要素をマージする操作は全てこの関数内で行うこと．
    - ただし，この関数内で呼ばれる別の関数を作成してもよい．その際は必ず前方宣言すること．
  - 入力データ用に動的に確保した配列，入力データの個数，mergeの対象となる範囲として始まりの要素番号，終わりの要素番号，中間の要素番号の5つを引数とすること．
    - 例：
    ```
    int merge(int *array, int N, int from, int to, int mid) ...
    ```

- 表示
  - `print_array_range_`関数を使って値のマージ処理が終わる度に，マージした範囲と配列全体の要素を以下の書式で表示すること．
    - マージした範囲の要素番号$i,j(i<j)$を用いて MERG$(i,j)$ と表示し，空白後に交換後の配列の全要素を表示する．
    - 例：要素番号 2,4の範囲をマージした場合
    ```
    MERG(⊔2,⊔4)⊔**⊔**⊔⊔8⊔⊔4⊔11⊔**⊔**⊔**⊔**⊔**⊔**↩︎
    ```

- 以下のプログラムを必ず用いてプログラムを完成せること．

```
#include <stdio.h>
#include <stdlib.h>
#include “ppa_extra_h/p2_header.h”

int mrg_sort(int *, int , int , int );
int merge(int *, int , int , int , int );

int main() {

  ...(省略)...

  return 0;
}

int mrg_sort(int* array, int N, int from, int to) {

  ...(省略)...

}

int merge(int* array, int N, int from, int to, int mid) {

  ...(省略)...

}
```


---
## 実行例
---
---
### 実行例(1)
---
- 入力データ
```
7 2 1 3 7 4 6 5
```
- 出力例
```
INIT:::::::  2  1  3  7  4  6  5
MERG( 0, 1)  1  2 ** ** ** ** **
MERG( 2, 3) ** **  3  7 ** ** **
MERG( 0, 3)  1  2  3  7 ** ** **
MERG( 4, 5) ** ** ** **  4  6 **
MERG( 4, 6) ** ** ** **  4  5  6
MERG( 0, 6)  1  2  3  4  5  6  7
DONE:::::::  1  2  3  4  5  6  7
13
```


---
### 実行例(2)
---
- 入力データ
```
13 10 2 8 4 11 9 11 5 3 13 1 2 6
```
- 出力例
```
INIT::::::: 10  2  8  4 11  9 11  5  3 13  1  2  6
MERG( 0, 1)  2 10 ** ** ** ** ** ** ** ** ** ** **
MERG( 2, 3) ** **  4  8 ** ** ** ** ** ** ** ** **
MERG( 0, 3)  2  4  8 10 ** ** ** ** ** ** ** ** **
MERG( 4, 5) ** ** ** **  9 11 ** ** ** ** ** ** **
MERG( 4, 6) ** ** ** **  9 11 11 ** ** ** ** ** **
MERG( 0, 6)  2  4  8  9 10 11 11 ** ** ** ** ** **
MERG( 7, 8) ** ** ** ** ** ** **  3  5 ** ** ** **
MERG( 7, 9) ** ** ** ** ** ** **  3  5 13 ** ** **
MERG(10,11) ** ** ** ** ** ** ** ** ** **  1  2 **
MERG(10,12) ** ** ** ** ** ** ** ** ** **  1  2  6
MERG( 7,12) ** ** ** ** ** ** **  1  2  3  5  6 13
MERG( 0,12)  1  2  2  3  4  5  6  8  9 10 11 11 13
DONE:::::::  1  2  2  3  4  5  6  8  9 10 11 11 13
36
```



---
### ステップに分けてプログラミング
---
この問題では，「`mrg_sort`関数における再帰処理の実装」「`merge`関数の実装」「`mgr_sort`関数と`merge`関数を組み合わせる」の3ステップに分けてプログラミングしてもらう．ステップごとに"動作確認"に成功しなければ，"TAに提出"が出来ないようになっている．以下では，各ステップをさらに細分化して説明する．

---
### ステップ1/3　「mrg_sort関数における再帰処理の実装」
---
ここでは、`merge`関数の実装は忘れて、`mrg_sort`関数の再帰機能のみを実装する。これは問題文のマージソートの説明において、手順3以外の手順を実装するということである。
  - 0, 入力配列の長さが1の場合、すでに並べ替えられているため、そのまま返す．
  - 1, 入力配列の長さが1より大きい場合、入力配列を同じ長さの2つの配列に分割する．
  - 2, マージソートを2回呼ぶ。新しく作成された半分の長さの配列のそれぞれに対して1回である．

#### 1-1. 準備
- これまでの問題と同様に，まず，確実に必要と思われるC言語のメインの構造を作る．

- 可変長配列を用いて標準入力から長さ$ n $の配列を読み込む
 
- 長さ$ n $の入力配列に対して、範囲0~n-1においてmrg_sort関数を実行する(mrg_sort関数の中身は1-3以降で作成する)

- 以下のプログラムを用いよ.

  ```
    int main(){
      int n;             // 配列の要素数
      scanf("%d", &n)    // nを標準入力
      int data[n];       // 可変長配列による配列の確保
      int i;
      for(i=0; i<N; i++) scanf("%d", &(array[i]));

      printf("INIT:::::::"); print_array_(array, n); 
      
      mrg_sort(data,n, 0 n-1);
      return 0;
  }
  ```

#### 1-2. 配列を前半と後半に分けて、それぞれでmrg_sort関数を再帰的に呼び出すように実装
- 配列を前半と後半に分け、それぞれで`mrg_sort`関数を再帰的に呼び出すように実装し、最終的に長さ1の`mrg_sort`関数になるまで分割を行う。

- 例：長さ$ n $の配列において、範囲0~3の`mrg_sort`関数を呼び出すということは、範囲0~1の`mrg_sort`関数と範囲2~3の`mrg_sort`関数をそれぞれ呼び出すということである。これを再帰を用いて簡略化して表現すると次のようになる。

  ```
  void mrg_sort(int* array, int n, int 0, int 3){
    mrg_sort(array,n,0,1);
    mrg_sort(array,n,2,3);
  }
  ```

- 上記を参考にして、任意の範囲で`mrg_sort`関数関数を再帰的に呼び出すように実装せよ。ただし、仕様にも記載されているように、配列を分割する際に，奇数で割り切れない場合は，必ず配列の先頭側を一つ多くなるようにすること．また,長さが1になった時には処理が終了しなければならない.

#### 1-3. 再帰処理の動作を検証
- ここでは`mrg_sort`関数の再帰が正しく機能していることを確認するために、呼び出すたびに`mrg_sort`関数の最初に自分自身の名前を出力させるようにしておく。

  ```
  void mrg_sort(int* array, int n, int from, int to){
    printf("SORT(%2d : %2d)\n", from , to);
    ???
  }
  ```

- 入力データは，1列目が配列の要素数，2列目以降が配列の要素であるとする．

- 出力を目視で確認すること

  - 例：入力が 2 1 2 の時，出力は以下のようになる
    ```
    SORT( 0 :  1)
    SORT( 0 :  0)
    SORT( 1 :  1)
    ```

  - 例：入力が 3 1 2 3 の時，出力は以下のようになる
    ```
    ```

  - 例：入力が 8 1 2 3 4 5 6 7 の時，出力は以下のようになる
    ```
    SORT( 0 :  7)
    SORT( 0 :  3)
    SORT( 0 :  1)
    SORT( 0 :  0)
    SORT( 1 :  1)
    SORT( 2 :  3)
    SORT( 2 :  2)
    SORT( 3 :  3)
    SORT( 4 :  7)
    SORT( 4 :  5)
    SORT( 4 :  4)
    SORT( 5 :  5)
    SORT( 6 :  7)
    SORT( 6 :  6)
    SORT( 7 :  7)
    ```

#### 1-4. 自動採点システムで動作確認


---
### ステップ2/3　「merge関数の実装」
---
ステップ1/3では再帰により、`mrg_sort`関数をそれぞれ長さ$ 1 $の`mrg_sort`関数になるまで分割を行った。このステップでは分割した`mrg_sort`関数をマージ(統合)する補助関数`merge`を実装する。
問題文の説明のように、補助関数`merge`はソートされた二つの配列を統合することにより、ソートされた一つの配列を作り出すものである。．

- 0, 入力配列の長さの合計に等しい長さの空の出力配列を準備する．
- 1, 各入力配列から出力配列にまだ追加されていない最初の要素を比較し、最小のものを$ m $とする．
- 2, 出力配列の最初の空のスペースに$ m $を追加する．
- 3, 入力配列が両方とも出力配列に完全に追加されていない場合は、（1）に戻る．
- 4, 出力配列にまだ追加されていない入力配列をそのまま出力配列の最後にコピーする．

#### 2-1. 準備
- 仕様にも書いてるあるように、長さ$ n $ の入力配列に対してマージ操作を行う際に、データの配列とは別にマージ用記憶領域が必要となるため、長さ$ 2n $の配列を用意する。

- 入力配列の読み込みは$ 0~n-1 $の範囲で行う。

- 2-2で説明するが、`from`,`to`,`mid`も読み込む

- 以下のプログラムを用いよ。

  ```
    int main(){
      int n;             // 配列の要素数
      int from,to,mid; 
      scanf("%d", &n)    // nを標準入力
      int data[2*n];       // 可変長配列による配列の確保
      
      scanf("%d", &from)
      scanf("%d", &mid)
      scanf("%d", &to)
      
      int i;
      for(i=0; i<N; i++) scanf("%d", &(array[i]));

      printf("INIT:::::::"); print_array_(array, 2*n); 
      
      merge(data,n, from, to, mid);
      return 0;
  }
  ```

#### 2-2. ソートされた二つの配列をソートされた一つの配列にマージする補助関数mergeを実装
- 二つのソートされた配列が与えられた時に、それぞれの先頭の要素から順番に比較を行い、ソートされた一つの配列を作成する。

- 問題文の図からもわかるように、`merge`関数は連続して並んでいる二つの配列を統合する関数である。

- 例えば、長さ6の配列の区間1~2に`5 7`、区間3~4に`6 8`がある場合、入力配列は`0 5 7 6 8 0`として与えられ(区間1~4以外は便宜上0で埋めてある),`merge`関数は次のように動く.

  - まず、区間1~4にある`5 7 6 8`からマージ用記憶領域（区間7~10）にソートされた配列`5 6 7 8`を作り出す。全体の長さ12の配列は`0 5 7 6 8 0 0 5 6 7 8 0`となる。

  - 次に、マージ用記憶領域(区間7~10)にあるソートされた配列を元の領域(1~4)にコピーする。全体の長さ12の配列は`0 5 6 7 8 0 0 5 6 7 8 0`となる。

- ステップ2/3のテストケースでは、一つ目の配列の始まりの位置`from`、一つ目の配列の終わりの位置`mid`、二つ目の配列の終わりの位置`to`も入力として与えられる。上の例では、`from=1`, `mid=2`, `to=4`である。

- 仕様にあるように、`merge`関数は入力データ用に動的に確保した配列，入力データの個数，mergeの対象となる範囲として`from`, `to`, `mid`の5つを引数とする.
  - 例：
  ```
  int merge(int *array, int N, int from, int to, int mid) ...
  ```

  - 仕様に記載されているように、配列内の二つの要素を比較するためには`comp_`関数を、配列内の要素を配列内の別の場所にコピーするためには`func_copy_val_`関数を用いれば良い.

  - ただし,片方の配列が空になった場合には別の処理が必要となる.

#### 2-3. 再帰処理の動作を検証
- ここでは`merge`関数の再帰が正しく機能していることを確認する.

- 入力データは，配列の要素数，一つ目の配列の始まりの位置`from`,一つ目の配列の終わりの位置`mid`, 二つ目の配列の終わりの位置`to`, 配列の要素の順番で与えられるとする．

- 注目する区間`from~to`以外の要素は便宜上全て0で埋めてある.

- 出力を目視で確認すること

  - 例：入力が `6 1 2 4 0 5 7 6 8 0` の時，出力は以下のようになる
    ```
    SORT( 0 :  1)
    SORT( 0 :  0)
    SORT( 1 :  1)
    ```

#### 2-4. 自動採点システムで動作確認


---
### ステップ3/3　「mrg_sort関数とmerge関数を組み合わせる」
---
ここではステップ1/3で再帰機能を実装したmrg_sort関数とステップ2/3で実装したmerge関数を組み合わせることにより、mrg_sort関数を完成させ、仕様を満たすようにプログラムを作成する．

#### 3-1. merge関数をmrg_sort関数に組み込み、ソート機能を完成させる
- 問題文のマージソートの説明の手順3を実装する
  - 3, ソートされた半分の長さの配列に対してmergeを呼び、それらを1つの全体の長さの並べ替えられた配列に結合する．

- 仕様にあるように、mrg_sortの戻り値が要素間の比較comp_の呼び出し回数となるようにする.


#### 3-2. mrg_sort関数の動作を検証
- 仕様にあるように、`print_array_range_`関数を使って値のマージ処理が終わる度に，マージした範囲と配列全体の要素を以下の書式で表示すること．
  - マージした範囲の要素番号$i,j(i<j)$を用いて MERG$(i,j)$ と表示し，空白後に交換後の配列の全要素を表示する．
  - 例：要素番号 2,4の範囲をマージした場合
    ```
    MERG(⊔2,⊔4)⊔**⊔**⊔⊔8⊔⊔4⊔11⊔**⊔**⊔**⊔**⊔**⊔**↩︎
    ```

- 入力データは，1列目が配列の要素数，2列目以降が配列の要素であるとする．

- 出力を目視で確認すること

  - 例：入力が 2 2 1 の時，出力は以下のようになる


#### 3-3. 自動採点システムで動作確認

