---
layout: page
title: 2-3. マージソート【基本】
---


ここでは，<font color="red">分割/統合に基づくソート</font>である<font color="red">マージソート (merge sort)</font>を実装してみよう．

マージソートのアルゴリズムは与えられた配列データを小さな部分配列に分割し，部分配列ごとにソートを行なう分割統治法の代表的アルゴリズムの一つである．
マージソートでは<font color="red">再帰関数</font>を使って効率的にアルゴリズムを構築することを学ぶ．

今回は、補助関数mergeを利用する。 mergeは2つの並べ替えられた配列を受け取り、以下のプロセスで結合する．

- 0, 入力配列の長さの合計に等しい長さの空の出力配列を準備する．
- 1, 各入力配列から出力配列にまだ追加されていない最初の要素を比較し、最小のものを$ m $とする．
- 2, 出力配列の最初の空のスペースに$ m $を追加する．
- 3, 入力配列が両方とも出力配列に完全に追加されていない場合は、（1）に戻る．
- 4, 出力配列にまだ追加されていない入力配列をそのまま出力配列の最後にコピーする．

次に、マージソートは、以下のプロセスに従って、mergeと再帰を使用して入力配列をソートする．

- 0, 入力配列の長さが1の場合、すでに並べ替えられているため、そのまま返す．
- 1, 入力配列の長さが1より大きい場合、入力配列を同じ長さの2つの配列に分割する．
- 2, マージソートを2回呼ぶ。新しく作成された半分の長さの配列のそれぞれに対して1回である．
- 3, ソートされた半分の長さの配列に対してmergeを呼び、それらを1つの全体の長さの並べ替えられた配列に結合する．

![Merge Sort](https://i.imgur.com/KVKxFuE.png)
![Merge Sort](https://i.imgur.com/QQUmTtI.png)

---
## 問題
---
与えられた配列データを<font color="red">マージソート</font>により<font color="red">昇順</font>に並べ替えるプログラムを作成せよ．

---
### 仕様
---

- 今回は、入力配列に同じ値の要素がない

- `#include` していいのは `<stdio.h>`と`“ppa_extra_h/p2_header.h”`のみとする．(“ppa_extra_h/p2_header.h”については下記で説明する。malocを用いないので、<stdlib.h>は必要ない。)

- 関数は全て前方宣言すること．

- 問題2-2と同じく、可変長配列を用いて配列を確保すること．

- マージソートを実行するためには，マージ操作を行う際にデータの配列とは別にマージ用記憶領域が必要となる．
  - データを読み込む配列を動的確保する際に，2倍の領域を確保する．つまりデータの要素数が$N$なら$2N$個のメモリを確保すること．
  - 余計に確保したメモリをマージ用記憶領域として利用すること．つまり，データ配列の値をマージ用記憶領域を含めた$2N$個の記憶域から外に取り出してはいけない．


- 配列操作に利用可能な関数
  - 配列内の要素を配列内の別の場所にコピーする手続きとして`func_copy_val_`関数を用いること．これは，挿入対象の値を退避したり挿入する場合も含まれる．
  - 問題2-2で作成した2つの要素を入れ替える`swap`関数の使用は不可
  - 配列内の二つの要素を比較する手続きとして`comp_`関数を用いること．
  - 配列内のある範囲の要素を表示する手続きとして`print_array_range_`関数を用いること．
  - `print_array_`関数をは用いない

- 配列をマージソートによって並び替える `mrg_sort` 関数を作成すること．また，以下の仕様を満すこと．
  - 配列の要素を並び替える操作は全てこの関数内で行うこと．
    - ただし，この関数内で以下で説明する`merge`関数を呼び出してよい．その際は必ず前方宣言すること．
  - 入力データ用に動的に確保した配列，入力データの個数，mergeの対象となる範囲として始まりの要素番号，終わりの要素番号の4つを引数とすること．
    - 例：
    ```
    int mrg_sort(int *array, int N, int p, int q) ...
    ```
  - 要素間の比較`comp_`の呼び出し回数を`mrg_sort` 関数の戻り値とすること．
  - 配列を分割する際に，奇数で割り切れない場合は，必ず配列の先頭側を一つ多くすること．

- 二つのソート済み配列をマージする`merge`関数を作成すること．また，以下の仕様を満すこと．
  - `mrg_sort`関数内で呼ばれる．
  - 配列の要素をマージする操作は全てこの関数内で行うこと．
    - ただし，この関数内で呼ばれる別の関数を作成してもよい．その際は必ず前方宣言すること．
  - 入力データ用に動的に確保した配列，入力データの個数，mergeの対象となる範囲として始まりの要素番号，終わりの要素番号，中間の要素番号の5つを引数とすること．
    - 例：
    ```
    int merge(int *array, int N, int p, int q, int r) ...
    ```

- 表示
  ```
  void print_array_range_(
      const int* const array,
  　  const int N,
  　  const int p, const int r) {
    int ri = 0;
    for (; ri < N; ++ri) {
      if (ri < p || r < ri) {
        printf(" **");
      } else {
        printf(" %2d", array[ri]);
      }
    }
    printf("\n");
  }
  ```
  - 上の関数を使って値のマージ処理が終わる度に，マージした範囲と配列全体の要素を以下の書式で表示すること．
    - マージした範囲の要素番号$i,j(i<j)$を用いて MERG$(i,j)$ と表示し，空白後に交換後の配列の全要素を表示する．
    - 例：要素番号 2,4の範囲をマージした場合
    ```
    MERG(⊔2,⊔4)⊔**⊔**⊔⊔8⊔⊔4⊔11⊔**⊔**⊔**⊔**⊔**⊔**↩︎
    ```

- 題2-1に提示してある関数と題2-2に提示してある`func_copy_val_`と`print_array_range_`を`ppa_extra_h/p2_header.h`というファイルにおいてある．`#include "ppa_extra_h/p2_header.h"`という宣言を通して含めたら、こちらの関数を書かなくても呼べる：`func_swap_`、`comp_`、`print_array_`、`func_mallocation_`、`func_copy_val_`、`print_array_range_`

- 以下のプログラムを必ず用いてプログラムを完成せること．

```
#include <stdio.h>
#include <stdlib.h>
#include “ppa_extra_h/p2_header.h”

int mrg_sort(int *, int , int , int );
int merge(int *, int , int , int , int );

int main() {

  ...(省略)...

  return 0;
}

int mrg_sort(int* array, int N, int p, int q) {

  ...(省略)...

}

int merge(int* array, int N, int p, int q, int r) {

  ...(省略)...

}
```


---
## 実行例
---
---
### 実行例(1)
---
- 入力データ
```
7 2 1 3 7 4 6 5
```
- 出力例
```
INIT:::::::  2  1  3  7  4  6  5
MERG( 0, 1)  1  2 ** ** ** ** **
MERG( 2, 3) ** **  3  7 ** ** **
MERG( 0, 3)  1  2  3  7 ** ** **
MERG( 4, 5) ** ** ** **  4  6 **
MERG( 4, 6) ** ** ** **  4  5  6
MERG( 0, 6)  1  2  3  4  5  6  7
DONE:::::::  1  2  3  4  5  6  7
13
```


---
### 実行例(2)
---
- 入力データ
```
13 10 2 8 4 11 9 11 5 3 13 1 2 6
```
- 出力例
```
INIT::::::: 10  2  8  4 11  9 11  5  3 13  1  2  6
MERG( 0, 1)  2 10 ** ** ** ** ** ** ** ** ** ** **
MERG( 2, 3) ** **  4  8 ** ** ** ** ** ** ** ** **
MERG( 0, 3)  2  4  8 10 ** ** ** ** ** ** ** ** **
MERG( 4, 5) ** ** ** **  9 11 ** ** ** ** ** ** **
MERG( 4, 6) ** ** ** **  9 11 11 ** ** ** ** ** **
MERG( 0, 6)  2  4  8  9 10 11 11 ** ** ** ** ** **
MERG( 7, 8) ** ** ** ** ** ** **  3  5 ** ** ** **
MERG( 7, 9) ** ** ** ** ** ** **  3  5 13 ** ** **
MERG(10,11) ** ** ** ** ** ** ** ** ** **  1  2 **
MERG(10,12) ** ** ** ** ** ** ** ** ** **  1  2  6
MERG( 7,12) ** ** ** ** ** ** **  1  2  3  5  6 13
MERG( 0,12)  1  2  2  3  4  5  6  8  9 10 11 11 13
DONE:::::::  1  2  2  3  4  5  6  8  9 10 11 11 13
36
```



---
### ステップに分けてプログラミング
---
この問題では，「mrg_sort関数における再帰処理の実装」「merge関数の実装」「mgr_sort関数とmerge関数を組み合わせる」の3ステップに分けてプログラミングしてもらう．ステップごとに"動作確認"に成功しなければ，"TAに提出"が出来ないようになっている．以下では，各ステップをさらに細分化して説明する．

---
### ステップ1/3　「mrg_sort関数における再帰処理の実装」
---
ここでは、merge関数の実装は忘れて、mrg_sort関数の再帰機能のみを実装しよう。
mrg_sort関数の再帰機能のみを実装する。これは問題文のマージソートの説明において、手順3以外の手順を実装するということである。
  - 0, 入力配列の長さが1の場合、すでに並べ替えられているため、そのまま返す．
  - 1, 入力配列の長さが1より大きい場合、入力配列を同じ長さの2つの配列に分割する．
  - 2, マージソートを2回呼ぶ。新しく作成された半分の長さの配列のそれぞれに対して1回である．

#### 1-1. 準備
- これまでの問題と同様に，まず，確実に必要と思われるC言語のメインの構造を作る．

#### 1-2. 標準入力から配列とその長さを読み込む
- 問題2-2と同じく、可変長配列を用いて標準入力から長さNの配列を読み込む

- 問題2-2で作成したprint_array関数により、入力が正しく読み込めているか確認する
 
- 長さ$ n $の入力配列に対して、範囲0~n-1においてmrg_sort関数を実行する(mrg_sort関数の中身は1-3以降で作成する)

  ```
    int main(){
      int n;             // 配列の要素数
      scanf("%d", &n)    // nを標準入力
      int data[n];       // 配列を宣言
      mrg_sort(data,n, 0 n-1);
      return 0;
  }
  ```

#### 1-3. 配列を前半と後半に分けて、それぞれでmrg_sort関数を再帰的に呼び出すように実装
- 配列を前半と後半に分け、それぞれでmrg_sort関数を再帰的に呼び出すように実装し、最終的に長さ1のmrg_sort関数になるまで分割を行う。

- 例：長さ$ n $の配列において、範囲0~3のマージを呼び出すということは、範囲0~1のマージソートと範囲2~3のマージソートをそれぞれ呼び出すということである。これを再帰を用いて簡略化した表現すると次のようになる。

  ```
  void mrg_sort(int* array, int n, int 0, int 3){
    mrg_sort(array,n,0,1);
    mrg_sort(array,n,2,3);
  }
  ```

- 上記を参考にして、任意の範囲でmrg_sort関数を再帰的に呼び出すように実装せよ。ただし、仕様にも記載されているように、配列を分割する際に，奇数で割り切れない場合は，必ず配列の先頭側を一つ多くなるようにすること．

  ```
  void mrg_sort(int* array, int n, int from, int to){
    mrg_sort(array,???,???,???);
    mrg_sort(array,???,???,???);
  }
  ```

- また、長さが1になった時には、処理が終了しなければならない。
  ```
  return 0;
  ```


#### 1-4. 再帰処理の動作を検証
- ここではmrg_sort関数の再帰が正しく機能していることを確認するために、mrg_sort関数を呼び出すたびにmrg_sort関数の最初に自分自身の名前を出力させるようにしておく。

  ```
  void mrg_sort(int* array, int n, int from, int to){
    printf("SORT(%2d : %2d)\n", from , to);
    ???
  }
  ```
- 例：入力が 2 1 2 の時，出力は以下のようになる
  ```
  SORT( 0 :  1)
  SORT( 0 :  0)
  SORT( 1 :  1)
  ```

- 例：入力が 8 1 2 3 4 5 6 7 の時，出力は以下のようになる
  ```
  SORT( 0 :  7)
  SORT( 0 :  3)
  SORT( 0 :  1)
  SORT( 0 :  0)
  SORT( 1 :  1)
  SORT( 2 :  3)
  SORT( 2 :  2)
  SORT( 3 :  3)
  SORT( 4 :  7)
  SORT( 4 :  5)
  SORT( 4 :  4)
  SORT( 5 :  5)
  SORT( 6 :  7)
  SORT( 6 :  6)
  SORT( 7 :  7)
  ```

#### 1-5. 自動採点システムで動作確認


---
### ステップ2/3　「merge関数の実装」
---
ステップ1/3では再帰により、mrg_sort関数をそれぞれ長さ$ 1 $のmrg_sort関数になるまで分割を行った。このステップでは分割したmrg_sort関数をマージ(統合)する補助関数mergeを実装する。
問題文の説明のように、補助関数mergeはソートされた二つの配列を統合することにより、ソートされた一つの配列を作り出すものである。．

- 0, 入力配列の長さの合計に等しい長さの空の出力配列を準備する．
- 1, 各入力配列から出力配列にまだ追加されていない最初の要素を比較し、最小のものを$ m $とする．
- 2, 出力配列の最初の空のスペースに$ m $を追加する．
- 3, 入力配列が両方とも出力配列に完全に追加されていない場合は、（1）に戻る．
- 4, 出力配列にまだ追加されていない入力配列をそのまま出力配列の最後にコピーする．

#### 2-1. 準備
- ステップ1/3のmrg_sort関数の実行部分はこのステップでは使用しないのでコメントアウトする．

- 長さ$ n$ の入力配列に対して、仕様にも書いてるように、マージ操作を行う際にデータの配列とは別にマージ用記憶領域が必要となるため、長さ$ 2n $の配列を用意する。

- 入力配列の読み込みは$ 0~n-1 $の範囲で行う。

#### 2-2. ソートされた二つの配列をソートされた一つの配列にマージする補助関数mergeを実装
- 二つのソートされた配列が与えられた時に、それぞれの先頭の要素から順番に比較を行い、ソートされた一つの配列を作成する。

- ここでは、mrg_sort関数への適用を見据えて、二つのソートされた配列が一つの配列に格納されているとする。

- 例えば、ソートされた長さ2の配列 1 3 と長さ2の配列 2 4 が一つの配列に 1 3 2 4 として入力配列が与えられている場合を考えよ。

- このとき、区間0~3にある 1 3 2 4 からマージ用記憶領域（区間4~7）にソートされた配列を 1 2 3 4 を作り出すようにmerge関数を作成する

- 最後に、マージ用記憶領域(区間4~7)にあるソートされた配列を元の領域(0~3)にコピーする。

- 仕様に記載されているように、配列内の二つの要素を比較するためには、comp_関数を用いれば良く、配列内の要素を配列内の別の場所にコピーするためには、func_copy_val_関数を用いれば良い。

- ただし、片方の配列が空になった場合には場合分け処理が必要となる。

- 再帰処理を適切に行うためには、マージが完了した後に、マージ用記憶領域に保存されているソートされた配列を、元の二つの配列が記憶されていた場所にコピーする必要がある。

- テストケースとしては、二つのソートされた配列が一つの配列として与えられる。このとき、二つの配列の始まりと終わりも入力として与えられている。なお、配列以外の場所は便宜上0を全て埋めている。

- merge関数は連続して並んでいる二つの配列を統合する関数なので、from,mid,toの三つの値が分かれば、十分である。

- マージ用記憶領域にソートされた配列を作成した後は、この要素の値を元の領域(0~N-1)にコピーする。これにより、元の場所にソートされた配列が作成される



---
### ステップ3/3　「mgr_sort関数とmerge関数を組み合わせる」
---
ここではステップ1/3で再帰機能を実装したmrg_sort関数とステップ2/3で実装したmerge関数を組み合わせることにより、mrg_sort関数を完成させ、仕様を満たすようにプログラムを作成する．

#### 3-1. 準備

- 問題文のマージソートの説明の手順3を実装する
  - 3, ソートされた半分の長さの配列に対してmergeを呼び、それらを1つの全体の長さの並べ替えられた配列に結合する．

- ただし、仕様にあるように、mrg_sortの戻り値は要素間の比較comp_の呼び出し回数となるように、merge関数とmrg_sort関数を修正する必要がある。


