---
layout: page
title: 2-5. ポインタ、アドレス、動的メモリ確保【基本】
---

この問題では，これまで使っていた配列である<font color="red">可変長配列（Variable-Length Array; VLA）</font>に代わり，課題３以降で用いる<font color="red">動的メモリ確保（Dynamic Memory Allocation; DMA）</font>された配列を取り扱う．
また，動的メモリ確保に関連して，C言語を使う上で避けては通れない<font color="red">ポインタ</font>と<font color="red">アドレス</font>について解説する．途中途中でサンプルコードを載せるので，各自，実行して動作を理解すること．本番の問題文は後半にあるが，前半を読み飛ばさないように．

---
## ポインタとアドレス
---
&
[]
sizeof
アドレス取得
ポインタがさす変数の取得
ポインタへの代入
ポインタがさす変数への代入
```
printf("%x\n", p); // 16進数で表示
printf("%o\n", p); // 8進数で表示
printf("%u\n", p); // 10進数で表示
```

---
## 値渡しとアドレス渡し
---

C言語では関数を呼び出す際，呼び出し側で渡した変数の中身（値）が，呼び出された関数側の変数にコピーされる：
```
...
  int a = 10;
  test(a);
...
void test(int b){
  printf("%d\n", b); // bには呼び出し元のaの値が入っている
  b = 300; // bとaはアドレスが異なる別々の変数なので，呼び出し元のaには値が代入されない（できない）
}
```
これを<font color="red">値渡し</font>と呼ぶ．

一方，関数の引数をポインタ変数にすると，呼び出し側では変数のアドレスを渡すことができ，呼び出された関数側のポインタ変数にコピーされるため，関数内でそのアドレスが指す変数の更新が可能になる：
```
...
  int a = 10;
  test(&a);
...
void test(int *b){
  printf("%d\n", *b); // bには呼び出し元のaの値が入っている
  *b = 300; // bとaはアドレスが異なる別々の変数なので，呼び出し元のaには値が代入されない（できない）
}
```
これを<font color="red">アドレス渡し</font>と呼ぶ．`scanf`関数で変数のアドレスを渡すのは，入力された値を，関数内で（そのアドレスが指す）変数に代入する必要があるからである．関数から複数の返り値を返したい場合，ポインタ変数を引数に渡し，返り値を代入することで返す（C言語では複数返り値はサポートされていない）．

以下のコードを実行し，値渡し（"pass by value"）とアドレス渡し（"pass by address"）の違いを確認せよ．

```
#include <stdio.h>

void pass_by_value(int x){
  printf("In pass_by_value: %d\n", x);
  x = 10;
}
void pass_by_address(int *ptr_x){
  printf("In pass_by_address: %d\n", *ptr_x);
  *ptr_x = 10;
}

int main(){
  int a = 0;

  pass_by_value(a);
  printf("After pass_by_value: %d\n", a);

  pass_by_address(&a);
  printf("After pass_by_address: %d\n", a);

  return 0;
}
```

---
## 配列とポインタ
---
p2-4などでは，関数に配列を渡す際に`void test(int array[], int n)`のような書き方をしていた．これは実は配列`array[]`の要素全てを渡しているのではなく，配列の先頭のアドレスが入っているポインタ変数`array`を渡しており，`void test(int *array, int n)`と等価である．配列はメモリ上の連続した領域に割り当てられるため，配列の`i`番目の要素`array[i]`へのアクセスは，内部ではアドレス`*array+i*sizeof(配列の型)`を参照することで実現している．（配列の値渡しがない理由は[こちら](#array_pass_by_value)）

以下のコードを実行し，配列の先頭アドレスを関数に渡しても，通常の配列のように`a[i]`のようなアクセスが可能であることを確認せよ．

```
#include <stdio.h>

void print_array(int *array, int n);

int main(){
  int n = 10;
  int a[n];
  
  for(int i=0; i<n; i++) a[i] = i;
  print_array(a, n);
  
  return 0;
}

void print_array(int *array, int n){
  for(int i=0; i<n; i++) printf("%d ", array[i]);
  printf("\n");
}

```

---
## 動的メモリ確保／解放
---
これまで配列は，`int array[10];`のようにあらかじめ大きさを指定するか，
```
int n;
scanf("%d", &n);
int array[n];
```
のように書いて，入力に応じて配列の大きさを決めていた．後者は可変長配列（Variable-Length Array; VLA）と呼ばれ，便利な機能である．一方で，C言語の可変長配列は`n`が大きすぎると[メモリが確保できず](#memory_size)，また確保されなかったことも分からないため，プログラムが予期せぬ動作をする恐れがある．安全に配列を確保するためには，以下のように`malloc`関数を用いた動的メモリ確保と`free`関数を用いたメモリ解放を行う：
```
#include <stdio.h>
#include <stdlib.h> // malloc, free, exit関数を使うためにインクルード

int main(){
  int *array, n;
  
  scanf("%d", &n);
  
  // (1) メモリを動的確保
  array = (int*)malloc(sizeof(int)*n);
  
  // (2) 確保失敗時のエラー処理
  if( array == (int*)NULL ){ // アドレスとしてNULLが返ってきた場合，メモリ確保に失敗している
    fprintf(stderr, "Cannot allocate \n"); // エラー出力
    exit(1);  // プログラムを強制終了する
  }
  
  // (3) 配列を使用
  ...(省略)...
  
  // (4) メモリ解放
  free(array);
  
  return 0;
}
```
動的メモリ確保に関連して４つの部分から成っている：
- (1)`malloc`

- (2) `NULL`ポインタ`exit(1)`

- (3) その配列を使う部分．途中で`return`文で関数を抜けてしまうと(4)が実行されないため，注意が必要である．

- (4) freeしないと，そのメモリ領域は再利用できずに残ってしまうため，メモリ容量を圧迫してしまう．

---
## 可変長配列 vs 動的メモリ確保
---
可変長配列と動的メモリ確保した配列の特徴を比較した表を以下に示す．

<img src="p25-VLA-vs-DMA.png" width="650px">

<span style="font-size: 85%;">※実行環境…コンパイラ・OS・シェル・物理メモリ量など．バージョンも含む．</span>

<span style="font-size: 85%;">※スコープ…変数の有効範囲（利用可能範囲）のこと．</span>

表の"利用可能スコープ"に関して，VLAを使うと関数の呼び出し側では配列が意図通りに動作しないことを確認せよ（`n`の値を4~40の間で変更すると，挙動が変わる）．
```
#include <stdio.h>
#include <stdlib.h>

int* array_allocation_by_VLA(int n);
int* array_allocation_by_DMA(int n);

int main(){
  int *a;
  int n = 40;
  
  a = array_allocation_by_DMA(n);
  for(int i=0; i<n; i++) printf("%d ", a[i]);
  printf("\n");
  for(int i=0; i<n; i++) a[i] = i;
  for(int i=0; i<n; i++) printf("%d ", a[i]);
  printf("\n");
  
  free(a);
  
  a = array_allocation_by_VLA(n);
  for(int i=0; i<n; i++) printf("%d ", a[i]);
  printf("\n");
  for(int i=0; i<n; i++) a[i] = i;
  for(int i=0; i<n; i++) printf("%d ", a[i]);
  printf("\n");
  
  return 0;
}

int* array_allocation_by_VLA(int n){
  int a[n];
  
  for(int i=0; i<n; i++) a[i] = 0;
  
  return a;
}

int* array_allocation_by_DMA(int n){
  int *a;
  
  a = (int*)malloc(sizeof(int)*n);
  
  for(int i=0; i<n; i++) a[i] = 0;
  
  return a;
}
```

---
## 問題
---

---
### 仕様
---

- 

- 

- 

- 

```
#include <stdio.h>
#include <stdlib.h>


  ...(省略)...
```


---
## 実行例
---
---
### 実行例
---
- 入力データ
```
```
- 出力例
```

```

---
## 参考情報
---
### 配列の値渡しができない理由<a name="array_pass_by_value"></a>
---
"配列の値渡し"がC言語でサポートされていないのは，値渡しでは変数をコピーするため，サイズが大きい配列を値渡しできてしまうと，メモリを浪費し，なおかつコピーする時間がかかることが理由である．

---
### 可変長配列と動的メモリ確保の上限<a name="memory_size"></a>
---
可変長配列と動的メモリ確保で扱える配列の大きさの上限は実行環境依存であるので，特に可変長配列を使う際には必ず確認する必要があるが，"一般的"な環境では1kB程度であれば問題なく使えるはずである．

「プログラミング演習A」では，"サンドボックス"と呼ばれる，外部プログラムを安全にサーバ上で実行するための環境を用いている．そのため，プログラムを実行して可変長配列と動的メモリ確保の上限を確認することはできない．余裕があれば，自分のPCでC言語をコンパイル／実行できる環境を整えて確かめてみよう．

---
### 動的メモリ確保に関する補足<a name="dynamic_memory_allocation"></a>
---
可変長配列と動的メモリ確保の違いを理解するには，プログラムがハードウェア上でどのように動作するか，特に"ヒープ領域"，"スタック領域"について理解する必要があるが，この授業は「プログラミング演習」であるので，詳細には立ち入らない．

C言語は"ハードウェアを意識したプログラミング"ができる／しなくてはいけない言語で，メモリ容量制限がシビアな場合，リアルタイム処理が必要な場合などに適している．一方で，プログラムが大規模・多機能になると，"ハードウェアを意識しないプログラミング"の方がバグ／セキュリティホールを生じにくい，開発スピードが速いなどのメリットがある．そのようなプログラミングができる言語としては，C++，Java，Pythonがある．用途・実行環境に応じて適切な言語を選ぶ，あるいは複数言語を使い分けることが重要である．
