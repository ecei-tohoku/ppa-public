---
layout: page
title: 2-5. マージソート【10点】
---

## 問題
リダイレクション '<' を用いて標準入力の入力元をデータファイルに切り替えることで配列データを読み込み，読み込まれた配列データをマージソートによって<font color="red">昇順</font>に並べ替えるプログラムを作成せよ．ただし，以下の仕様を満たすこと．

- データファイルの内容は，以下の通りである．
  - データファイルの 1 行目に，ソートすべきデータの個数 $n$ が記載されている．なお，$n$ の値は 2 のべき乗である．
  - データファイルの 2 行目に，ソートすべき $n$ 個のデータが半角スペースで区切られて記載されている．なお，すべてのデータの値は，`int` 型で収まる範囲内の正の整数である．
- `main` 関数内で，データファイルを読み込む．
  - ソートする $n$ 個のデータを読み込む際には，データの格納に必要なメモリ領域を動的に確保すること．また，確保したメモリ領域を，プログラム終了時に解放すること．
- 入力された $n$ 個の配列データに対し，マージソートのアルゴリズムを適用する `mergesort` 関数を作成する．
  - 配列データをソートする際，比較回数（配列データに対して実行される２つの数の大きさを比較した回数）を数えること．ただし，計測結果を `mergesort` 関数内で表示してはいけない．
  - ソート後の配列データを `mergesort` 関数内で表示してはいけない．
  - グローバル変数および静的変数を使用してはいけない．
  - `mergesort` 関数の作成においては，下に示す【マージソートのアルゴリズム】の擬似コードを参考のこと．
  - 再帰呼び出しを用いること．
  - マージソートの実行にあたり，必要があれば配列データのメモリ領域を動的に確保すること．確保されたメモリ領域については，所望の処理が完了した後に適宜解放すること．
  - ソート後の配列データと比較回数の計測結果とを `main` 関数内で標準出力に書き出し，プログラムを終了する．
  - まず，ソート後の配列データを出力し，その後，比較回数の計測結果を出力すること．
  - ソート後の配列データを表示する際には，配列の各要素を半角スペースで区切って表示すること．

## 実行例
入力されるデータファイル ([sortdata.txt](./sortdata.txt)) の例

```
8
2 4 3 1 8 7 6 5
```

リダイレクション '<' を用いて `sortdata.txt` の内容を標準入力から読み込む．

```
$ ./a.out < sortdata.txt
```

`sortdata.txt` に対する実行結果の例（`>` は標準出力を示し，`⊔` は半角スペースを示す．）

```
> 1⊔2⊔3⊔4⊔5⊔6⊔7⊔8
> 13
```

## マージソートのアルゴリズム
以下のプログラムでは，`mergesort` 関数において，2 つの配列をマージするための関数 `merge` を呼び出していることに注意されたい．つまり，`mergesort` 関数だけでなく `merge` 関数も作成する必要がある．なお[問題2-2](p22.html "問題2-2") と同様に，各自でプログラムを作成する際には，下記の 2 つの関数の形式（引数と戻り値の与え方）を自由に変更してよい．

再帰呼び出しを用いたマージソート関数の例（擬似コード）

```c
/* 部分配列 data[ p ]～data[ r - 1 ] をソートする */
mergesort ( data, p, r )
1 if p + 1 < r
2   q = ( p + r ) / 2
3   mergesort ( data, p, q )
4   mergesort ( data, q, r )
5   merge ( data, p, q, r )
```

部分配列をマージする関数の例（擬似コード）

```c
/* 部分配列 data[ p ]～data[ q - 1 ] と data[ q ]～data[ r - 1 ] をマージする */
merge ( data, p, q, r )
 1 let n1 = q - p and n2 = r - q
 2 let L[ n1 ] and R[ n2 ] be new arrays
 3 for i = 0 to n1-1
 4   L[ i ] = data[ p + i ]
 5 for i = 0 to n2-1
 6   R[ i ] = data[ q + i ]
 7 let i = 0, j = 0 and k = p
 8 while ( i < n1 and j < n2 )
 9   if L[ i ] < R[ j ] then
10     data[ k ] = L [ i ]
11     i = i + 1 and k = k + 1
12   else
13     data[ k ] = R [ j ]
14     j = j + 1 and k = k + 1
15 if i < n1 then
16   copy L[ i ]～L[ n1-1 ] to data[ k ]～data[ r - 1 ]
17 else
18   copy R[ j ]～R[ n2-1 ] to data[ k ]～data[ r - 1 ]
```
