---
layout: page
title: 5-1. 選択ソート【初歩】
---


ここでは，もっともシンプルなソートアルゴリズムのひとつである <font color="red">選択ソート (selection sort)</font> を実装しよう．

まず，ソートには昇順（小さい方から大きい方へ）と降順（大きい方から小さい方へ）の通常二パターンが考えられるが，本課題では，簡単のため<font color="red">昇順</font>の場合のみを考える．以降，断りなく単に「ソート」と記載があった場合には，昇順ソートのこととする．

選択ソートの基本操作は，「<font color="red">ソートされていない要素</font>から最も小さい値を見つけ出す」である．
また，見つけた最小値を取り除き，同じ手順を行えば，2番目に小さい値，3番目に小さい値，と順番に抽出することができる．
よって，その時点での最小値を取得したら，それを，配列の先頭から並べていけばソートが完成する．という仕組みである．
直感的にもわかりやすいアルゴリズムと言える．

しかし，これを実際にプログラムで実装するためには，いろいろ考えることがある．
もうすこし具体的な処理手順としては以下のようになる．

1. 配列全体から，もっとも値の小さいデータを探し，配列の先頭(1番目)の要素と交換する．
2. 1番目の要素を除き，配列の<font color="red">残りのデータ</font>の中から，もっとも値の小さいデータ（全体で2番目に値の小さいデータ）を探し，配列の先頭から2番の要素と交換する．
3. 1,2番目の要素を除き，配列の<font color="red">残りのデータ</font>の中から，もっとも値の小さいデータ（全体で3番目に値の小さいデータ）を探し，配列の手前から3番目の要素と交換する．
4. 以下同様

次の図は、最初のステップで、もっとも値の小さいデータ (1) を見つけて、配列xの最初の先頭と交換する方法を示している.

![Select Sort](https://i.imgur.com/4amLHf9.png)

次の図は、アルゴリズムの各反復i後の配列xの状態を示している. 各反復に必要な比較の数に特に注意.

![Select Sort](https://i.imgur.com/ZurtE8b.png)

---
## 問題
---
与えられた配列データを<font color="red">選択ソート</font>により<font color="red">昇順</font>に並べ替えるプログラムを作成せよ．
なお入力データは，1列目が配列の要素数，2列目以降が配列の要素であるとする．
- 入力データの例
  ```
  5 1 2 3 4 5
  ```

---
### 仕様
---
- `#include` していいのは `<stdio.h>`のみとする．

- 関数は全て前方宣言すること．前方宣言とは，その関数が使われる前に宣言しておくことを指し，通常は`main`関数の前に宣言する．

- グローバル変数や静的変数を使用しないこと．

- 可変長配列を用いて配列を確保すること．可変長配列については，ステップ1/3で説明する．

- 配列を選択ソートによって並べ替えるvoid型の `sel_sort` 関数を作成すること．また，以下の仕様を満すこと．
  - 配列の要素を並べ替える操作は全てこの関数内で行うこと．
  - 入力データと配列と入力データの個数の二つを引数とすること．
    - 例：
    ```
    void sel_sort(int array[], int N) ...
    ```
  - 関数内で要素間の比較回数を数えること．

- 配列を出力するvoid型の `print_array` 関数を作成すること．また，以下の仕様を満すこと．
  - `sel_sort`関数と同様に，入力データと配列と入力データの個数の二つを引数とすること．
  - 配列の各要素の出力は4桁とし，要素1つを出力後にカンマと空白を加えること．
  - 配列の最後の要素の出力後はカンマも空白も加えず，改行せよ．
  - 例：
    ```
    ⊔⊔⊔6,⊔⊔⊔⊔2,⊔⊔⊔11,⊔⊔⊔⊔9,⊔⊔⊔12,⊔⊔⊔13,⊔⊔⊔⊔1,⊔⊔⊔10↩︎
    ```

- 2つの要素を入れ替える`swap` 関数を作成すること．また，以下の仕様を満すこと．
  - 入力データと入れ替える配列の要素番号$x$と$y$の三つを引数とすること．
    - 例：
    ```
    void swap(int array[], int x, int y) ...
    ```

- 表示
  - 配列を入力後，INIT. ARRAY : と表示し，その後入力した配列を`print_array` 関数を用いて出力すること
    - 例：
    ```
    INIT.⊔ARRAY⊔:⊔⊔⊔⊔6,⊔⊔⊔⊔2,⊔⊔⊔11,⊔⊔⊔⊔9,⊔⊔⊔12,⊔⊔⊔13,⊔⊔⊔⊔1,⊔⊔⊔10↩︎
    ```
  - 配列の$i$番目の要素に対し，以下の書式で表示すること
    - 配列の$i$番目の要素と最小値の要素$j$を用いて SWAP$(i,j)$ : と表示後に，交換後の配列の全要素を`print_array` 関数を用いて表示する．
    SWAP$(i,j)$の$i$と$j$は2桁で表示する．交換が起こらなかった場合は，SWAP$(i,i)$を表示する．
        - 例1：要素番号0,6の要素を交換した場合
	    ```
	    SWAP(⊔0,⊔6)⊔:⊔⊔⊔⊔1,⊔⊔⊔⊔2,⊔⊔⊔11,⊔⊔⊔⊔9,⊔⊔⊔12,⊔⊔⊔13,⊔⊔⊔⊔6,⊔⊔⊔10↩︎
	    ```
    	- 例2：$i=0$の時に交換が起こらなかった場合
	    ```
	    SWAP(⊔0,⊔0)⊔:⊔⊔⊔⊔1,⊔⊔⊔⊔1,⊔⊔⊔⊔1,⊔⊔⊔⊔1,⊔⊔⊔⊔1,⊔⊔⊔⊔1,⊔⊔⊔⊔⊔1,⊔⊔⊔⊔1↩︎
	     ```
    - 配列の要素数が$N$の場合，この表示を$N-1$回繰り返せ
  - 配列の並べ替えが完了したら，comp = と表示し，比較回数を表示して改行せよ
    - 例
    ```
    comp⊔=⊔28↩︎
    ```

  - 全体的な出力例は以下の3-5の実行例を参照せよ．



---
### ステップに分けてプログラミング
---
この問題では，「配列全体から最小値を検索し，それを左に移動させる」「残りの配列データに対して最小値探索を繰り返す」「関数を用いて選択ソートを作成する」の3ステップに分けてプログラミングしてもらう．ステップごとに"動作確認"に成功しなければ，"TAに提出"が出来ないようになっている．以下では，各ステップをさらに細分化して説明する．
なお，ステップ1/3と2/3では`main` 関数内で実装すること．

---
### ステップ1/3　「配列全体から最小値を検索し，それを左に移動させる」
---
ここでは，配列全体から最小値を検索し，配列の先頭の要素と入れ替える部分を実装する．

#### 1-1. 準備
- これまでの問題と同様に，まず，確実に必要と思われるC言語のメインの構造を作る．

#### 1-2. 適当な配列を用意
- 標準入力から読み込むのではなく，まずは適当な配列を`main` 関数内で用意する．

#### 1-3. 2つの要素を入れ替える部分を実装
- 配列の0番目と1番目の要素を入れ替え，結果を標準出力して（自動採点システムではなく）目視で確認する．

#### 1-4. 配列全体の最小値を見つけ，配列の先頭と最小値の位置を交換する
- 結果を標準出力して目視で確認する．

#### 1-5. 標準出力の部分を実装する．
- `main` 関数内で標準出力を行う．ステップ1/3では，以下の仕様とする．
  - 要素の出力形式は"%d"で良い．
  - 要素1つを出力後にカンマと空白を加えること．
  - 配列の最後の要素の出力にもカンマと空白を加え，改行せよ．
- 入力した配列を上記の形式で出力せよ．
- 2つの要素を入れ替えた後の配列を上記の形式で出力せよ．
- 比較を行うたびに，比較回数$N_{comp}$と最小値$datamin$を出力し，改行せよ．出力形式は，以下のとおりとする．
  - 例：$N_{comp}$=10，$datamin$=1の時
    ```
	comp⊔=⊔10,⊔min⊔=⊔1↩︎
    ```

- 例：入力が16 74 93 26 48 65 47 38 46 59 20 93 72 39 58 3 9の時，出力は以下のようになる．
  ```
  74, 93, 26, 48, 65, 47, 38, 46, 59, 20, 93, 72, 39, 58, 3, 9, 
  comp = 1, min = 74
  comp = 2, min = 26
  comp = 3, min = 26
  comp = 4, min = 26
  comp = 5, min = 26
  comp = 6, min = 26
  comp = 7, min = 26
  comp = 8, min = 26
  comp = 9, min = 20
  comp = 10, min = 20
  comp = 11, min = 20
  comp = 12, min = 20
  comp = 13, min = 20
  comp = 14, min = 3
  comp = 15, min = 3
  3, 93, 26, 48, 65, 47, 38, 46, 59, 20, 93, 72, 39, 58, 74, 9, 
  ```

#### 1-6. 配列の要素数と配列データを標準入力する
- 1-2で用意した配列はコメントアウトする．

- 自動採点システムに用意したテストケースでは，配列の要素数がテストケースごとに異なる．このため，配列の要素数をテストケースごとに宣言する必要がある．問題5-1〜5-3では，「可変長配列」を用いて配列の要素数を宣言する．可変長配列では，以下の例のように，配列を宣言するときの要素数を変数にできる．
    - 例：
    ```
    int main(){
      int n;             // 配列の要素数
      scanf("%d", &n);    // nを標準入力
      int data[n];       // 配列を宣言
      data[0] = 1;       // 0番目の要素を入力
      data[1] = 2;       // 1番目の要素を入力
      printf("%d %d\n", data[0], data[1]);	// dataを標準出力
      return 0;
    }
    ```

#### 1-7. 自動採点システムで動作確認


---
### ステップ2/3　「残りの配列データに対して最小値探索を繰り返す」
---
ここでは，ステップ1/3の最小値の検索を，残りの配列データに対して行う部分を実装する．

#### 2-1. 準備

- ステップ1/3の1-5における，比較を行うたびに出力する部分（`comp⊔=⊔10,⊔min⊔=⊔1↩︎`）は使用しないので，コメントアウトする．

- 必要に応じて，標準入力の部分はコメントアウトし，1-2で用意した配列を用いてプログラムの確認を行う．

#### 2-2. 配列の先頭の要素を除いた残りの配列データの最小値検索

- ステップ1/3の1-4のプログラムと1-5の入れ替え後の配列を標準出力する部分をコピーし，配列の先頭の要素を入れ替え後の標準出力する部分の下側に貼り付ける．

- 貼り付けたものを用いて，配列の先頭の要素を除いた残りの配列データの最小値検索を行うプログラムを実装する．

#### 2-3. 2-2を残りの配列に対して繰り返す

- 比較回数も数え，最後に標準出力する．出力の仕方は以下の通り．
    ```
    comp⊔=⊔28↩︎
    ```

- 結果を目視で確認する．
    - 実行例：16 74 93 26 48 65 47 38 46 59 20 93 72 39 58 3 9の場合
    ```
    74, 93, 26, 48, 65, 47, 38, 46, 59, 20, 93, 72, 39, 58, 3, 9, 
    3, 93, 26, 48, 65, 47, 38, 46, 59, 20, 93, 72, 39, 58, 74, 9, 
    3, 9, 26, 48, 65, 47, 38, 46, 59, 20, 93, 72, 39, 58, 74, 93, 
    3, 9, 20, 48, 65, 47, 38, 46, 59, 26, 93, 72, 39, 58, 74, 93, 
    3, 9, 20, 26, 65, 47, 38, 46, 59, 48, 93, 72, 39, 58, 74, 93, 
    3, 9, 20, 26, 38, 47, 65, 46, 59, 48, 93, 72, 39, 58, 74, 93, 
    3, 9, 20, 26, 38, 39, 65, 46, 59, 48, 93, 72, 47, 58, 74, 93, 
    3, 9, 20, 26, 38, 39, 46, 65, 59, 48, 93, 72, 47, 58, 74, 93, 
    3, 9, 20, 26, 38, 39, 46, 47, 59, 48, 93, 72, 65, 58, 74, 93, 
    3, 9, 20, 26, 38, 39, 46, 47, 48, 59, 93, 72, 65, 58, 74, 93, 
    3, 9, 20, 26, 38, 39, 46, 47, 48, 58, 93, 72, 65, 59, 74, 93, 
    3, 9, 20, 26, 38, 39, 46, 47, 48, 58, 59, 72, 65, 93, 74, 93, 
    3, 9, 20, 26, 38, 39, 46, 47, 48, 58, 59, 65, 72, 93, 74, 93, 
    3, 9, 20, 26, 38, 39, 46, 47, 48, 58, 59, 65, 72, 93, 74, 93, 
    3, 9, 20, 26, 38, 39, 46, 47, 48, 58, 59, 65, 72, 74, 93, 93, 
    3, 9, 20, 26, 38, 39, 46, 47, 48, 58, 59, 65, 72, 74, 93, 93, 
    comp = 120
    ```

#### 2-4. 全ての探索処理をループで表す

#### 2-5. 自動採点システムで動作確認

- 標準入力の部分をコメントアウトした場合には，動作確認の前に元に戻す．

---
### ステップ3/3　「関数を用いて選択ソートを作成する」
---
ここでは，これまでに実装した部分のいくつかを関数化し，仕様を満たすようにプログラムを作成する．

#### 3-1. 準備
- ステップ2/3で実装した標準出力の部分を，コメントアウトする．

- 必要に応じて，標準入力の部分はコメントアウトし，1-2で用意した配列を用いてプログラムの確認を行う．

#### 3-2. `print_array` 関数の作成
- 仕様を満たすように作成すること（ステップ1/3と2/3とは仕様が異なるので注意すること）．

- 出力を目視で確認すること

#### 3-3. 入力データの出力部分の作成

- `print_array` 関数を用いて，仕様を満たすように作成すること．

- 出力を目視で確認すること

#### 3-4. `swap` 関数の作成
- 出力を目視で確認すること

#### 3-5. `sel_sort` 関数の作成

- ステップ2/3で作成した最小値探索を行う部分を用いて，`sel_sort` 関数を作成

- 表示の仕様を満たすように，SWAPと表示する部分を作成．

- 比較回数もこの関数内で標準出力する．出力の仕方は2-3と同じ．

- 出力を目視で確認すること

    - 実行例：16 74 93 26 48 65 47 38 46 59 20 93 72 39 58 3 9の場合
    ```
    INIT. ARRAY :   74,   93,   26,   48,   65,   47,   38,   46,   59,   20,   93,   72,   39,   58,    3,    9
    SWAP( 0,14) :    3,   93,   26,   48,   65,   47,   38,   46,   59,   20,   93,   72,   39,   58,   74,    9
    SWAP( 1,15) :    3,    9,   26,   48,   65,   47,   38,   46,   59,   20,   93,   72,   39,   58,   74,   93
    SWAP( 2, 9) :    3,    9,   20,   48,   65,   47,   38,   46,   59,   26,   93,   72,   39,   58,   74,   93
    SWAP( 3, 9) :    3,    9,   20,   26,   65,   47,   38,   46,   59,   48,   93,   72,   39,   58,   74,   93
    SWAP( 4, 6) :    3,    9,   20,   26,   38,   47,   65,   46,   59,   48,   93,   72,   39,   58,   74,   93
    SWAP( 5,12) :    3,    9,   20,   26,   38,   39,   65,   46,   59,   48,   93,   72,   47,   58,   74,   93
    SWAP( 6, 7) :    3,    9,   20,   26,   38,   39,   46,   65,   59,   48,   93,   72,   47,   58,   74,   93
    SWAP( 7,12) :    3,    9,   20,   26,   38,   39,   46,   47,   59,   48,   93,   72,   65,   58,   74,   93
    SWAP( 8, 9) :    3,    9,   20,   26,   38,   39,   46,   47,   48,   59,   93,   72,   65,   58,   74,   93
    SWAP( 9,13) :    3,    9,   20,   26,   38,   39,   46,   47,   48,   58,   93,   72,   65,   59,   74,   93
    SWAP(10,13) :    3,    9,   20,   26,   38,   39,   46,   47,   48,   58,   59,   72,   65,   93,   74,   93
    SWAP(11,12) :    3,    9,   20,   26,   38,   39,   46,   47,   48,   58,   59,   65,   72,   93,   74,   93
    SWAP(12,12) :    3,    9,   20,   26,   38,   39,   46,   47,   48,   58,   59,   65,   72,   93,   74,   93
    SWAP(13,14) :    3,    9,   20,   26,   38,   39,   46,   47,   48,   58,   59,   65,   72,   74,   93,   93
    SWAP(14,14) :    3,    9,   20,   26,   38,   39,   46,   47,   48,   58,   59,   65,   72,   74,   93,   93
    comp = 120
    ```

#### 3-6. 自動採点システムで動作確認
- 標準入力の部分をコメントアウトした場合には，動作確認の前に元に戻す．
